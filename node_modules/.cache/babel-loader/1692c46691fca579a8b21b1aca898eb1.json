{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Documents\\\\blockchain-dev\\\\ledgeit\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _window;\n\nfunction t(t) {\n  return t && \"object\" == typeof t && \"default\" in t ? t.default : t;\n}\n\nvar e = t(require(\"bitcoinsource\"));\nvar r = t(require(\"axios\"));\n\nfunction n(t, e, r, n, s, i, a) {\n  try {\n    var o = t[i](a);\n    var c = o.value;\n  } catch (t) {\n    return void r(t);\n  }\n\n  o.done ? e(c) : Promise.resolve(c).then(n, s);\n}\n\nfunction s(t) {\n  return function () {\n    var e = this,\n        r = arguments;\n    return new Promise(function (s, i) {\n      var a = t.apply(e, r);\n\n      function o(t) {\n        n(a, s, i, o, c, \"next\", t);\n      }\n\n      function c(t) {\n        n(a, s, i, o, c, \"throw\", t);\n      }\n\n      o(void 0);\n    });\n  };\n}\n\nfunction i(t, e, r) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = r, t;\n}\n\nfunction a(t, e) {\n  var r = Object.keys(t);\n\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(t);\n    e && (n = n.filter(function (e) {\n      return Object.getOwnPropertyDescriptor(t, e).enumerable;\n    })), r.push.apply(r, n);\n  }\n\n  return r;\n}\n\nfunction o(t) {\n  for (var e = 1; e < arguments.length; e++) {\n    var r = null != arguments[e] ? arguments[e] : {};\n    e % 2 ? a(Object(r), !0).forEach(function (e) {\n      i(t, e, r[e]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : a(Object(r)).forEach(function (e) {\n      Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n    });\n  }\n\n  return t;\n}\n\nfunction c(t, e) {\n  if (null == t) return {};\n  var r = {};\n  var n = Object.keys(t);\n  var s, i;\n\n  for (i = 0; i < n.length; i++) s = n[i], e.indexOf(s) >= 0 || (r[s] = t[s]);\n\n  return r;\n}\n\nfunction u(t, e) {\n  if (null == t) return {};\n  var r = c(t, e);\n  var n, s;\n\n  if (Object.getOwnPropertySymbols) {\n    var i = Object.getOwnPropertySymbols(t);\n\n    for (s = 0; s < i.length; s++) n = i[s], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n]);\n  }\n\n  return r;\n}\n\nfunction h(t, e) {\n  if (\"object\" != typeof t || null === t) return t;\n  var r = t[Symbol.toPrimitive];\n\n  if (void 0 !== r) {\n    var n = r.call(t, e || \"default\");\n    if (\"object\" != typeof n) return n;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === e ? String : Number)(t);\n}\n\nfunction p(t) {\n  var e = h(t, \"string\");\n  return \"symbol\" == typeof e ? e : String(e);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\n\nfunction d(t, e) {\n  var r = {};\n\n  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);\n\n  if (null != t && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var s = 0;\n\n    for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);\n  }\n\n  return r;\n}\n\nfunction l(t, e, r, n) {\n  return new (r || (r = Promise))(function (s, i) {\n    function a(t) {\n      try {\n        c(n.next(t));\n      } catch (t) {\n        i(t);\n      }\n    }\n\n    function o(t) {\n      try {\n        c(n.throw(t));\n      } catch (t) {\n        i(t);\n      }\n    }\n\n    function c(t) {\n      var e;\n      t.done ? s(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {\n        t(e);\n      })).then(a, o);\n    }\n\n    c((n = n.apply(t, e || [])).next());\n  });\n}\n\nvar v = process.env.BC_CHAIN || \"BSV\";\nvar f = process.env.BC_NETWORK || \"testnet\";\nvar g = process.env.BC_WOC_API_KEY || void 0;\n\nvar _ = parseInt(process.env.BC_DUST_LIMIT, 10) || 4e3;\n\nvar m = parseInt(process.env.BC_DEFAULT_FEE, 10) || (\"BSV\" === v ? 500 : 2500);\nvar w = parseInt(process.env.BC_SCRIPT_CHUNK_SIZE, 10) || 479;\nvar b;\nvar y;\nprocess.env.BC_BBS_URL ? (y = \"http://\".concat(process.env.BC_BBS_URL), b = \"ws://\".concat(process.env.BC_BBS_URL)) : (y = \"https://bbs.bitcoincomputer.io\", b = \"wss://bbs.bitcoincomputer.io\");\nvar O = {\n  CHAIN: v,\n  NETWORK: f,\n  WOC_API_KEY: g,\n  MIN_NON_DUST_AMOUNT: _,\n  SCRIPT_CHUNK_SIZE: w,\n  UN_P2SH_URL: y,\n  WS_URL: b,\n  DEFAULT_FEE: m\n};\ne.versionGuard = () => !0, e.Networks.defaultNetwork = e.Networks[O.NETWORK];\nconst S = e.PublicKey;\n\nconst x = () => \"__temp__:\" + Math.random();\n\nconst I = [\"_id\", \"_rev\", \"_owners\", \"_amount\", \"__vouts\", \"__txId\", \"__cls\", \"__func\", \"__index\", \"__args\"];\n\nconst P = t => Object.prototype.toString.call(t).match(/\\s([a-zA-Z]+)/)[1];\n\nconst j = t => \"object\" == typeof t ? P(t) : P(t).toLowerCase();\n\nconst T = t => [\"number\", \"string\", \"boolean\", \"undefined\", \"Null\"].includes(j(t));\n\nconst E = t => \"Array\" === j(t);\n\nconst C = t => \"Object\" === j(t);\n\nconst D = t => T(t) || [\"Array\", \"Object\"].includes(j(t));\n\nconst k = t => \"Object\" === j(t) && Object.keys(t).every(t => !Number.isNaN(parseInt(t, 10)));\n\nconst K = (t, e) => {\n  if (!D(t) || !D(e)) throw new Error(\"Unsupported data types for deep equals: \".concat(j(t), \" & \").concat(j(e)));\n  if (j(t) !== j(e)) return !1;\n  if (T(t) && T(e)) return t === e;\n\n  const r = (t, e) => Object.entries(t).every(([t, r]) => K(e[t], r));\n\n  return t && e && r(t, e) && r(e, t);\n};\n\nconst B = t => {\n  if (T(t)) return t;\n  if (E(t)) return t.map(B);\n\n  if (C(t)) {\n    const e = Object.keys(t).reduce((e, r) => (e[r] = B(t[r]), e), {});\n    const r = Object.create(Object.getPrototypeOf(t));\n    return Object.assign(r, e);\n  }\n\n  throw new Error(\"Unsupported data type for clone: \" + j(t));\n};\n\nconst N = (t, e) => t.reduce(([t, r], n, s) => e(n, s) ? [[...t, n], r] : [t, [...r, n]], [[], []]);\n\nconst U = (t, e) => Object.fromEntries(Object.entries(t).map(t => e(t)));\n\nconst A = (t, e) => U(t, ([t, r]) => [t, e(r)]);\n\nconst R = (t, e) => Object.fromEntries(Object.entries(t).filter(([, t]) => e(t)));\n\nconst H = (t, e) => {\n  if (T(t)) return t;\n\n  if (C(t)) {\n    const r = U(t, ([t, r]) => [t, I.includes(t) ? r : H(r, e)]);\n    const n = t._amount && void 0 !== t._amount ? t._amount : O.MIN_NON_DUST_AMOUNT;\n    const s = void 0 !== t._owners ? t._owners : [e];\n    return Object.assign(Object.assign({}, r), {\n      _amount: n,\n      _owners: s\n    });\n  }\n\n  if (E(t)) return t.map(t => H(t, e));\n  throw new Error(\"unsupported type \".concat(j(t), \" in setOwnersAndAmount\"));\n};\n\nconst L = (t, e, r, n) => {\n  if (T(t)) return t;\n  if (E(t)) return t.map(t => L(t, e, r, n));\n\n  if (C(t)) {\n    t._rev = \"\".concat(n, \":\").concat(r);\n    const s = e[r];\n    return Object.entries(t).forEach(([r, i]) => {\n      Object.keys(s).includes(r) && (t[r] = L(i, e, s[r], n));\n    }), t;\n  }\n\n  throw new Error(\"Unsupported type \".concat(j(t), \" in deep.updateRev\"));\n};\n\nconst M = t => T(t) ? t : E(t) ? t.map(M) : (C(t) && (t.__cls = t.constructor.toString(), Object.entries(t).forEach(([e, r]) => {\n  t[e] = M(r);\n})), t);\n\nconst F = t => {\n  if (T(t)) return t;\n  if (E(t)) return t.map(F);\n  if (C(t)) return t._id = !t._id || t._id.startsWith(\"__temp__\") ? t._rev : t._id, Object.entries(t).forEach(([e, r]) => {\n    t[e] = F(r);\n  }), t;\n  throw new Error(\"Unsupported type \".concat(j(t), \" in deep.addId\"));\n};\n\nconst V = t => {\n  if (E(t)) t.map(V);else if (C(t)) {\n    const e = x();\n    return t._id = t._id || e, t._rev = t._rev || e, Object.values(t).map(V), t._id;\n  }\n};\n\nfunction W(t) {\n  if (T(t)) return t;\n  if (E(t)) return t.map(W);\n  if (C(t)) return U(t, ([t, e]) => \"_owners\" === t ? [t, JSON.stringify(e)] : T(e) ? [t, e] : [t, W(e)]);\n  throw new Error(\"Unexpected type \".concat(j(t), \" in stringifyOwners\"));\n}\n\nconst $ = t => void 0 !== t._owners ? Object.assign(Object.assign({}, t), {\n  _owners: JSON.parse(t._owners).map(t => new S(t))\n}) : t;\n\nconst J = t => T(t) ? t : Object.entries(t).reduce((t, [e, r]) => {\n  const n = J(r);\n  return k(n) ? Object.entries(n).forEach(([r, n]) => {\n    t[\"\".concat(e, \"_\").concat(r)] = n;\n  }) : t[e] = n, t;\n}, {});\n\nconst z = t => {\n  const e = {\n    [t._id]: Object.entries(t).reduce((t, [e, r]) => I.includes(e) ? Object.assign(Object.assign({}, t), {\n      [e]: r\n    }) : T(r) ? Object.assign(Object.assign({}, t), {\n      [\"__basic__\" + e]: r\n    }) : Object.assign(Object.assign({}, t), {\n      [e]: r._id\n    }), {})\n  };\n  return Object.values(t).filter(t => !T(t)).reduce((t, e) => Object.assign(Object.assign({}, t), z(e)), e);\n};\n\nconst q = t => Object.fromEntries(Object.entries(t).filter(([t]) => !t.startsWith(\"__basic__\")));\n\nconst Z = (t, e) => Object.fromEntries(Object.entries(e).map(([e, r]) => {\n  const n = t[e];\n  var s;\n  return r.__change = (s = n) ? K(s, r) ? \"same\" : \"diff\" : \"new\", [e, r];\n}));\n\nconst G = (t, e) => (t[e].__contains = Object.entries(t[e]).reduce((e, [r, n]) => [\"__contains\"].concat(I).includes(r) ? e : \"__change\" === r ? \"new\" === n || \"diff\" === n || e : G(t, n)[n].__contains || e, !1), t);\n\nconst Y = t => t.reduce((t, e, r) => Object.assign(Object.assign({}, t), {\n  [e._id]: r\n}), {});\n\nconst Q = (t, e) => t.map(t => Object.entries(t).reduce((t, [r, n]) => {\n  const s = \"string\" == typeof n && \"undefined\" !== j(e[n]) ? e[n] : n;\n  return Object.assign(Object.assign({}, t), {\n    [r]: s\n  });\n}, {}));\n\nconst X = (t, e) => {\n  const r = V(e);\n  const n = B(t);\n  const s = B(e);\n  M(n), M(s);\n  const i = W(n);\n  const a = W(s);\n  const o = J(i);\n  const c = J(a);\n  const u = z(o);\n  const h = z(c);\n  const p = Z(u, h);\n  const l = A(p, q);\n  const v = G(l, r);\n  const f = v[r];\n  delete f.__cls, delete v[r];\n  const g = A(v, t => t._rev);\n\n  const _ = R(v, t => t.__contains || Object.values(f).includes(t._id));\n\n  const m = Object.values(_);\n\n  const _N = N(m, t => \"new\" === t.__change),\n        _N2 = _slicedToArray(_N, 2),\n        w = _N2[0],\n        b = _N2[1];\n\n  const y = [...b, ...w];\n  const O = Y(y);\n  const S = Q(y, O);\n\n  const _Q = Q([f], O),\n        _Q2 = _slicedToArray(_Q, 1),\n        x = _Q2[0];\n\n  const I = b.map(t => t._rev);\n  S.concat([x]).forEach(t => {\n    delete t._id, delete t._rev, delete t.__change, delete t.__contains;\n  });\n  const P = S.map(t => Object.entries(t).reduce((t, [e, r]) => Object.assign(Object.assign({}, t), {\n    [e]: g[r] || r\n  }), {})).map($).map((t, e) => e < I.length ? d(t, [\"__cls\"]) : t);\n  return [I, P, x];\n};\n\nvar tt = t => ({\n  smartArgs: t.filter(t => t._rev),\n  dumbArgs: t.map(t => t._rev ? \"__\" : t)\n});\n\nvar et = (t, e) => {\n  var r = 0;\n  return e.map(e => \"__\" === e ? t[r++] : e);\n};\n\nclass rt {\n  constructor(t) {\n    this.db = t;\n  }\n\n  construct(t, e) {\n    return l(this, void 0, void 0, function* () {\n      return (() => l(this, void 0, void 0, function* () {\n        const _B = B([e, {}]),\n              _B2 = _slicedToArray(_B, 2),\n              r = _B2[0],\n              n = _B2[1];\n\n        const s = new t(...e);\n\n        const _tt = tt(r),\n              i = _tt.smartArgs,\n              a = _tt.dumbArgs;\n\n        const _tt2 = tt(e),\n              o = _tt2.smartArgs;\n\n        const c = Object.assign(Object.assign(Object.assign({}, i), {\n          obj: n\n        }), {\n          _id: \"index\"\n        });\n        const u = Object.assign(Object.assign(Object.assign({}, o), {\n          obj: s\n        }), {\n          _id: \"index\"\n        });\n\n        const _X = X(c, u),\n              _X2 = _slicedToArray(_X, 3),\n              h = _X2[0],\n              p = _X2[1],\n              d = _X2[2];\n\n        void 0 !== p[0] && (p[0].__index = d);\n        const l = d.obj;\n        void 0 !== p[l] && (p[l].__func = \"constructor\", p[l].__args = a, p[l].__cls = t.toString());\n        const v = (yield this.db.update(h, p))[0].split(\":\")[0];\n        return Object.entries(d).forEach(([t, e]) => {\n          L(\"obj\" === t ? s : o[t], p, e, v);\n        }), F([s, ...o]), s;\n      }))();\n    });\n  }\n\n  call(t, e, r) {\n    return l(this, void 0, void 0, function* () {\n      const _B3 = B([r, t]),\n            _B4 = _slicedToArray(_B3, 2),\n            n = _B4[0],\n            s = _B4[1];\n\n      const i = Reflect.apply(t[e], t, r);\n\n      const _tt3 = tt(n),\n            a = _tt3.smartArgs,\n            o = _tt3.dumbArgs;\n\n      const _tt4 = tt(r),\n            c = _tt4.smartArgs;\n\n      const u = Object.assign(Object.assign(Object.assign({}, a), {\n        obj: s\n      }), {\n        _id: \"index\"\n      });\n      const h = Object.assign(Object.assign(Object.assign({}, c), {\n        obj: t\n      }), {\n        _id: \"index\"\n      });\n      \"Object\" === j(i) && (h.res = i);\n\n      const _X3 = X(u, h),\n            _X4 = _slicedToArray(_X3, 3),\n            p = _X4[0],\n            d = _X4[1],\n            l = _X4[2];\n\n      void 0 !== d[0] && (d[0].__index = l);\n      const v = l.obj;\n      void 0 !== d[v] && (d[v].__func = e, d[v].__args = o);\n\n      const _ref = yield this.db.update(p, d),\n            _ref2 = _slicedToArray(_ref, 1),\n            f = _ref2[0];\n\n      const _f$split = f.split(\":\"),\n            _f$split2 = _slicedToArray(_f$split, 1),\n            g = _f$split2[0];\n\n      return Object.entries(l).forEach(([e, r]) => {\n        \"obj\" === e && L(t, d, r, g), L(\"res\" === e ? i : c[e], d, r, g);\n      }), F([i, t, ...c]), i;\n    });\n  }\n\n  get(t, e) {\n    return \"function\" == typeof t[e] ? (...r) => this.call(t, e, r) : Reflect.get(t, e);\n  }\n\n}\n\nvar nt = e.PublicKey,\n    st = e.Signature,\n    it = e.Script,\n    at = e.Opcode;\n\nfunction ot(t, e) {\n  var r = [];\n  var n = 0;\n\n  for (; n < t.length;) r.push(t.slice(n, n + e)), n += e;\n\n  return r;\n}\n\nclass ct extends it {\n  static outScriptFromData(t) {\n    var e = t._owners,\n        r = t._amount,\n        n = t.__vouts,\n        s = t.__txId,\n        i = u(t, [\"_owners\", \"_amount\", \"__vouts\", \"__txId\"]);\n    var a = ot(Buffer.from(JSON.stringify(i)), O.SCRIPT_CHUNK_SIZE);\n    return a[a.length - 1].byteLength >= O.SCRIPT_CHUNK_SIZE && ot(a.pop(), O.SCRIPT_CHUNK_SIZE).forEach(t => {\n      a.push(t);\n    }), a.map(t => ({\n      redeemScript: ct.getScript(t, e),\n      chunk: t\n    }));\n  }\n\n  static getScript(t, e) {\n    var r = new ct();\n    return r.add(\"OP_1\"), e.forEach(t => r.add(t.toBuffer())), r.add(\"OP_\".concat(e.length)), r.add(\"OP_CHECKMULTISIG\"), r.add(t), r.add(\"OP_DROP\"), r;\n  }\n\n  getData() {\n    return this.isDbDataScript() ? JSON.parse(this.chunks[this.chunks.length - 2].buf.toString()) : {};\n  }\n\n  getPublicKeys() {\n    if (this.isDbDataScript()) return this.chunks.slice(1, this.chunks.length - 4).map(t => new nt(t.buf));\n    throw new Error(\"Cannot get owners from non-data script\");\n  }\n\n  isDbDataScript() {\n    return !!(this.chunks.length >= 5 && this.chunks[0].opcodenum === at.OP_1 && this.chunks[1].buf && [20, 33].includes(this.chunks[1].buf.length) && this.chunks[this.chunks.length - 3].opcodenum === at.OP_CHECKMULTISIG && this.chunks[this.chunks.length - 2].buf && this.chunks[this.chunks.length - 1].opcodenum === at.OP_DROP);\n  }\n\n  static isP2shScript(t) {\n    return !(3 !== t.chunks.length || t.chunks[0].opcodenum !== at.OP_0 || !t.chunks[1].buf || !t.chunks[2].buf);\n  }\n\n  static redeemScriptFromP2shScript(t) {\n    if (!this.isP2shScript(t)) throw new Error(\"not a p2sh script\");\n    var e = new it(t.chunks[2].buf);\n    var r = new this();\n    return r.chunks = e.chunks, r;\n  }\n\n  static fromScript(t) {\n    var e = new it(t);\n    var r = new ct();\n    return r.chunks = e.chunks, r;\n  }\n\n}\n\nfunction ut(t) {\n  return {\n    writable: !0,\n    value: t\n  };\n}\n\nfunction ht(t, e, r) {\n  var n = r[t];\n  return o({\n    [e]: n\n  }, u(r, [t].map(p)));\n}\n\nvar pt = e.Address,\n    dt = e.Transaction,\n    lt = e.PublicKey,\n    vt = e.Script;\nvar ft = new Map();\n\nclass gt {\n  constructor() {\n    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : O.CHAIN;\n    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O.NETWORK;\n    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : O.WOC_API_KEY;\n    this.chain = t, this.network = e, \"BSV\" === t && (this.wocApiKey = r);\n  }\n\n  getBaseUrl() {\n    if (\"BSV\" === this.chain) {\n      var t = \"livenet\" === this.network ? \"main\" : \"test\";\n      return \"https://api.whatsonchain.com/v1/bsv/\".concat(t);\n    }\n\n    var e = \"livenet\" === this.network ? \"rest\" : \"trest\";\n    return \"https://\".concat(e, \".bitcoin.com/v2\");\n  }\n\n  getRequestHeaders() {\n    return \"BSV\" === this.chain && this.wocApiKey ? {\n      \"woc-api-key\": this.wocApiKey\n    } : {};\n  }\n\n  unwrap(t) {\n    return s(function* () {\n      try {\n        return (yield t).data;\n      } catch (t) {\n        var e = t.message,\n            r = t.config,\n            n = t.response;\n        var s = r.url,\n            i = r.method,\n            a = r.data;\n        var o;\n\n        try {\n          o = JSON.parse(a);\n        } catch (t) {\n          o = null;\n        }\n\n        var c = o && o.txhex ? new dt(o.txhex) : null;\n        throw t.message = \"Communication Error\\n\\nmessage\\t\".concat(e, \"\\nrequest\\t\").concat(i, \" \").concat(s, \"\\n\").concat(c ? \"transaction\\t \".concat(JSON.stringify(c.toJSON(), null, 2)) : \"post\" !== i || c ? \"\" : \"data\\t\".concat(a), \"\\n\").concat(n ? \"response\\t\".concat(JSON.stringify(n.data)) : \"\"), t;\n      }\n    })();\n  }\n\n  get(t) {\n    var e = arguments,\n        n = this;\n    return s(function* () {\n      var s = e.length > 1 && void 0 !== e[1] && e[1] ? \"\" : n.getBaseUrl();\n      return n.unwrap(r.get(\"\".concat(s).concat(t), {\n        headers: n.getRequestHeaders()\n      }));\n    })();\n  }\n\n  post(t, e) {\n    var n = arguments,\n        i = this;\n    return s(function* () {\n      var s = n.length > 2 && void 0 !== n[2] && n[2] ? \"\" : i.getBaseUrl();\n      return i.unwrap(r.post(\"\".concat(s).concat(t), e, {\n        headers: i.getRequestHeaders()\n      }));\n    })();\n  }\n\n  getBalance(t) {\n    var e = this;\n    return s(function* () {\n      var r = \"/address/\".concat(t.toString(), \"/balance\");\n      var n = \"/address/details/\".concat(t.toString());\n      var s;\n\n      switch (e.chain) {\n        case \"BSV\":\n          return s = yield e.get(r), parseInt(s.confirmed, 10) + parseInt(s.unconfirmed, 10);\n\n        case \"BCH\":\n          return s = yield e.get(n), parseInt(s.balanceSat, 10) + parseInt(s.unconfirmedBalanceSat, 10);\n\n        default:\n          throw new Error(\"chain is not set in getBalance\");\n      }\n    })();\n  }\n\n  getTransaction(t) {\n    var e = this;\n    return s(function* () {\n      var r = yield e.getRawTransaction(t);\n      return new dt(r);\n    })();\n  }\n\n  getTransactionWithSpendingData(t) {\n    var e = this;\n    return s(function* () {\n      var _t$split, _t$split2;\n\n      if (\"testnet\" === e.network && \"BSV\" === e.chain) throw new Error(\"Restclient.getTransactionWithSpendingData is not supported on BSV testnet\");\n\n      switch ((_t$split = t.split(\":\"), _t$split2 = _slicedToArray(_t$split, 1), t = _t$split2[0], _t$split), e.chain) {\n        case \"BSV\":\n          var r = \"https://api.blockchair.com/bitcoin-sv/dashboards/transaction/\".concat(t);\n\n          var _ref3 = yield e.get(r, !0),\n              n = _ref3.data;\n\n          var _n$t = n[t],\n              s = _n$t.transaction,\n              i = _n$t.inputs,\n              a = _n$t.outputs;\n          return {\n            hex: \"\",\n            txid: s.hash,\n            hash: s.hash,\n            version: s.version,\n            size: s.size,\n            locktime: s.lock_time,\n            vin: i,\n            vout: a.map(t => ({\n              value: t.value,\n              n: t.index,\n              scriptPubKey: t.script_hex,\n              spentTxId: t.spending_transaction_id,\n              spentIndex: t.spending_index\n            })),\n            blockhash: \"unknown\",\n            confirmations: \"unknown\",\n            time: \"unknown\",\n            blocktime: \"unknown\"\n          };\n\n        case \"BCH\":\n          return e.get(\"/transaction/details/\".concat(t));\n\n        default:\n          throw new Error(\"chain is not set in getTransactionWithSpendingData\");\n      }\n    })();\n  }\n\n  getRawTransaction(t) {\n    var e = this;\n    return s(function* () {\n      var _t$split3 = t.split(\":\"),\n          _t$split4 = _slicedToArray(_t$split3, 1),\n          n = _t$split4[0];\n\n      var s = ft.get(n);\n      if (s) return s;\n      var i = \"livenet\" === e.network ? \"main\" : \"test\";\n      var a = yield e.unwrap(r.get(\"\".concat(O.UN_P2SH_URL, \"/tx/\").concat(e.chain, \"/\").concat(i, \"/\").concat(n)));\n      return ft.set(n, a), a;\n    })();\n  }\n\n  sendTransaction(t) {\n    var e = arguments,\n        r = this;\n    return s(function* () {\n      var n = e.length > 1 && void 0 !== e[1] && e[1];\n      var s;\n      if (\"BSV\" === r.chain) s = yield r.post(\"/tx/raw\", {\n        txhex: t.toString()\n      });else {\n        if (\"BCH\" !== r.chain) throw new Error(\"chain is not set in sendTransaction\");\n\n        var _ref4 = yield r.post(\"/rawtransactions/sendRawTransaction\", {\n          hexes: [t.toString()]\n        });\n\n        var _ref5 = _slicedToArray(_ref4, 1);\n\n        s = _ref5[0];\n      }\n\n      if (n) {\n        var i = t.outputData.map(t => {\n          var e = t._owners;\n\n          if (void 0 !== e) {\n            var r = e.map(t => t.toString());\n            return o(o({}, t), {\n              _owners: r\n            });\n          }\n\n          return t;\n        });\n        var a = JSON.stringify(i);\n        var c = t.toJSON().inputs.map(t => {\n          var e = t.prevTxId,\n              r = t.outputIndex;\n          return \"\".concat(e, \":\").concat(r);\n        });\n        yield r.postOutputData({\n          txId: s,\n          outputData: a,\n          inputs: c\n        });\n      }\n\n      return s;\n    })();\n  }\n\n  getUtxosFromAddress(t) {\n    var e = this;\n    return s(function* () {\n      var _ref6;\n\n      var r = [];\n      var n = \"\";\n\n      switch (e.chain) {\n        case \"BSV\":\n          return r = yield e.get(\"/address/\".concat(t.toString(), \"/unspent\")), Promise.all(r.map(t => {\n            var e = t.tx_hash,\n                r = t.tx_pos,\n                n = t.value;\n            return {\n              txId: e,\n              vout: r,\n              satoshis: n,\n              amount: n / 1e8\n            };\n          }).map(function () {\n            var t = s(function* (t) {\n              var r = (yield e.getTransaction(t.txId)).outputs[t.vout];\n              return t.scriptPubKey = r.script.toHex(), t;\n            });\n            return function (e) {\n              return t.apply(this, arguments);\n            };\n          }()));\n\n        case \"BCH\":\n          return (_ref6 = yield e.get(\"/address/utxo/\".concat(t.toString())), r = _ref6.utxos, n = _ref6.scriptPubKey, _ref6), r.map(t => o({\n            scriptPubKey: n\n          }, t)).map(t => {\n            var e = t.txid;\n            return o({\n              txId: e\n            }, u(t, [\"txid\"]));\n          });\n\n        default:\n          throw new Error(\"chain is not set in getUtxosFromAddress\");\n      }\n    })();\n  }\n\n  getTxosFromOutputData(t) {\n    var e = this;\n    return s(function* () {\n      var r = t.map(t => t.__txId);\n      var n = [...new Set(r)];\n      var i = new Map();\n      return yield Promise.all(n.map(function () {\n        var t = s(function* (t) {\n          return i.set(t, (yield e.getTransaction(t)));\n        });\n        return function (e) {\n          return t.apply(this, arguments);\n        };\n      }())), t.map(t => {\n        var _ref7 = i.get(t.__txId) || {},\n            e = _ref7.outputs,\n            r = _ref7.blockheight,\n            n = _ref7.confirmations;\n\n        return t.__vouts.map(s => {\n          var _e$s = e[s],\n              i = _e$s._scriptBuffer,\n              a = _e$s._satoshis;\n          return {\n            txId: t.__txId,\n            vout: s,\n            scriptPubKey: i.toString(\"hex\"),\n            amount: parseFloat(a / 1e8),\n            satoshis: parseInt(a, 10),\n            height: r,\n            confirmations: n\n          };\n        });\n      });\n    })();\n  }\n\n  postOutputData(t) {\n    var e = this;\n    return s(function* () {\n      return e.post(\"\".concat(O.UN_P2SH_URL, \"/\"), t, !0);\n    })();\n  }\n\n  getOutputData(t) {\n    var e = this;\n    return s(function* () {\n      return ((yield e.get(\"\".concat(O.UN_P2SH_URL, \"/un-p2sh/\").concat(t), !0)) || []).map(t => t._owners ? o(o({}, t), {\n        _owners: t._owners.map(t => new lt(t))\n      }) : t);\n    })();\n  }\n\n  getOwnedRevs(t) {\n    var e = this;\n    return s(function* () {\n      return e.get(\"\".concat(O.UN_P2SH_URL, \"/txos/\").concat(t.toString()), !0);\n    })();\n  }\n\n  getLatestRev(t) {\n    var e = this;\n    return s(function* () {\n      var _ref8 = yield e.get(\"\".concat(O.UN_P2SH_URL, \"/get-rev/\").concat(t), !0),\n          _ref9 = _slicedToArray(_ref8, 1),\n          r = _ref9[0].rev;\n\n      return r;\n    })();\n  }\n\n  setTxoSpent(t) {\n    var e = this;\n    return s(function* () {\n      var _t$split5 = t.split(\":\"),\n          _t$split6 = _slicedToArray(_t$split5, 2),\n          r = _t$split6[0],\n          n = _t$split6[1];\n\n      return e.post(\"\".concat(O.UN_P2SH_URL, \"/txos/set-spent/\"), {\n        txId: r,\n        virtualIndex: parseInt(n, 10)\n      }, !0);\n    })();\n  }\n\n}\n\nvar _t = e.Transaction,\n    mt = e.PublicKey,\n    wt = e.Address,\n    bt = e.BN,\n    yt = e.Script,\n    Ot = e.encoding;\nvar St = _t.Output,\n    xt = _t.Input;\nvar It = xt.MultiSigScriptHash,\n    Pt = xt.PublicKeyHashInput;\nvar jt = Ot.BufferReader;\n\nvar Tt = t => new Promise(e => setTimeout(e, t));\n\nclass Et extends _t {\n  constructor(t, e, r) {\n    super(r), this._outputData = [], this.restClient = new gt(t, e), this.feePerKb(O.DEFAULT_FEE), Object.defineProperty(this, \"to\", ut(this._to)), Object.defineProperty(this, \"from\", ut(this._from));\n  }\n\n  get chain() {\n    return this.restClient.chain;\n  }\n\n  get network() {\n    return this.restClient.network;\n  }\n\n  static fromRedeemScripts(t) {\n    var e = t.map(t => t.chunks[t.chunks.length - 2].buf);\n    var r = Buffer.concat(e);\n    var n = JSON.parse(r.toString());\n    return o({\n      _owners: t[0].getPublicKeys(),\n      _amount: O.MIN_NON_DUST_AMOUNT\n    }, n);\n  }\n\n  static addVouts(t) {\n    var e = 0;\n    return t.map(t => {\n      var r = ct.outScriptFromData(t).length;\n      return t.__vouts = Array(r).fill(e).map((t, e) => t + e), e += r, t;\n    });\n  }\n\n  get dataInputs() {\n    var t = [];\n\n    var e = function* (t) {\n      for (var e of t) yield e;\n    }(this.inputs);\n\n    var r = e.next();\n\n    for (; !r.done;) {\n      var n = r.value;\n      var s = ct.fromScript(n._scriptBuffer);\n\n      if (ct.isP2shScript(s)) {\n        var i = !1;\n        var a = [ct.redeemScriptFromP2shScript(s)];\n\n        for (; !i;) try {\n          t.push(Et.fromRedeemScripts(a)), i = !0;\n        } catch (t) {\n          var o = e.next();\n          if (o.done) throw new Error(\"Could not compute data inputs\");\n          var c = o.value;\n          var u = ct.fromScript(c._scriptBuffer);\n          a.push(ct.redeemScriptFromP2shScript(u));\n        }\n      }\n\n      r = e.next();\n    }\n\n    return t;\n  }\n\n  set dataInputs(t) {\n    throw Error(\"dataTransaction.dataInputs cannot be set directly, use dataTransaction.from or dataTransaction.fromDataOutput\");\n  }\n\n  getVirtualInputs() {\n    var t = this;\n    return s(function* () {\n      if (\"BSV\" === t.chain) return (yield Promise.all(t.inputs.map(function () {\n        var e = s(function* (e) {\n          var r = e.prevTxId,\n              n = e.outputIndex;\n          var s = e.prevTxId.toString(\"hex\");\n          var i = (yield Et.fromTxId(s, t.chain, t.network)).outputs[n];\n          return !!ct.fromScript(i._scriptBuffer).isDbDataScript() && e;\n        });\n        return function (t) {\n          return e.apply(this, arguments);\n        };\n      }()))).filter(t => !!t).map(t => \"\".concat(t.prevTxId.toString(\"hex\"), \":\").concat(t.outputIndex));\n\n      if (\"BCH\" === t.chain) {\n        var e = t.dataInputs;\n        var r = Et.addVouts(e);\n        return Promise.all(r.map(function () {\n          var e = s(function* (e) {\n            var r = [];\n\n            e.__vouts.forEach(e => {\n              r.push(t.inputs[e]);\n            });\n\n            var n = r[0].prevTxId.toString(\"hex\");\n            var s = yield Et.fromTxId(n, t.chain, t.network);\n            yield s.fetchOutputData();\n            var i = Et.addVouts(s.outputData);\n            var a = [];\n            i.forEach((t, e) => {\n              K(t.__vouts, r.map(t => t.outputIndex)) && a.push(e);\n            });\n            var o = a[0];\n            return \"\".concat(n, \":\").concat(o);\n          });\n          return function (t) {\n            return e.apply(this, arguments);\n          };\n        }()));\n      }\n\n      throw new Error(\"chain not set in getVirtualInputs\");\n    })();\n  }\n\n  fromMultiSig(t, e, r) {\n    var n = t.map(t => ht(\"txId\", \"txid\", t));\n    return super.from(n, e, r);\n  }\n\n  _from(t, e, r) {\n    var n = ht(\"txId\", \"txid\", t);\n    return super.from(n, e, r);\n  }\n\n  fromDataOutput(t, e) {\n    var r = ct.outScriptFromData(e);\n    var n = e._owners;\n    return r.forEach((e, r) => {\n      var s = e.redeemScript;\n      var _t$r = t[r],\n          i = _t$r.scriptPubKey,\n          a = _t$r.satoshis,\n          o = _t$r.txId,\n          c = _t$r.vout;\n      var u = new St({\n        script: new ct(i),\n        satoshis: parseInt(a, 10)\n      });\n      var h = new ct();\n      var p = new It({\n        prevTxId: o,\n        output: u,\n        outputIndex: c,\n        script: h\n      }, n, 1, null, s);\n      this.addInput(p);\n    }), this;\n  }\n\n  get outputData() {\n    if (\"BSV\" === this.chain) return this.outputs.filter(t => ct.fromScript(t._scriptBuffer).isDbDataScript()).map(t => {\n      var _ref10 = t._script || t.script,\n          e = _ref10.chunks;\n\n      var r = e[e.length - 2].buf;\n      var n = JSON.parse(r.toString());\n      var s = e.slice(1, e.length - 4);\n      return n._owners = s.map(t => new mt(t.buf).toString()), n._amount = t._satoshis, n;\n    });\n    if (\"BCH\" === this.chain) return this._outputData;\n    throw new Error(\"Chain not set in dataTransaction get outputdata\");\n  }\n\n  set outputData(t) {\n    throw Error(\"dataTransaction.outputData cannot be set directly\");\n  }\n\n  toData(t) {\n    if (\"BSV\" === this.chain) {\n      var e = t._owners,\n          r = t._amount,\n          n = u(t, [\"_owners\", \"_amount\"]);\n      var s = Buffer.from(JSON.stringify(n));\n      var i = ct.getScript(s, e);\n      var a = new St({\n        script: i,\n        satoshis: r\n      });\n      return this.addOutput(a), this.outputs.length - 1;\n    }\n\n    if (\"BCH\" === this.chain) {\n      var o = ct.outScriptFromData(t);\n      return this._outputData.push(t), o.forEach(e => {\n        var r = e.redeemScript,\n            n = e.chunk;\n        var s = ct.buildScriptHashOut(r);\n        var i = t._amount;\n        var a = new St({\n          script: s,\n          satoshis: i\n        });\n        this.addOutput(a);\n      }), this._outputData.length - 1;\n    }\n\n    throw new Error(\"chain not set in dataScript.toScriptOutput\");\n  }\n\n  _to(t, e) {\n    return t && t._owners && t._amount && !e ? this.toData(t) : super.to(t, e);\n  }\n\n  fetchOutputData() {\n    var t = this;\n    return s(function* () {\n      if (!t._outputData.length) {\n        var e = t.getTxId();\n        \"BSV\" === t.chain ? t._outputData = t.outputs.map(t => {\n          var e = ct.fromScript(t._scriptBuffer);\n          var r = t._satoshis;\n\n          if (e.isDbDataScript()) {\n            var n = e.getPublicKeys().map(t => t.toString());\n            return Object.assign(e.getData(), {\n              _amount: r,\n              _owners: n\n            });\n          }\n\n          if (e.isPublicKeyHashOut()) {\n            var s = e.getPublicKeyHash();\n            return {\n              address: wt.fromPublicKeyHash(s)\n            };\n          }\n\n          throw new Error(\"Unrecognized output script \".concat(e.toString()));\n        }) : \"BCH\" === t.chain && (t._outputData = yield t.restClient.getOutputData(e));\n      }\n    })();\n  }\n\n  get prevObjectIds() {\n    return this.inputs.map(t => \"\".concat(t.prevTxId.toString(\"hex\"), \":\").concat(t.outputIndex));\n  }\n\n  getTxId() {\n    return new jt(this._getHash()).readReverse().toString(\"hex\");\n  }\n\n  getChangeIndex() {\n    return this._changeIndex;\n  }\n\n  static fromTxId(t, e, r) {\n    return s(function* () {\n      var n = null;\n      var s = new gt(e, r);\n\n      try {\n        n = yield s.getRawTransaction(t);\n      } catch (e) {\n        yield Tt(3e3), n = yield s.getRawTransaction(t);\n      }\n\n      var i = new Et(e, r);\n      return i.fromString(n), i;\n    })();\n  }\n\n}\n\nclass Ct {\n  constructor(t, e, r = {}) {\n    const _r$path = r.path,\n          n = _r$path === void 0 ? \"m/44'/0'/0'/0\" : _r$path,\n          _r$passphrase = r.passphrase,\n          s = _r$passphrase === void 0 ? \"\" : _r$passphrase;\n    this.mnemonic = t, this.path = n, this.passphrase = s, this.restClient = e, this.utoxsSyncing = !1, this.hdPrivateKey = this.mnemonic.toHDPrivateKey(this.passphrase, O.NETWORK), this.path && (this.hdPrivateKey = this.hdPrivateKey.derive(this.path)), this.utxos = [], this.syncUtxos();\n  }\n\n  get chain() {\n    return this.restClient.chain;\n  }\n\n  get network() {\n    return this.restClient.network;\n  }\n\n  getMnemonic() {\n    return this.mnemonic;\n  }\n\n  getPath() {\n    return this.path;\n  }\n\n  getUtxos() {\n    return this.utxos;\n  }\n\n  derive(t = 0, e = !1) {\n    const r = new Ct(this.mnemonic, this.restClient);\n    return r.path = \"\".concat(this.path).concat(this.path.length ? \"/\" : \"\").concat(t).concat(e ? \"'\" : \"\"), r.hdPrivateKey = this.hdPrivateKey.derive(t, e), r;\n  }\n\n  static getHdPrivateKey() {\n    return new e.HDPrivateKey();\n  }\n\n  getPrivateKey() {\n    return this.hdPrivateKey.privateKey;\n  }\n\n  getPublicKey() {\n    return this.hdPrivateKey.publicKey;\n  }\n\n  getAddress() {\n    return this.address = this.address || this.getPublicKey().toAddress(this.network), this.address;\n  }\n\n  syncUtxos() {\n    return l(this, void 0, void 0, function* () {\n      this.utoxsSyncing = !0, this.utxos = yield this.restClient.getUtxosFromAddress(this.getAddress()), this.utoxsSyncing = !1;\n    });\n  }\n\n  waitUntilSynced() {\n    return l(this, void 0, void 0, function* () {\n      for (; this.utoxsSyncing;) yield new Promise(t => setTimeout(t, 300));\n    });\n  }\n\n  getBalance() {\n    return l(this, void 0, void 0, function* () {\n      const t = this.getAddress();\n      return this.restClient.getBalance(t.toString());\n    });\n  }\n\n  getBalanceLowerBounds() {\n    return l(this, void 0, void 0, function* () {\n      return yield this.waitUntilSynced(), this.utxos.reduce((t, e) => t + e.satoshis, 0);\n    });\n  }\n\n  getUtxosToSpend(t) {\n    return l(this, void 0, void 0, function* () {\n      yield this.waitUntilSynced();\n\n      for (let t = this.utxos.length - 1; t > 0; t -= 1) {\n        const e = Math.floor(Math.random() * (t + 1));\n        var _ref11 = [this.utxos[e], this.utxos[t]];\n        this.utxos[t] = _ref11[0];\n        this.utxos[e] = _ref11[1];\n      }\n\n      return this.getUtxosWithSatoshis(t);\n    });\n  }\n\n  getUtxosWithSatoshis(t) {\n    let e = 0;\n    const r = [];\n    let n = 0;\n\n    for (; e < t && n < this.utxos.length;) r.push(this.utxos[n]), e += this.utxos[n].satoshis, n += 1;\n\n    if (e >= t) return r;\n    throw new Error(\"Insufficient balance in address \".concat(this.getAddress().toString(), \" on \").concat(O.NETWORK, \" \").concat(O.CHAIN, \". Found \").concat(e, \", required \").concat(t, \".\"));\n  }\n\n  fundAndSendTransaction(t, e = !1) {\n    return l(this, void 0, void 0, function* () {\n      t.feePerKb(O.DEFAULT_FEE);\n      const r = t._estimateFee() + 100;\n      const n = yield this.getUtxosToSpend(t._getOutputAmount() - t._getInputAmount() + r);\n      n.forEach(e => t.from(e)), t.change(this.getAddress()), t.sign(this.getPrivateKey()), yield this.restClient.sendTransaction(t, e), this.utxos = this.utxos.filter(t => !n.includes(t));\n      const s = t.getChangeOutput();\n      return s && this.utxos.push({\n        txId: t.getTxId(),\n        vout: t.getChangeIndex(),\n        satoshis: s.satoshis,\n        amount: s.satoshis / 1e8,\n        scriptPubKey: s.script.toHex()\n      }), t;\n    });\n  }\n\n  send(t, e) {\n    return l(this, void 0, void 0, function* () {\n      const r = new Et(this.chain, this.network).to(e, t);\n      return this.fundAndSendTransaction(r);\n    });\n  }\n\n}\n\nvar Dt = e.HDPrivateKey,\n    kt = e.Mnemonic,\n    Kt = e.Transaction,\n    Bt = e.Script,\n    Nt = e.PublicKey;\n\nclass Ut {\n  constructor(t) {\n    this.wallet = t;\n  }\n\n  get chain() {\n    return this.wallet.chain;\n  }\n\n  get network() {\n    return this.wallet.network;\n  }\n\n  put(t) {\n    var e = this;\n    return s(function* () {\n      return e.update([], t);\n    })();\n  }\n\n  getOutputDataMap(t) {\n    var e = this;\n    return s(function* () {\n      var r = [...new Set(t)];\n      var n = yield Promise.all(r.map(function () {\n        var t = s(function* (t) {\n          var r = yield e.wallet.restClient.getOutputData(t);\n          var n = 0;\n          var s = r.map(e => {\n            var r = ct.outScriptFromData(e).length;\n            var s = Array(r).fill(n).map((t, e) => t + e);\n            return n += r, void 0 !== e._owners && (e._owners = e._owners.map(t => new Nt(t))), o(o({}, e), {}, {\n              __vouts: s,\n              __txId: t\n            });\n          });\n          return [t, s];\n        });\n        return function (e) {\n          return t.apply(this, arguments);\n        };\n      }()));\n      return new Map(n);\n    })();\n  }\n\n  get(t) {\n    var e = this;\n    return s(function* () {\n      if (\"BSV\" === e.chain) {\n        var r = t.map(t => t.split(\":\")[0]);\n        var n = [...new Set(r)];\n        var i = yield Promise.all(n.map(function () {\n          var t = s(function* (t) {\n            return [t, yield e.wallet.restClient.getTransaction(t)];\n          });\n          return function (e) {\n            return t.apply(this, arguments);\n          };\n        }()));\n        var a = new Map(i);\n        return Promise.all(t.map(function () {\n          var t = s(function* (t) {\n            var _t$split7 = t.split(\":\"),\n                _t$split8 = _slicedToArray(_t$split7, 2),\n                e = _t$split8[0],\n                r = _t$split8[1];\n\n            var n = a.get(e).outputs[parseInt(r, 10)];\n            var s = ct.fromScript(n.script);\n            return Object.assign(s.getData(), {\n              __txId: e,\n              __vouts: [parseInt(r, 10)],\n              _owners: s.getPublicKeys(),\n              _amount: Math.round(n.satoshis)\n            });\n          });\n          return function (e) {\n            return t.apply(this, arguments);\n          };\n        }()));\n      }\n\n      if (\"BCH\" === e.chain) {\n        var o = t.map(t => t.split(\":\")[0]);\n        var c = yield e.getOutputDataMap(o);\n        return t.map(t => {\n          var _t$split9 = t.split(\":\"),\n              _t$split10 = _slicedToArray(_t$split9, 2),\n              e = _t$split10[0],\n              r = _t$split10[1];\n\n          var n = c.get(e);\n          if (!n || !Array.isArray(n)) throw new Error(\"No data found.\");\n          return n[parseInt(r, 10)];\n        });\n      }\n\n      throw new Error(\"chain not set in db.get\");\n    })();\n  }\n\n  getUpdateTxBch(t, e, r) {\n    var n = this;\n    return s(function* () {\n      var r = new Et(n.chain, n.network);\n      var i = yield n.get(t);\n      var a = yield n.wallet.restClient.getTxosFromOutputData(i);\n      t.forEach(function () {\n        var t = s(function* (t, e) {\n          r.fromDataOutput(a[e], i[e]);\n        });\n        return function (e, r) {\n          return t.apply(this, arguments);\n        };\n      }());\n      var o = H(e, n.wallet.getPublicKey()).map(t => r.to(t));\n      return {\n        transaction: r = yield n.wallet.fundAndSendTransaction(r, !0),\n        virtualIndices: o\n      };\n    })();\n  }\n\n  getUpdateTxBsv(t, e, r) {\n    var n = this;\n    return s(function* () {\n      var r = new Et(n.chain, n.network);\n      (yield Promise.all(t.map(function () {\n        var t = s(function* (t) {\n          var _t$split11 = t.split(\":\"),\n              _t$split12 = _slicedToArray(_t$split11, 2),\n              e = _t$split12[0],\n              r = _t$split12[1];\n\n          var s = yield n.wallet.restClient.getTransaction(e);\n          var _s$outputs$parseInt = s.outputs[parseInt(r, 10)],\n              i = _s$outputs$parseInt.script,\n              a = _s$outputs$parseInt.satoshis;\n          var o = ct.fromScript(i);\n          return {\n            output: {\n              txId: e,\n              outputIndex: parseInt(r, 10),\n              scriptPubKey: o,\n              satoshis: Math.round(a)\n            },\n            publicKeys: o.getPublicKeys(),\n            nr: 1\n          };\n        });\n        return function (e) {\n          return t.apply(this, arguments);\n        };\n      }()))).forEach(t => {\n        var e = t.output,\n            n = t.publicKeys,\n            s = t.nr;\n        r.from(e, n, s);\n      });\n      var i = H(e, n.wallet.getPublicKey()).map(t => r.to(t));\n      return r = yield n.wallet.fundAndSendTransaction(r, !0), yield r.fetchOutputData(), {\n        transaction: r,\n        virtualIndices: i\n      };\n    })();\n  }\n\n  update(t, e) {\n    var r = this;\n    return s(function* () {\n      var n = e.reduce((t, e) => t + parseInt(e._amount, 10), 0);\n\n      if (\"BSV\" === r.chain) {\n        var _ref12 = yield r.getUpdateTxBsv(t, e, n),\n            i = _ref12.transaction,\n            a = _ref12.virtualIndices;\n\n        return yield Promise.all(t.map(function () {\n          var t = s(function* (t) {\n            yield r.wallet.restClient.setTxoSpent(t);\n          });\n          return function (e) {\n            return t.apply(this, arguments);\n          };\n        }())), a.map(t => \"\".concat(i.getTxId(), \":\").concat(t));\n      }\n\n      if (\"BCH\" === r.chain) {\n        var _ref13 = yield r.getUpdateTxBch(t, e, n),\n            o = _ref13.transaction,\n            c = _ref13.virtualIndices;\n\n        return t.forEach(function () {\n          var t = s(function* (t) {\n            yield r.wallet.restClient.setTxoSpent(t);\n          });\n          return function (e) {\n            return t.apply(this, arguments);\n          };\n        }()), c.map(t => \"\".concat(o.getTxId(), \":\").concat(t));\n      }\n\n      throw new Error(\"Chain not set in db.update \".concat(r.chain));\n    })();\n  }\n\n}\n\nvar At;\n\nif (\"undefined\" == typeof window) {\n  var _require = require(\"node-localstorage\"),\n      Rt = _require.LocalStorage;\n\n  At = new Rt(\"./uls-scratch\");\n} else void 0 !== window.localStorage && (_window = window, At = _window.localStorage, _window);\n\nvar Ht = At;\n\nclass Lt {\n  static serialize(t) {\n    return JSON.stringify(Object.entries(t));\n  }\n\n  static deserialize(t, e) {\n    var r = e ? new e() : {};\n    return JSON.parse(t).forEach(t => {\n      var _t2 = _slicedToArray(t, 2),\n          e = _t2[0],\n          n = _t2[1];\n\n      return r[e] = n;\n    }), r;\n  }\n\n  static set(t) {\n    if (void 0 === t._rev) throw new Error(\"Rev not set in Cache.set\");\n    var e = \"Object\" === t.constructor.name ? JSON.stringify({\n      data: Lt.serialize(t)\n    }) : JSON.stringify({\n      data: Lt.serialize(t),\n      clazz: t.constructor.toString()\n    });\n    return Ht.setItem(t._rev, e), t._rev;\n  }\n\n  static get(t) {\n    var _ref14 = JSON.parse(Ht.getItem(t || \"\")) || {},\n        e = _ref14.data,\n        r = _ref14.clazz;\n\n    if (e) {\n      var n = \"string\" == typeof r ? eval(\"(\".concat(r, \")\")) : void 0;\n      return this.deserialize(e, n);\n    }\n\n    return null;\n  }\n\n}\n\nclass Mt {\n  constructor(t, e) {\n    this.chain = t, this.network = e;\n  }\n\n  get(t) {\n    return l(this, void 0, void 0, function* () {\n      const e = Lt.get(t);\n      if (e) return e;\n\n      const _t$split13 = t.split(\":\"),\n            _t$split14 = _slicedToArray(_t$split13, 2),\n            r = _t$split14[0],\n            n = _t$split14[1];\n\n      const s = yield Et.fromTxId(r, this.chain, this.network);\n      yield s.fetchOutputData();\n      const i = s.outputData;\n      const a = i[0].__index;\n      const _i$a$obj = i[a.obj],\n            o = _i$a$obj.__cls,\n            c = _i$a$obj.__func,\n            u = _i$a$obj.__args;\n      const h = yield s.getVirtualInputs();\n      const p = yield Promise.all(Object.values(a).map(t => l(this, void 0, void 0, function* () {\n        return h[t] ? this.get(h[t]) : Promise.resolve({});\n      })));\n      const d = Object.keys(a).map((t, e) => [t, p[e]]);\n      const v = Object.fromEntries(d);\n      let f = v.obj;\n      delete v.obj;\n      const g = Object.entries(v).reduce((t, [e, r]) => (Number.isNaN(parseInt(e, 10)) || (t[parseInt(e, 10)] = r), t), []);\n\n      const _ = et(g, u);\n\n      let m;\n\n      if (\"constructor\" === c) {\n        const t = eval(\"(\".concat(o, \")\"));\n        f = new t(..._);\n      } else {\n        const t = f[c].bind(f);\n        m = Reflect.apply(t, f, _);\n      }\n\n      const w = a;\n      return Object.entries(w).forEach(([t, e]) => {\n        \"obj\" === t && L(f, i, e, r), L(\"res\" === t ? m : g[t], i, e, r);\n      }), F([f, m, ...g]), [f, m, ...g].filter(t => !T(t)).map(Lt.set), [...g, f, m][n];\n    });\n  }\n\n}\n\nvar Ft = e.Mnemonic,\n    Vt = e.PublicKey;\n\nclass Wt {\n  constructor() {\n    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n    var e = t.seed,\n        _t$chain = t.chain,\n        r = _t$chain === void 0 ? O.CHAIN : _t$chain,\n        _t$network = t.network,\n        n = _t$network === void 0 ? O.NETWORK : _t$network,\n        _t$mnemonic = t.mnemonic,\n        s = _t$mnemonic === void 0 ? new Ft(e) : _t$mnemonic,\n        i = t.wocApiKey,\n        _t$path = t.path,\n        a = _t$path === void 0 ? \"m/44'/0'/0'/0\" : _t$path,\n        _t$passphrase = t.passphrase,\n        o = _t$passphrase === void 0 ? \"\" : _t$passphrase;\n    this.restClient = new gt(r, n, i);\n    var _t$db = t.db,\n        c = _t$db === void 0 ? new Ut(new Ct(s, this.restClient, {\n      path: a,\n      passphrase: o\n    })) : _t$db;\n    this.db = c, this.reader = new Mt(this.chain, this.network);\n  }\n\n  get chain() {\n    return this.db.chain;\n  }\n\n  get network() {\n    return this.db.network;\n  }\n\n  static parseContract(t) {\n    return \"string\" === j(t) && (t = t.startsWith(\"export \") ? t.slice(7) : t, t = t.startsWith(\"default \") ? t.slice(8) : t, t = \"(\".concat(t, \")\"), t = eval(t)), t;\n  }\n\n  new(t, e) {\n    var r = this;\n    return s(function* () {\n      var n = new rt(r.db);\n      var s = yield Wt.parseContract(t);\n      var i = new Proxy(s, n);\n      var a = yield new i(...e);\n      return new Proxy(a, n);\n    })();\n  }\n\n  sync(t) {\n    var e = this;\n    return s(function* () {\n      var r = yield e.reader.get(t);\n      var n = new rt(e.db);\n      return new Proxy(r, n);\n    })();\n  }\n\n  getOwnedRevs() {\n    var t = arguments,\n        e = this;\n    return s(function* () {\n      var r = t.length > 0 && void 0 !== t[0] ? t[0] : e.db.wallet.getPublicKey();\n      return e.db.wallet.restClient.getOwnedRevs(r);\n    })();\n  }\n\n  getRevs() {\n    var t = arguments,\n        e = this;\n    return s(function* () {\n      var r = t.length > 0 && void 0 !== t[0] ? t[0] : e.db.wallet.getPublicKey();\n      return (yield e.db.wallet.restClient.getOwnedRevs(r)).map(t => {\n        var e = t.txId,\n            r = t.virtualIndex;\n        return \"\".concat(e, \":\").concat(r);\n      });\n    })();\n  }\n\n  getLatestRev(t) {\n    var e = this;\n    return s(function* () {\n      return e.db.wallet.restClient.getLatestRev(t);\n    })();\n  }\n\n  syncWallet() {\n    var t = this;\n    return s(function* () {\n      t.db.wallet.syncWallet();\n    })();\n  }\n\n}\n\nmodule.exports = Wt;","map":null,"metadata":{},"sourceType":"script"}