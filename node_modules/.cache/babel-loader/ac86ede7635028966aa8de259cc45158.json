{"ast":null,"code":"/**\n * https://github.com/the-bitcoin-token/bitcoin-source\n * Copyright (c) 2019 Bitcoin Computer\n * Copyright (c) 2019 Brenton Gunning\n * Copyright (c) 2018 Janez Urevc\n * Copyright (c) 2018-2019 Clemens Ley\n * Copyright (c) 2017-2018 Emilio Almansi\n * Copyright (c) 2013-2017 BitPay, Inc.\n * Copyright (c) 2009-2015 The Bitcoin Core developers\n * Copyright (c) 2014 Ryan X. Charles\n * Copyright (c) 2014 reddit, Inc.\n * Copyright (c) 2011 Stefan Thomas <justmoon@members.fsf.org>\n * Copyright (c) 2011 Google Inc.\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nimport _ from 'lodash';\nimport elliptic from 'elliptic';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport cashaddr from 'cashaddrjs';\nimport hash from 'hash.js';\nimport assert from 'assert';\nimport randomBytes from 'randombytes';\nimport bufferCompare from 'buffer-compare';\nimport unorm from 'unorm';\nimport URL from 'url';\nvar docsURL = 'http://bitcore.io/';\nvar data = [{\n  name: 'InvalidB58Char',\n  message: 'Invalid Base58 character: {0} in {1}'\n}, {\n  name: 'InvalidB58Checksum',\n  message: 'Invalid Base58 checksum for {0}'\n}, {\n  name: 'InvalidNetwork',\n  message: 'Invalid version for network: got {0}'\n}, {\n  name: 'InvalidState',\n  message: 'Invalid state: {0}'\n}, {\n  name: 'NotImplemented',\n  message: 'Function {0} was not implemented yet'\n}, {\n  name: 'InvalidNetworkArgument',\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\n}, {\n  name: 'InvalidArgument',\n\n  message() {\n    return \"Invalid Argument\".concat((arguments.length <= 0 ? undefined : arguments[0]) ? \": \".concat(arguments.length <= 0 ? undefined : arguments[0]) : '').concat((arguments.length <= 1 ? undefined : arguments[1]) ? \" Documentation: \".concat(docsURL).concat(arguments.length <= 1 ? undefined : arguments[1]) : '');\n  }\n\n}, {\n  name: 'AbstractMethodInvoked',\n  message: 'Abstract Method Invocation: {0}'\n}, {\n  name: 'InvalidArgumentType',\n\n  message() {\n    return \"Invalid Argument for \".concat(arguments.length <= 2 ? undefined : arguments[2], \", expected \").concat(arguments.length <= 1 ? undefined : arguments[1], \" but got \").concat(typeof (arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n}, {\n  name: 'Unit',\n  message: 'Internal Error on Unit {0}',\n  errors: [{\n    name: 'UnknownCode',\n    message: 'Unrecognized unit code: {0}'\n  }, {\n    name: 'InvalidRate',\n    message: 'Invalid exchange rate: {0}'\n  }]\n}, {\n  name: 'Transaction',\n  message: 'Internal Error on Transaction {0}',\n  errors: [{\n    name: 'Input',\n    message: 'Internal Error on Input {0}',\n    errors: [{\n      name: 'MissingScript',\n      message: 'Need a script to create an input'\n    }, {\n      name: 'UnsupportedScript',\n      message: 'Unsupported input script type: {0}'\n    }, {\n      name: 'MissingPreviousOutput',\n      message: 'No previous output information.'\n    }]\n  }, {\n    name: 'NeedMoreInfo',\n    message: '{0}'\n  }, {\n    name: 'InvalidSorting',\n    message: 'The sorting function provided did not return the change output as one of the array elements'\n  }, {\n    name: 'InvalidOutputAmountSum',\n    message: '{0}'\n  }, {\n    name: 'MissingSignatures',\n    message: 'Some inputs have not been fully signed'\n  }, {\n    name: 'InvalidIndex',\n    message: 'Invalid index: {0} is not between 0, {1}'\n  }, {\n    name: 'UnableToVerifySignature',\n    message: 'Unable to verify signature: {0}'\n  }, {\n    name: 'DustOutputs',\n    message: 'Dust amount detected in one output'\n  }, {\n    name: 'InvalidSatoshis',\n    message: 'Output satoshis are invalid'\n  }, {\n    name: 'FeeError',\n    message: 'Internal Error on Fee {0}',\n    errors: [{\n      name: 'TooSmall',\n      message: 'Fee is too small: {0}'\n    }, {\n      name: 'TooLarge',\n      message: 'Fee is too large: {0}'\n    }, {\n      name: 'Different',\n      message: 'Unspent value is different from specified fee: {0}'\n    }]\n  }, {\n    name: 'ChangeAddressMissing',\n    message: 'Change address is missing'\n  }, {\n    name: 'BlockHeightTooHigh',\n    message: 'Block Height can be at most 2^32 -1'\n  }, {\n    name: 'NLockTimeOutOfRange',\n    message: 'Block Height can only be between 0 and 499 999 999'\n  }, {\n    name: 'LockTimeTooEarly',\n    message: \"Lock Time can't be earlier than UNIX date 500 000 000\"\n  }]\n}, {\n  name: 'Script',\n  message: 'Internal Error on Script {0}',\n  errors: [{\n    name: 'UnrecognizedAddress',\n    message: 'Expected argument {0} to be an address'\n  }, {\n    name: 'CantDeriveAddress',\n    message: \"Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.\"\n  }, {\n    name: 'InvalidBuffer',\n    message: \"Invalid script buffer: can't parse valid script from given buffer {0}\"\n  }]\n}, {\n  name: 'HDPrivateKey',\n  message: 'Internal Error on HDPrivateKey {0}',\n  errors: [{\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\n  }, {\n    name: 'InvalidEntropyArgument',\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\n    errors: [{\n      name: 'TooMuchEntropy',\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\n    }, {\n      name: 'NotEnoughEntropy',\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\n    }]\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xprivkey string in {0}'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path: {0}'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\n  }]\n}, {\n  name: 'HDPublicKey',\n  message: 'Internal Error on HDPublicKey {0}',\n  errors: [{\n    name: 'ArgumentIsPrivateExtended',\n    message: 'Argument is an extended private key: {0}'\n  }, {\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument: got {0}'\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xpubkey: got \"{0}\"'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\n  }, {\n    name: 'InvalidIndexCantDeriveHardened',\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\n  }, {\n    name: 'MustSupplyArgument',\n    message: 'Must supply an argument to create a HDPublicKey'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\n  }]\n}, {\n  name: 'Mnemonic',\n  message: 'Internal Error on bitcore-mnemonic module {0}',\n  errors: [{\n    name: 'InvalidEntropy',\n    message: 'Entropy length must be an even multiple of 11 bits: {0}'\n  }, {\n    name: 'UnknownWordlist',\n    message: 'Could not detect the used word list: {0}'\n  }, {\n    name: 'InvalidMnemonic',\n    message: 'Mnemonic string is invalid: {0}'\n  }]\n}];\n\nfunction format(message, args) {\n  return message.replace('{0}', args[0]).replace('{1}', args[1]).replace('{2}', args[2]);\n}\n\nvar traverseNode = function traverseNode(parent, errorDefinition) {\n  var NodeError = function NodeError() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (_.isString(errorDefinition.message)) {\n      this.message = format(errorDefinition.message, args);\n    } else if (_.isFunction(errorDefinition.message)) {\n      this.message = errorDefinition.message.apply(null, args);\n    } else {\n      throw new Error(\"Invalid error definition for \".concat(errorDefinition.name));\n    }\n\n    this.stack = \"\".concat(this.message, \"\\n\").concat(new Error().stack);\n  };\n\n  NodeError.prototype = Object.create(parent.prototype);\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\n  parent[errorDefinition.name] = NodeError;\n\n  if (errorDefinition.errors) {\n    // eslint-disable-next-line no-use-before-define\n    childDefinitions(NodeError, errorDefinition.errors);\n  }\n\n  return NodeError;\n}; // TODO Try to get rid of this and copy the body into the callers.\n\n\nvar childDefinitions = function childDefinitions(parent, children) {\n  _.each(children, child => traverseNode(parent, child));\n};\n\nvar traverseRoot = function traverseRoot(parent, errorsDefinition) {\n  childDefinitions(parent, errorsDefinition);\n  return parent;\n};\n\nvar bitcore = {};\n\nbitcore.Error = function () {\n  this.message = 'Internal error';\n  this.stack = \"\".concat(this.message, \"\\n\").concat(new Error().stack);\n};\n\nbitcore.Error.prototype = Object.create(Error.prototype);\nbitcore.Error.prototype.name = 'bitcore.Error';\ntraverseRoot(bitcore.Error, data);\n\nbitcore.Error.extend = function (spec) {\n  return traverseNode(bitcore.Error, spec);\n};\n\nvar errors = bitcore.Error;\nvar preconditions = {\n  checkState(condition, message) {\n    if (!condition) {\n      throw new errors.InvalidState(message);\n    }\n  },\n\n  checkArgument(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\n    }\n  },\n\n  checkArgumentType(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        if (!Buffer.isBuffer(argument)) {\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\n        } // eslint-disable-next-line valid-typeof\n\n      } else if (typeof argument !== type) {\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\n      }\n    } else if (!(argument instanceof type)) {\n      throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n    }\n  }\n\n};\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\n\nvar Base58 = function Base58(obj) {\n  if (!(this instanceof Base58)) {\n    return new Base58(obj);\n  }\n\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58.validCharacters = function validCharacters(chars) {\n  if (Buffer.isBuffer(chars)) {\n    chars = chars.toString();\n  }\n\n  return _.every(_.map(chars, char => _.includes(ALPHABET, char)));\n};\n\nBase58.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58.encode = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Input should be a buffer');\n  }\n\n  return bs58.encode(buf);\n};\n\nBase58.decode = function (str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n\n  return Buffer.from(bs58.decode(str));\n};\n\nBase58.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.fromString = function (str) {\n  var buf = Base58.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nBase58.prototype.toString = function () {\n  return Base58.encode(this.buf);\n};\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\n\n\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n/**\n * @namespace JSUtil\n */\n\n\nvar JSUtil = {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON: function isValidJSON(arg) {\n    var parsed;\n\n    if (!_.isString(arg)) {\n      return false;\n    }\n\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n\n    if (typeof parsed === 'object') {\n      return true;\n    }\n\n    return false;\n  },\n  isHexa,\n  isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray(array) {\n    return [].concat(array);\n  },\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable: function defineImmutable(target, values) {\n    Object.keys(values).forEach(key => {\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  },\n\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber: function isNaturalNumber(value) {\n    return typeof value === 'number' && Number.isFinite(value) && Math.floor(value) === value && value >= 0;\n  }\n};\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var length = a.length;\n\n  for (var i = 0; i < length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar BufferUtil = {\n  /**\n   * Fill a buffer with a value.\n   *\n   * @param {Buffer} buff\n   * @param {number} value\n   * @return {Buffer}\n   */\n  fill: function fill(buff, value) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    preconditions.checkArgumentType(value, 'number', 'value');\n    var length = buff.length;\n\n    for (var i = 0; i < length; i += 1) {\n      buff[i] = value;\n    }\n\n    return buff;\n  },\n\n  /**\n   * Return a copy of a buffer\n   *\n   * @param {Buffer} original\n   * @return {Buffer}\n   */\n  copy(original) {\n    var buff = Buffer.alloc(original.length);\n    original.copy(buff);\n    return buff;\n  },\n\n  /**\n   * Returns true if the given argument is an instance of a buffer. Tests for\n   * both node's Buffer and Uint8Array\n   *\n   * @param {*} arg\n   * @return {boolean}\n   */\n  isBuffer: function isBuffer(arg) {\n    return Buffer.isBuffer(arg) || arg instanceof Uint8Array;\n  },\n\n  /**\n   * Returns a zero-filled byte array\n   *\n   * @param {number} bytes\n   * @return {Buffer}\n   */\n  emptyBuffer: function emptyBuffer(bytes) {\n    preconditions.checkArgumentType(bytes, 'number', 'bytes');\n    var result = Buffer.alloc(bytes);\n\n    for (var i = 0; i < bytes; i += 1) {\n      result.write('\\0', i);\n    }\n\n    return result;\n  },\n\n  /**\n   * Concatenates a buffer\n   *\n   * Shortcut for <tt>Buffer.concat</tt>\n   */\n  concat: Buffer.concat,\n  equals,\n  equal: equals,\n\n  /**\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\n    preconditions.checkArgumentType(integer, 'number', 'integer');\n    return Buffer.from([integer & 0xff]);\n  },\n\n  /**\n   * Transform a 4-byte integer into a Buffer of length 4.\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsBuffer: function integerAsBuffer(integer) {\n    preconditions.checkArgumentType(integer, 'number', 'integer');\n    var bytes = [];\n    bytes.push(integer >> 24 & 0xff);\n    bytes.push(integer >> 16 & 0xff);\n    bytes.push(integer >> 8 & 0xff);\n    bytes.push(integer & 0xff);\n    return Buffer.from(bytes);\n  },\n\n  /**\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\n   *\n   * @param {Buffer} buff\n   * @return {number}\n   */\n  integerFromBuffer: function integerFromBuffer(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff[0] << 24 | buff[1] << 16 | buff[2] << 8 | buff[3];\n  },\n\n  /**\n   * Transforms the first byte of an array into a number ranging from -128 to 127\n   * @param {Buffer} buff\n   * @return {number}\n   */\n  integerFromSingleByteBuffer: function integerFromBuffer(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff[0];\n  },\n\n  /**\n   * Transforms a buffer into a string with a number in hexa representation\n   *\n   * Shorthand for <tt>buffer.toString('hex')</tt>\n   *\n   * @param {Buffer} buff\n   * @return {string}\n   */\n  bufferToHex: function bufferToHex(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff.toString('hex');\n  },\n\n  /**\n   * Reverse a buffer\n   * @param {Buffer} param\n   * @return {Buffer}\n   */\n  reverse: function reverse(param) {\n    var ret = Buffer.alloc(param.length);\n\n    for (var i = 0; i < param.length; i += 1) {\n      ret[i] = param[param.length - i - 1];\n    }\n\n    return ret;\n  },\n\n  /**\n   * Transforms an hexa encoded string into a Buffer with binary values\n   *\n   * Shorthand for <tt>Buffer(string, 'hex')</tt>\n   *\n   * @param {string} string\n   * @return {Buffer}\n   */\n  hexToBuffer: function hexToBuffer(string) {\n    assert(JSUtil.isHexa(string));\n    return Buffer.from(string, 'hex');\n  }\n};\nBufferUtil.NULL_HASH = BufferUtil.fill(Buffer.alloc(32), 0);\nBufferUtil.EMPTY_BUFFER = Buffer.alloc(0);\nvar Hash = {};\n\nHash.sha1 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha1().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha256().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.ripemd160().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha256ripemd160 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha512().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function (hashf, data, key) {\n  // http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  // http://tools.ietf.org/html/rfc4868#section-2\n  preconditions.checkArgument(BufferUtil.isBuffer(data));\n  preconditions.checkArgument(BufferUtil.isBuffer(key));\n  preconditions.checkArgument(hashf.blocksize);\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var oKey = Buffer.alloc(blocksize);\n  oKey.fill(0x5c);\n  var iKey = Buffer.alloc(blocksize);\n  iKey.fill(0x36);\n  var oKeyPad = Buffer.alloc(blocksize);\n  var iKeyPad = Buffer.alloc(blocksize);\n\n  for (var i = 0; i < blocksize; i += 1) {\n    oKeyPad[i] = oKey[i] ^ key[i];\n    iKeyPad[i] = iKey[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([oKeyPad, hashf(Buffer.concat([iKeyPad, data]))]));\n};\n\nHash.sha256hmac = function (data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function (data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n\nvar Base58Check = function Base58Check(obj) {\n  if (!(this instanceof Base58Check)) return new Base58Check(obj);\n\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58Check.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58Check.validChecksum = function validChecksum(data, checksum) {\n  if (_.isString(data)) {\n    data = Buffer.from(Base58.decode(data));\n  }\n\n  if (_.isString(checksum)) {\n    checksum = Buffer.from(Base58.decode(checksum));\n  }\n\n  if (!checksum) {\n    checksum = data.slice(-4);\n    data = data.slice(0, -4);\n  }\n\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\n};\n\nBase58Check.decode = function (s) {\n  if (typeof s !== 'string') throw new Error('Input must be a string');\n  var buf = Buffer.from(Base58.decode(s));\n  if (buf.length < 4) throw new Error('Input string too short');\n  var data = buf.slice(0, -4);\n  var csum = buf.slice(-4);\n  var hash = Hash.sha256sha256(data);\n  var hash4 = hash.slice(0, 4);\n  if (csum.toString('hex') !== hash4.toString('hex')) throw new Error('Checksum mismatch');\n  return data;\n};\n\nBase58Check.checksum = function (buff) {\n  return Hash.sha256sha256(buff).slice(0, 4);\n};\n\nBase58Check.encode = function (buf) {\n  if (!Buffer.isBuffer(buf)) throw new Error('Input must be a buffer');\n  var checkedBuf = Buffer.alloc(buf.length + 4);\n  var hash = Base58Check.checksum(buf);\n  buf.copy(checkedBuf);\n  hash.copy(checkedBuf, buf.length);\n  return Base58.encode(checkedBuf);\n};\n\nBase58Check.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.fromString = function (str) {\n  var buf = Base58Check.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nBase58Check.prototype.toString = function () {\n  return Base58Check.encode(this.buf);\n};\n\nvar networks = [];\nvar networkMaps = {};\n/**\n * A network is merely a map containing values that correspond to version\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\n * (a.k.a. \"mainnet\") and \"testnet\".\n * @constructor\n */\n\nfunction Network() {}\n\nNetwork.prototype.toString = function toString() {\n  return this.name;\n};\n/**\n * @function\n * @member Networks#get\n * Retrieves the network associated with a magic number or string.\n * @param {string|number|Network} arg\n * @param {string|Array} keys - if set, only check if the magic number associated with this name\n *   matches\n * @return Network\n */\n\n\nfunction get(arg, keys) {\n  if (~networks.indexOf(arg)) {\n    return arg;\n  }\n\n  if (keys) {\n    if (!_.isArray(keys)) {\n      keys = [keys];\n    }\n\n    var index = networks.findIndex(network => _.some(keys, key => network[key] === arg));\n\n    if (index !== -1) {\n      return networks[index];\n    }\n\n    return undefined;\n  }\n\n  return networkMaps[arg];\n}\n/**\n * @function\n * @member Networks#add\n * Will add a custom Network\n * @param {Object} data\n * @param {string} data.name - The name of the network\n * @param {string} data.alias - The aliased name of the network\n * @param {Number} data.pubkeyhash - The publickey hash prefix\n * @param {Number} data.privatekey - The privatekey prefix\n * @param {Number} data.scripthash - The scripthash prefix\n * @param {Number} data.xpubkey - The extended public key magic\n * @param {Number} data.xprivkey - The extended private key magic\n * @param {Number} data.networkMagic - The network magic number\n * @param {Number} data.port - The network port\n * @param {Array}  data.dnsSeeds - An array of dns seeds\n * @return Network\n */\n\n\nfunction addNetwork(data) {\n  var network = new Network();\n  JSUtil.defineImmutable(network, {\n    name: data.name,\n    alias: data.alias,\n    pubkeyhash: data.pubkeyhash,\n    privatekey: data.privatekey,\n    scripthash: data.scripthash,\n    xpubkey: data.xpubkey,\n    xprivkey: data.xprivkey\n  });\n\n  if (data.networkMagic) {\n    JSUtil.defineImmutable(network, {\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\n    });\n  }\n\n  if (data.port) {\n    JSUtil.defineImmutable(network, {\n      port: data.port\n    });\n  }\n\n  if (data.dnsSeeds) {\n    JSUtil.defineImmutable(network, {\n      dnsSeeds: data.dnsSeeds\n    });\n  }\n\n  _.each(network, value => {\n    if (!_.isUndefined(value) && !_.isObject(value)) {\n      networkMaps[value] = network;\n    }\n  });\n\n  networks.push(network);\n  return network;\n}\n/**\n * @function\n * @member Networks#remove\n * Will remove a custom network\n * @param {Network} network\n */\n\n\nfunction removeNetwork(network) {\n  for (var i = 0; i < networks.length; i += 1) {\n    if (networks[i] === network) {\n      networks.splice(i, 1);\n    }\n  }\n\n  Object.keys(networkMaps).forEach(objectKey => {\n    if (networkMaps[objectKey] === network) {\n      delete networkMaps[objectKey];\n    }\n  });\n}\n\naddNetwork({\n  name: 'livenet',\n  alias: 'mainnet',\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  xpubkey: 0x0488b21e,\n  xprivkey: 0x0488ade4,\n  networkMagic: 0xf9beb4d9,\n  port: 8333,\n  dnsSeeds: ['seed.bitcoin.sipa.be', 'dnsseed.bluematt.me', 'dnsseed.bitcoin.dashjr.org', 'seed.bitcoinstats.com', 'seed.bitnodes.io', 'bitseed.xf2.org']\n});\n/**\n * @instance\n * @member Networks#livenet\n */\n\nvar livenet = get('livenet');\naddNetwork({\n  name: 'testnet',\n  alias: 'regtest',\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394\n});\n/**\n * @instance\n * @member Networks#testnet\n */\n\nvar testnet = get('testnet'); // Add configurable values for testnet/regtest\n\nvar TESTNET = {\n  PORT: 18333,\n  NETWORK_MAGIC: BufferUtil.integerAsBuffer(0x0b110907),\n  DNS_SEEDS: ['testnet-seed.bitcoin.petertodd.org', 'testnet-seed.bluematt.me', 'testnet-seed.alexykot.me', 'testnet-seed.bitcoin.schildbach.de']\n};\nObject.keys(TESTNET).forEach(objectKey => {\n  if (!_.isObject(TESTNET[objectKey])) {\n    networkMaps[TESTNET[objectKey]] = testnet;\n  }\n});\nvar REGTEST = {\n  PORT: 18444,\n  NETWORK_MAGIC: BufferUtil.integerAsBuffer(0xfabfb5da),\n  DNS_SEEDS: []\n};\nObject.keys(REGTEST).forEach(objectKey => {\n  if (!_.isObject(REGTEST[objectKey])) {\n    networkMaps[REGTEST[objectKey]] = testnet;\n  }\n});\nObject.defineProperty(testnet, 'port', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.PORT;\n    }\n\n    return TESTNET.PORT;\n  }\n\n});\nObject.defineProperty(testnet, 'networkMagic', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.NETWORK_MAGIC;\n    }\n\n    return TESTNET.NETWORK_MAGIC;\n  }\n\n});\nObject.defineProperty(testnet, 'dnsSeeds', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.DNS_SEEDS;\n    }\n\n    return TESTNET.DNS_SEEDS;\n  }\n\n});\n/**\n * @function\n * @member Networks#enableRegtest\n * Will enable regtest features for testnet\n */\n\nfunction enableRegtest() {\n  testnet.regtestEnabled = true;\n}\n/**\n * @function\n * @member Networks#disableRegtest\n * Will disable regtest features for testnet\n */\n\n\nfunction disableRegtest() {\n  testnet.regtestEnabled = false;\n}\n/**\n * @namespace Networks\n */\n\n\nvar Networks = {\n  add: addNetwork,\n  remove: removeNetwork,\n  defaultNetwork: livenet,\n  livenet,\n  mainnet: livenet,\n  testnet,\n  get,\n  enableRegtest,\n  disableRegtest\n};\n\nvar reversebuf = function reversebuf(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function (n) {\n  preconditions.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function (str, base) {\n  preconditions.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\n\n\nBN.fromSM = function (buf, opts) {\n  var ret;\n\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n\n  if (opts) {\n    endian = opts.endian;\n  }\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] &= 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n\n  return ret;\n};\n\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function (opts) {\n  var buf;\n  var hex;\n\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] |= 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\n\n\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  preconditions.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\n\n\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function (buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n\n  for (var _i = 0; _i < size - natlen; _i += 1) {\n    rbuf[_i] = 0;\n  }\n\n  return rbuf;\n};\n\nvar ec = elliptic.curves.secp256k1;\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\n\nvar Point = function Point(x, y, isRed) {\n  var point;\n\n  try {\n    point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid point on curve');\n  }\n\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\n\nPoint.fromX = function fromX(odd, x) {\n  var point;\n\n  try {\n    point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid x value for curve.');\n  }\n\n  point.validate();\n  return point;\n};\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\n\n\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\n\n\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\n\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\n\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\n\n\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve.');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  } // todo: needs test case\n\n\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return BufferUtil.concat([prefix, xbuf]);\n}; //      \n\n\nvar Random = {};\n\nRandom.getRandomBufferNode = function (size) {\n  return randomBytes(size);\n};\n\nRandom.getRandomBufferBrowser = function (size) {\n  var windowCrypto;\n\n  if (window.crypto && window.crypto.getRandomValues) {\n    windowCrypto = window.crypto;\n  } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n    // internet explorer\n    windowCrypto = window.msCrypto;\n  } else {\n    throw new Error('window crypto.getRandomValues not available');\n  }\n\n  var bbuf = new Uint8Array(size);\n  windowCrypto.getRandomValues(bbuf);\n  var buf = Buffer.from(bbuf);\n  return buf;\n};\n/* secure random bytes that sometimes throws an error due to lack of entropy */\n\n\nRandom.getRandomBuffer = function (size) {\n  if (typeof window !== 'undefined' && (typeof window.crypto !== 'undefined' || typeof window.msCrypto !== 'undefined')) {\n    return Random.getRandomBufferBrowser(size);\n  }\n\n  return Random.getRandomBufferNode(size);\n};\n/* insecure random bytes, but it never fails */\n\n\nRandom.getPseudoRandomBuffer = function (size) {\n  var b32 = 0x100000000;\n  var b = Buffer.alloc(size);\n  var r = 0;\n\n  for (var i = 0; i <= size; i += 1) {\n    var j = Math.floor(i / 4);\n    var k = i - j * 4;\n\n    if (k === 0) {\n      r = Math.random() * b32;\n      b[i] = r & 0xff;\n    } else {\n      b[i] = (r >>>= 8) & 0xff;\n    }\n  }\n\n  return b;\n};\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\n\n\nfunction PrivateKey(data, network) {\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network); // validation\n\n\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n\n  if (typeof info.network === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n  return this;\n}\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\n\n\nPrivateKey.prototype._classifyArguments = function (data, network) {\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  }; // detect type of data\n\n  if (_.isUndefined(data) || _.isNull(data)) {\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network) {\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof data === 'string') {\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n\n  return info;\n};\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\n\n\nPrivateKey._getRandomBN = function () {\n  var condition;\n  var bn;\n\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n\n  return bn;\n};\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformBuffer = function (buf, network) {\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n  return info;\n};\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\n\n\nPrivateKey._transformBNBuffer = function (buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformWIF = function (str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\n\n\nPrivateKey.fromBuffer = function (arg, network) {\n  return new PrivateKey(arg, network);\n};\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformObject = function (json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn,\n    network,\n    compressed: json.compressed\n  };\n};\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromWIF = function (str) {\n  preconditions.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\nPrivateKey.fromString = PrivateKey.fromWIF;\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\n\nPrivateKey.fromObject = function (obj) {\n  preconditions.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromRandom = function (network) {\n  var bn = PrivateKey._getRandomBN();\n\n  return new PrivateKey(bn, network);\n};\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\n\nPrivateKey.getValidationError = function (data, network) {\n  var error;\n\n  try {\n    // #weirdstuff Refactor.\n    // eslint-disable-next-line no-new\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\n\n\nPrivateKey.isValid = function (data, network) {\n  if (!data) {\n    return false;\n  }\n\n  return !PrivateKey.getValidationError(data, network);\n};\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\n\n\nPrivateKey.prototype.toString = function () {\n  return this.toBuffer().toString('hex');\n};\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\n\n\nPrivateKey.prototype.toWIF = function () {\n  var buf;\n\n  if (this.compressed) {\n    buf = Buffer.concat([Buffer.from([this.network.privatekey]), this.bn.toBuffer({\n      size: 32\n    }), Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([this.network.privatekey]), this.bn.toBuffer({\n      size: 32\n    })]);\n  }\n\n  return Base58Check.encode(buf);\n};\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\n\n\nPrivateKey.prototype.toBigNumber = function () {\n  return this.bn;\n};\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBuffer = function () {\n  // TODO: use `return this.bn.toBuffer({ size: 32 })` in v1.0.0\n  return this.bn.toBuffer();\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBufferNoPadding = function () {\n  return this.bn.toBuffer();\n};\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\n\n\nPrivateKey.prototype.toPublicKey = function () {\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n\n  return this._pubkey;\n};\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\n\n\nPrivateKey.prototype.toAddress = function (network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n/**\n * @returns {Object} A plain object representation\n */\n\n\nPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON;\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\n\nPrivateKey.prototype.inspect = function () {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return \"<PrivateKey: \".concat(this.toString(), \", network: \").concat(this.network).concat(uncompressed, \">\");\n};\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\n\n\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  preconditions.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra); // validation\n\n\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Networks.defaultNetwork\n  });\n  return this;\n}\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\n\n\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  }; // detect type of data\n\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Networks.get(extra.network);\n  }\n\n  return info;\n};\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isPrivateKey = function (param) {\n  return param instanceof PrivateKey;\n};\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformPrivateKey = function (privkey) {\n  preconditions.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformDER = function (buf, strict) {\n  preconditions.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n\n  return info;\n};\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformX = function (odd, x) {\n  preconditions.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPrivateKey = function (privkey) {\n  preconditions.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n\n  var info = PublicKey._transformPrivateKey(privkey);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromBuffer = function (buf, strict) {\n  preconditions.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n\n  var info = PublicKey._transformDER(buf, strict);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\nPublicKey.fromDER = PublicKey.fromBuffer;\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\nPublicKey.fromPoint = function (point, compressed) {\n  preconditions.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromString = function (str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n\n  var info = PublicKey._transformDER(buf);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\n\n\nPublicKey.getValidationError = function (data) {\n  var error;\n\n  try {\n    // #weirdstuff Refactor.\n    // eslint-disable-next-line no-new\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\n\n\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n/**\n * @returns {Object} A plain object of the PublicKey\n */\n\n\nPublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON;\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\n\nPublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  }\n\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return Buffer.concat([prefix, xbuf]);\n};\n\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER;\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\n\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\n\n\nPublicKey.prototype.toAddress = function (network) {\n  return Address.fromPublicKey(this, network || this.network);\n};\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\n\n\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\n\n\nPublicKey.prototype.inspect = function () {\n  return \"<PublicKey: \".concat(this.toString()).concat(this.compressed ? '' : ', uncompressed', \">\");\n};\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n\n  if (_.isUndefined(buf)) {\n    return undefined;\n  }\n\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf\n    });\n  } else if (_.isString(buf)) {\n    var b = Buffer.from(buf, 'hex');\n\n    if (b.length * 2 !== buf.length) {\n      throw new TypeError('Invalid hex string');\n    }\n\n    this.set({\n      buf: b\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function () {\n  return this.pos >= this.buf.length;\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function (len) {\n  preconditions.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos += len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function () {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function () {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos += 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function () {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos += 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function () {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos += 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function () {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function () {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readInt32LE = function () {\n  var val = this.buf.readInt32LE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function () {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos += 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function () {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = first * 0x100000000 + second; // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n\n  var bn;\n\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n\n  this.pos += 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xfd:\n      return this.readUInt16LE();\n\n    case 0xfe:\n      return this.readUInt32LE();\n\n    case 0xff:\n      {\n        var n = this.readUInt64LEBN().toNumber();\n\n        if (n <= 2 ** 53) {\n          return n;\n        }\n\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n\n    default:\n      return first;\n  }\n};\n/**\n * reads a length prepended buffer\n */\n\n\nBufferReader.prototype.readVarLengthBuffer = function () {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  preconditions.checkState(buf.length === len, \"Invalid length while reading varlength buffer. Expected: \".concat(len, \", Received: \").concat(buf.length));\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function () {\n  var first = this.buf.readUInt8(this.pos);\n\n  switch (first) {\n    case 0xfd:\n      return this.read(1 + 2);\n\n    case 0xfe:\n      return this.read(1 + 4);\n\n    case 0xff:\n      return this.read(1 + 8);\n\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xfd:\n      return new BN(this.readUInt16LE());\n\n    case 0xfe:\n      return new BN(this.readUInt32LE());\n\n    case 0xff:\n      return this.readUInt64LEBN();\n\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function () {\n  var buf = Buffer.alloc(this.buf.length);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function (len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos += len;\n  return BufferUtil.reverse(buf);\n};\n\nvar BufferWriter = function BufferWriter(obj) {\n  if (!(this instanceof BufferWriter)) return new BufferWriter(obj);\n  if (obj) this.set(obj);else this.bufs = [];\n};\n\nBufferWriter.prototype.set = function (obj) {\n  this.bufs = obj.bufs || this.bufs || [];\n  return this;\n};\n\nBufferWriter.prototype.toBuffer = function () {\n  return this.concat();\n};\n\nBufferWriter.prototype.concat = function () {\n  return Buffer.concat(this.bufs);\n};\n\nBufferWriter.prototype.write = function (buf) {\n  assert(BufferUtil.isBuffer(buf));\n  this.bufs.push(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeReverse = function (buf) {\n  assert(BufferUtil.isBuffer(buf));\n  this.bufs.push(BufferUtil.reverse(buf));\n  return this;\n};\n\nBufferWriter.prototype.writeUInt8 = function (n) {\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16BE = function (n) {\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16LE = function (n) {\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32BE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeInt32LE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32LE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64BEBN = function (bn) {\n  var buf = bn.toBuffer({\n    size: 8\n  });\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64LEBN = function (bn) {\n  var buf = bn.toBuffer({\n    size: 8\n  });\n  this.writeReverse(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintNum = function (n) {\n  var buf = BufferWriter.varintBufNum(n);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintBN = function (bn) {\n  var buf = BufferWriter.varintBufBN(bn);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.varintBufNum = function (n) {\n  var buf;\n\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    buf = Buffer.alloc(1 + 8);\n    buf.writeUInt8(255, 0);\n    buf.writeInt32LE(n & -1, 1);\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n  }\n\n  return buf;\n};\n\nBufferWriter.varintBufBN = function (bn) {\n  var buf;\n  var n = bn.toNumber();\n\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    var bw = new BufferWriter();\n    bw.writeUInt8(255);\n    bw.writeUInt64LEBN(bn);\n    buf = bw.concat();\n  }\n\n  return buf;\n};\n\nfunction Opcode(num) {\n  if (!(this instanceof Opcode)) {\n    return new Opcode(num);\n  }\n\n  var value;\n\n  if (_.isNumber(num)) {\n    value = num;\n  } else if (_.isString(num)) {\n    value = Opcode.map[num];\n  } else {\n    throw new TypeError(\"Unrecognized num type: \\\"\".concat(typeof num, \"\\\" for Opcode\"));\n  }\n\n  JSUtil.defineImmutable(this, {\n    num: value\n  });\n  return this;\n}\n\nOpcode.fromBuffer = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return new Opcode(Number(\"0x\".concat(buf.toString('hex'))));\n};\n\nOpcode.fromNumber = function (num) {\n  preconditions.checkArgument(_.isNumber(num));\n  return new Opcode(num);\n};\n\nOpcode.fromString = function (str) {\n  preconditions.checkArgument(_.isString(str));\n  var value = Opcode.map[str];\n\n  if (typeof value === 'undefined') {\n    throw new TypeError('Invalid opcodestr');\n  }\n\n  return new Opcode(value);\n};\n\nOpcode.prototype.toHex = function () {\n  return this.num.toString(16);\n};\n\nOpcode.prototype.toBuffer = function () {\n  return Buffer.from(this.toHex(), 'hex');\n};\n\nOpcode.prototype.toNumber = function () {\n  return this.num;\n};\n\nOpcode.prototype.toString = function () {\n  var str = Opcode.reverseMap[this.num];\n\n  if (typeof str === 'undefined') {\n    throw new Error('Opcode does not have a string representation');\n  }\n\n  return str;\n};\n\nOpcode.smallInt = function (n) {\n  preconditions.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\n  preconditions.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\n\n  if (n === 0) {\n    return Opcode('OP_0');\n  }\n\n  return new Opcode(Opcode.map.OP_1 + n - 1);\n};\n\nOpcode.map = {\n  // push value\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  // control\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  // stack ops\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  // splice ops\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  // bit logic\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  // numeric\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  // crypto\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  // expansion\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_NOP3: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  // template matching params\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255\n};\nOpcode.reverseMap = [];\nObject.keys(Opcode.map).forEach(k => {\n  Opcode.reverseMap[Opcode.map[k]] = k;\n}); // Easier access to opcodes\n\n_.extend(Opcode, Opcode.map);\n/**\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\n */\n\n\nOpcode.isSmallIntOp = function (opcode) {\n  if (opcode instanceof Opcode) {\n    opcode = opcode.toNumber();\n  }\n\n  return opcode === Opcode.map.OP_0 || opcode >= Opcode.map.OP_1 && opcode <= Opcode.map.OP_16;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Script opcode\n */\n\n\nOpcode.prototype.inspect = function () {\n  return \"<Opcode: \".concat(this.toString(), \", hex: \").concat(this.toHex(), \", decimal: \").concat(this.num, \">\");\n};\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r,\n      s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; // public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; // whether the recovered pubkey is compressed\n\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i += 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  preconditions.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  preconditions.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  preconditions.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = function (buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n};\n\nSignature.fromBuffer = Signature.fromDER; // The format used in a tx\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf), 'DER formatted signature should be a buffer');\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  preconditions.checkArgument(header === 0x30, 'Header byte should be 0x30');\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  preconditions.checkArgument(!strict || length === buflength, 'Length byte should length of what follows');\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  preconditions.checkArgument(rheader === 0x02, 'Integer byte for r should be 0x02');\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00;\n  preconditions.checkArgument(rlength === rbuf.length, 'Length of r incorrect');\n  var sheader = buf[2 + 2 + rlength + 0];\n  preconditions.checkArgument(sheader === 0x02, 'Integer byte for s should be 0x02');\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00;\n  preconditions.checkArgument(slength === sbuf.length, 'Length of s incorrect');\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  preconditions.checkArgument(length === sumlength - 2, 'Length of signature incorrect');\n  var obj = {\n    header,\n    length,\n    rheader,\n    rlength,\n    rneg,\n    rbuf,\n    r,\n    sheader,\n    slength,\n    sneg,\n    sbuf,\n    s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val -= 4;\n  }\n\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = function () {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = !!(rnbuf[0] & 0x80);\n  var sneg = !!(snbuf[0] & 0x80);\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toDER = Signature.prototype.toBuffer;\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isTxDER = function (buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n\n  var nLenR = buf[3];\n\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n\n  var nLenS = buf[5 + nLenR];\n\n  if (nLenR + nLenS + 7 !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n\n  if (nLenR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n\n  if (nLenS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options\n * or combinations thereof. Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n\n\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function () {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_FORKID = 0x40;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\n\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  }\n\n  if (from instanceof Address) {\n    return Script.fromAddress(from);\n  }\n\n  if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  }\n\n  if (typeof from === 'string') {\n    return Script.fromString(from);\n  }\n\n  if (typeof from !== 'undefined') {\n    this.set(from);\n  }\n};\n\nScript.prototype.set = function (obj) {\n  this.chunks = obj.chunks || this.chunks;\n  return this;\n};\n\nScript.fromBuffer = function (origBuffer) {\n  var script = new Script();\n  script.chunks = [];\n  var br = new BufferReader(origBuffer);\n\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n      var len = void 0;\n      var buf = void 0;\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(origBuffer.toString('hex'));\n      }\n\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function () {\n  return this.chunks.reduce((bw, chunk) => {\n    bw.writeUInt8(chunk.opcodenum);\n\n    if (chunk.buf) {\n      if (chunk.opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n\n    return bw;\n  }, new BufferWriter()).concat();\n};\n\nScript.fromASM = function (str) {\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum === undefined) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i += 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1], 16),\n        opcodenum\n      });\n      i += 3;\n    } else {\n      script.chunks.push({\n        opcodenum\n      });\n      i += 1;\n    }\n  }\n\n  return script;\n};\n\nScript.fromHex = function (str) {\n  return new this(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function (str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new this(Buffer.from(str, 'hex'));\n  }\n\n  var script = new this();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      // #weirdstuff\n      if (token.startsWith('0x')) {\n        opcodenum = parseInt(token, 16);\n      } else {\n        opcodenum = parseInt(token, 10);\n      }\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum\n        });\n        i += 2;\n      } else {\n        throw new Error(\"Invalid script: \".concat(JSON.stringify(str)));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1], 10),\n        opcodenum\n      });\n      i += 3;\n    } else {\n      script.chunks.push({\n        opcodenum\n      });\n      i += 1;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype._chunkToString = function (chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = type === 'asm';\n  var str = '';\n\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      str = \"\".concat(str, \" \").concat(Opcode(opcodenum).toString());\n    } else {\n      var numstr = opcodenum.toString(16);\n\n      if (numstr.length % 2 !== 0) {\n        numstr = \"0\".concat(numstr);\n      }\n\n      if (asm) {\n        str = \"\".concat(str, \" \").concat(numstr);\n      } else {\n        str = \"\".concat(str, \" 0x\").concat(numstr);\n      }\n    }\n  } else {\n    // data chunk\n    if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      str = \"\".concat(str, \" \").concat(Opcode(opcodenum).toString());\n    }\n\n    if (chunk.len > 0) {\n      if (asm) {\n        str = \"\".concat(str, \" \").concat(chunk.buf.toString('hex'));\n      } else {\n        str = \"\".concat(str, \" \").concat(chunk.len, \" 0x\").concat(chunk.buf.toString('hex'));\n      }\n    }\n  }\n\n  return str;\n};\n\nScript.prototype.toASM = function () {\n  return this.chunks.reduce((acc, chunk) => acc + this._chunkToString(chunk, 'asm'), '').substr(1);\n};\n\nScript.prototype.toString = function () {\n  return this.chunks.reduce((acc, chunk) => acc + this._chunkToString(chunk), '').substr(1);\n};\n\nScript.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function () {\n  return \"<Script: \".concat(this.toString(), \">\");\n}; // script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\n\n\nScript.prototype.isPublicKeyHashOut = function () {\n  return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\n\n\nScript.prototype.isPublicKeyHashIn = function () {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30 && pubkeyBuf && pubkeyBuf.length) {\n      var version = pubkeyBuf[0];\n\n      if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      }\n\n      if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nScript.prototype.getPublicKey = function () {\n  preconditions.checkState(this.isPublicKeyOut(), \"Can't retrieve PublicKey from a non-PublicKey output\");\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function () {\n  preconditions.checkState(this.isPublicKeyHashOut(), \"Can't retrieve PublicKeyHash from a non-PublicKeyHash output\");\n  return this.chunks[2].buf;\n};\n/**\n * @returns {boolean} if this is a public key output script\n */\n\n\nScript.prototype.isPublicKeyOut = function () {\n  if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n\n    if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\n\n\nScript.prototype.isPublicKeyIn = function () {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a p2sh output script\n */\n\n\nScript.prototype.isScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 0x14 && buf[buf.length - 1] === Opcode.OP_EQUAL;\n};\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\n\n\nScript.prototype.isScriptHashIn = function () {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n\n    throw e;\n  }\n\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\n\n\nScript.prototype.isMultisigOut = function () {\n  return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(obj => obj.buf && BufferUtil.isBuffer(obj.buf)) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;\n};\n/**\n * @returns {boolean} if this is a multisig input script\n */\n\n\nScript.prototype.isMultisigIn = function () {\n  return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(obj => obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf));\n};\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\n\n\nScript.prototype.isDataOut = function () {\n  return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);\n};\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash or P2SH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\n\n\nScript.prototype.getData = function () {\n  if (this.isDataOut() || this.isScriptHashOut()) {\n    // #weirdstuff\n    if (this.chunks[1] === undefined) {\n      return Buffer.alloc(0);\n    }\n\n    return Buffer.from(this.chunks[1].buf);\n  }\n\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n\n  throw new Error('Unrecognized script type to get data from');\n};\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\n\n\nScript.prototype.isPushOnly = function () {\n  return this.chunks.every(chunk => chunk.opcodenum <= Opcode.OP_16);\n};\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\nScript.OP_RETURN_STANDARD_SIZE = 80;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classify = function () {\n  if (this._isInput) {\n    return this.classifyInput();\n  }\n\n  if (this._isOutput) {\n    return this.classifyOutput();\n  }\n\n  var outputType = this.classifyOutput();\n  return outputType !== Script.types.UNKNOWN ? outputType : this.classifyInput();\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyOutput = function () {\n  var keys = Object.keys(Script.outputIdentifiers);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    if (Script.outputIdentifiers[keys[i]].bind(this)()) {\n      return Script.types[keys[i]];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyInput = function () {\n  var keys = Object.keys(Script.inputIdentifiers);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    if (Script.inputIdentifiers[keys[i]].bind(this)()) {\n      return Script.types[keys[i]];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if script is one of the known types\n */\n\n\nScript.prototype.isStandard = function () {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n}; // Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\n\n\nScript.prototype.prepend = function (obj) {\n  this._addByType(obj, true);\n\n  return this;\n};\n/**\n * Compares a script with another script\n */\n\n\nScript.prototype.equals = function (script) {\n  preconditions.checkState(script instanceof Script, 'Must provide another script');\n\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n\n  var i;\n\n  for (i = 0; i < this.chunks.length; i += 1) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    }\n\n    if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\n\n\nScript.prototype.add = function (obj) {\n  this._addByType(obj, false);\n\n  return this;\n};\n\nScript.prototype._addByType = function (obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function (op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function (opcode, prepend) {\n  var op;\n\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype._addBuffer = function (buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < 2 ** 8) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < 2 ** 16) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < 2 ** 32) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error(\"You can't push that much data\");\n  }\n\n  this._insertAtPosition({\n    buf,\n    len,\n    opcodenum\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype.removeCodeseparators = function () {\n  this.chunks = this.chunks.filter(chunk => chunk.opcodenum !== Opcode.OP_CODESEPARATOR);\n  return this;\n}; // high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\n\n\nScript.buildMultisigOut = function (publicKeys, threshold, opts) {\n  preconditions.checkArgument(threshold <= publicKeys.length, 'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new this();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = publicKeys.map(PublicKey);\n  var sorted = publicKeys;\n\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, publicKey => publicKey.toString('hex'));\n  }\n\n  sorted.forEach(pKey => script.add(pKey.toBuffer()));\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script\n *   (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n// #weirdstuff - \"opts\" is never used in the function, but if we remove it tests go red. We should\n// look into this in more detail and try to figure out what is happening.\n// eslint-disable-next-line no-unused-vars\n\n\nScript.buildMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  preconditions.checkArgument(_.isArray(pubkeys));\n  preconditions.checkArgument(_.isNumber(threshold));\n  preconditions.checkArgument(_.isArray(signatures));\n  var s = new this();\n  s.add(Opcode.OP_0);\n  signatures.forEach(signature => {\n    preconditions.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n  return s;\n};\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to\n * spend.\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script\n *   (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n\n\nScript.buildP2SHMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  preconditions.checkArgument(_.isArray(pubkeys));\n  preconditions.checkArgument(_.isNumber(threshold));\n  preconditions.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new this();\n  s.add(Opcode.OP_0);\n  signatures.forEach(signature => {\n    preconditions.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\n\n\nScript.buildPublicKeyHashOut = function (to) {\n  preconditions.checkArgument(!_.isUndefined(to));\n  preconditions.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n\n  var s = new this();\n  s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\n\n\nScript.buildPublicKeyOut = function (pubkey) {\n  preconditions.checkArgument(pubkey instanceof PublicKey);\n  var s = new this();\n  s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);\n  return s;\n};\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\n\n\nScript.buildDataOut = function (data, encoding) {\n  preconditions.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n\n  var s = new this();\n  s.add(Opcode.OP_RETURN);\n\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n\n  return s;\n};\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\n\n\nScript.buildScriptHashOut = function (script) {\n  preconditions.checkArgument(script instanceof Script || script instanceof Address && script.isPayToScriptHash());\n  var s = new this().add(Opcode.OP_HASH160).add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);\n  s._network = script._network || script.network;\n  return s;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical\n *   encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyIn = function (signature, sigtype) {\n  preconditions.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  preconditions.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new this();\n  script.add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)]));\n  return script;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical\n *   encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyHashIn = function (publicKey, signature, sigtype) {\n  preconditions.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  preconditions.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new this().add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)])).add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n/**\n * @returns {Script} an empty script\n */\n\n\nScript.empty = function () {\n  return new this();\n};\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\n\n\nScript.prototype.toScriptHashOut = function () {\n  return Script.buildScriptHashOut(this);\n};\n/**\n * @return {Script} an output script built from the address\n */\n\n\nScript.fromAddress = function (address) {\n  address = new Address(address);\n\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  }\n\n  if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  }\n\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\n\n\nScript.prototype.getAddressInfo = function () {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  }\n\n  if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  }\n\n  var info = this._getOutputAddressInfo();\n\n  if (!info) {\n    return this._getInputAddressInfo();\n  }\n\n  return info;\n};\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getOutputAddressInfo = function () {\n  var info = {};\n\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getInputAddressInfo = function () {\n  var info = {};\n\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\n\n\nScript.prototype.toAddress = function (network) {\n  var info = this.getAddressInfo();\n\n  if (!info) {\n    return false;\n  }\n\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\n\n\nScript.prototype.findAndDelete = function (script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n\n  for (var i = 0; i < this.chunks.length; i += 1) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n\n  return this;\n};\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\n\n\nScript.prototype.checkMinimalPush = function (i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n\n  if (!buf) {\n    return true;\n  }\n\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  }\n\n  if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  }\n\n  if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  }\n\n  if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  }\n\n  if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  }\n\n  if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n\n  return true;\n};\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\n\n\nScript.prototype._decodeOP_N = function (opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  }\n\n  if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  }\n\n  throw new Error(\"Invalid opcode: \".concat(JSON.stringify(opcode)));\n};\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\n\n\nScript.prototype.getSignatureOperationsCount = function (accurate) {\n  accurate = _.isUndefined(accurate) ? true : accurate;\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  self.chunks.forEach(chunk => {\n    var opcode = chunk.opcodenum;\n\n    if (opcode === Opcode.OP_CHECKSIG || opcode === Opcode.OP_CHECKSIGVERIFY) {\n      n += 1;\n    } else if (opcode === Opcode.OP_CHECKMULTISIG || opcode === Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n\n    lastOpcode = opcode;\n  });\n  return n;\n};\n\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n/**\n * Instantiate an address from an address String or Buffer, a public key or\n * script hash Buffer, or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this\n * constructor is an `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string) or\n * `Address.PayToScriptHash` (the string `'scripthash'`). The network is an\n * instance of {@link Network}. You can quickly check whether an address is of a\n * given kind by using the methods `isPayToPublicKeyHash` and\n * `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\n\nclass Address {\n  constructor(data, network, type) {\n    if (!(this instanceof Address)) {\n      return new Address(data, network, type);\n    }\n\n    if (_.isArray(data) && _.isNumber(network)) {\n      return Address.createMultisig(data, network, type);\n    }\n\n    if (data instanceof Address) {\n      // Immutable instance\n      return data;\n    }\n\n    preconditions.checkArgument(data, 'Address data required in first argument.', 'guide/address.html');\n\n    if (network && !Networks.get(network)) {\n      throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n    }\n\n    if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash) {\n      throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n    }\n\n    var info = Address._classifyArguments(data, network, type); // set defaults if not set\n\n\n    info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n    info.type = info.type || type || Address.PayToPublicKeyHash;\n    JSUtil.defineImmutable(this, {\n      hashBuffer: info.hashBuffer,\n      network: info.network,\n      type: info.type\n    });\n  }\n  /**\n   * Internal function used to split different kinds of arguments of the constructor\n   * @param {*} data - The encoded data in various formats\n   * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n   */\n\n\n  static _classifyArguments(data, network, type) {\n    // transform and validate input data\n    if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n      return Address._transformHash(data);\n    }\n\n    if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n      return Address._transformBuffer(data, network, type);\n    }\n\n    if (data instanceof PublicKey) {\n      return Address._transformPublicKey(data);\n    } // eslint-disable-next-line no-use-before-define\n\n\n    if (data instanceof Script) {\n      return Address._transformScript(data, network);\n    }\n\n    if (typeof data === 'string') {\n      return Address._transformString(data, network, type, Address.DefaultFormat);\n    }\n\n    if (_.isObject(data)) {\n      return Address._transformObject(data);\n    }\n\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  /**\n   * @param {Buffer} hash - An instance of a hash Buffer\n   * @returns {Object} An object with keys: hashBuffer\n   * @private\n   */\n\n\n  static _transformHash(hash) {\n    var info = {};\n\n    if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n      throw new TypeError('Address supplied is not a buffer.');\n    }\n\n    if (hash.length !== 20) {\n      throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n    }\n\n    info.hashBuffer = hash;\n    return info;\n  }\n  /**\n   * Deserializes an address serialized through `Address#toObject()`\n   * @param {Object} data\n   * @param {string} data.hash - the hash that this address encodes\n   * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n   * @param {Network=} data.network - the name of the network associated\n   * @return {Address}\n   */\n\n\n  static _transformObject(data) {\n    preconditions.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n    preconditions.checkArgument(data.type, 'Must provide a `type` property');\n    return {\n      hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n      network: Networks.get(data.network) || Networks.defaultNetwork,\n      type: data.type\n    };\n  }\n  /**\n   * Internal function to discover the network and type based on the first data byte\n   *\n   * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n   * @returns {Object} An object with keys: network and type\n   * @private\n   */\n\n\n  static _classifyFromVersion(buffer) {\n    var version = {};\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = this.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = this.PayToScriptHash;\n    }\n\n    return version;\n  }\n  /**\n   * Internal function to transform a bitcoin address buffer\n   *\n   * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n   * @param {string=} network - The network: 'livenet' or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformBuffer(buffer, network, type) {\n    var info = {};\n\n    if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n      throw new TypeError('Address supplied is not a buffer.');\n    }\n\n    if (buffer.length !== 1 + 20) {\n      throw new TypeError('Address buffers must be exactly 21 bytes.');\n    }\n\n    network = Networks.get(network);\n\n    var bufferVersion = Address._classifyFromVersion(buffer);\n\n    if (!bufferVersion.network || network && network !== bufferVersion.network) {\n      throw new TypeError('Address has mismatched network type.');\n    }\n\n    if (!bufferVersion.type || type && type !== bufferVersion.type) {\n      throw new TypeError('Address has mismatched type.');\n    }\n\n    info.hashBuffer = buffer.slice(1);\n    info.network = bufferVersion.network;\n    info.type = bufferVersion.type;\n    return info;\n  }\n  /**\n   * Internal function to transform a {@link PublicKey}\n   *\n   * @param {PublicKey} pubkey - An instance of PublicKey\n   * @returns {Object} An object with keys: hashBuffer, type\n   * @private\n   */\n\n\n  static _transformPublicKey(pubkey) {\n    var info = {};\n\n    if (!(pubkey instanceof PublicKey)) {\n      throw new TypeError('Address must be an instance of PublicKey.');\n    }\n\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n    info.type = this.PayToPublicKeyHash;\n    return info;\n  }\n  /**\n   * Internal function to transform a {@link Script} into a `info` object.\n   *\n   * @param {Script} script - An instance of Script\n   * @returns {Object} An object with keys: hashBuffer, type\n   * @private\n   */\n\n\n  static _transformScript(script, network) {\n    // eslint-disable-next-line no-use-before-define\n    preconditions.checkArgument(script instanceof Script, 'script must be a Script instance');\n    var info = script.getAddressInfo(network);\n\n    if (!info) {\n      throw new errors.Script.CantDeriveAddress(script);\n    }\n\n    return info;\n  }\n  /**\n   * Creates a P2SH address from a set of public keys and a threshold.\n   *\n   * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n   * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n   * interface.\n   *\n   * @param {Array} publicKeys - a set of public keys to create an address\n   * @param {number} threshold - the number of signatures needed to release the funds\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @return {Address}\n   */\n\n\n  static createMultisig(publicKeys, threshold, network) {\n    network = network || publicKeys[0].network || Networks.defaultNetwork; // eslint-disable-next-line no-use-before-define\n\n    return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n  }\n  /**\n   * Internal function to transform a bitcoin address string\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformString(data, network, type, format) {\n    if (typeof data !== 'string') {\n      throw new TypeError('data parameter supplied is not a string.');\n    }\n\n    data = data.trim();\n\n    if (format === this.LegacyFormat) {\n      return this._transformStringLegacy(data, network, type);\n    }\n\n    if (format === this.BitpayFormat) {\n      return this._transformStringBitpay(data, network, type);\n    }\n\n    if (format === this.CashAddrFormat) {\n      return this._transformStringCashAddr(data, network, type);\n    }\n\n    throw new TypeError('Unrecognized address format.');\n  }\n  /**\n   * Internal function to transform a bitcoin address string in legacy format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringLegacy(data, network, type) {\n    var addressBuffer = Base58Check.decode(data);\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Internal function to transform a bitcoin address string in Bitpay format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringBitpay(data, network, type) {\n    var addressBuffer = Base58Check.decode(data);\n\n    if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n      addressBuffer[0] = 0;\n    } else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n      addressBuffer[0] = 5;\n    }\n\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Internal function to transform a bitcoin address string in CashAddr format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringCashAddr(data, network, type) {\n    if (!(typeof network === 'string')) {\n      network = network.toString();\n    }\n\n    var decoded = cashaddr.decode(data);\n    preconditions.checkArgument(!network || network === 'livenet' && decoded.prefix === 'bitcoincash' || network === 'testnet' && decoded.prefix === 'bchtest', 'Invalid network.');\n    preconditions.checkArgument(!type || type === this.PayToPublicKeyHash && decoded.type === 'P2PKH' || type === this.PayToScriptHash && decoded.type === 'P2SH', 'Invalid type.');\n    network = Networks.get(network || (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet'));\n    type = type || (decoded.type === 'P2PKH' ? this.PayToPublicKeyHash : this.PayToScriptHash);\n    var version = Buffer.from([network[type]]);\n    var hashBuffer = Buffer.from(decoded.hash);\n    var addressBuffer = Buffer.concat([version, hashBuffer]);\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Instantiate an address from a PublicKey instance\n   *\n   * @param {PublicKey} data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromPublicKey(data, network) {\n    var info = this._transformPublicKey(data);\n\n    network = network || Networks.defaultNetwork;\n    return new Address(info.hashBuffer, network, info.type);\n  }\n  /**\n   * Instantiate an address from a ripemd160 public key hash\n   *\n   * @param {Buffer} hash - An instance of buffer of the hash\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromPublicKeyHash(hash, network) {\n    var info = this._transformHash(hash);\n\n    return new Address(info.hashBuffer, network, this.PayToPublicKeyHash);\n  }\n  /**\n   * Instantiate an address from a ripemd160 script hash\n   *\n   * @param {Buffer} hash - An instance of buffer of the hash\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromScriptHash(hash, network) {\n    preconditions.checkArgument(hash, 'hash parameter is required');\n\n    var info = this._transformHash(hash);\n\n    return new Address(info.hashBuffer, network, this.PayToScriptHash);\n  }\n  /**\n   * Builds a p2sh address paying to script. This will hash the script and\n   * use that to create the address.\n   * If you want to extract an address associated with a script instead,\n   * see {{Address#fromScript}}\n   *\n   * @param {Script} script - An instance of Script\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static payingTo(script, network) {\n    preconditions.checkArgument(script, 'script is required'); // eslint-disable-next-line no-use-before-define\n\n    preconditions.checkArgument(script instanceof Script, 'script must be instance of Script');\n    return this.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n  }\n  /**\n   * Extract address from a Script. The script must be of one\n   * of the following types: p2pkh input, p2pkh output, p2sh input\n   * or p2sh output.\n   * This will analyze the script and extract address information from it.\n   * If you want to transform any script to a p2sh Address paying\n   * to that script's hash instead, use {{Address#payingTo}}\n   *\n   * @param {Script} script - An instance of Script\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromScript(script, network) {\n    // eslint-disable-next-line no-use-before-define\n    preconditions.checkArgument(script instanceof Script, 'script must be a Script instance');\n\n    var info = this._transformScript(script, network);\n\n    return new Address(info.hashBuffer, network, info.type);\n  }\n  /**\n   * Instantiate an address from a buffer of the address\n   *\n   * @param {Buffer} buffer - An instance of buffer of the address\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromBuffer(buffer, network, type) {\n    var info = this._transformBuffer(buffer, network, type);\n\n    return new Address(info.hashBuffer, info.network, info.type);\n  }\n  /**\n   * Instantiate an address from an address string\n   *\n   * @param {string} str - An string of the bitcoin address\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromString(str, network, type, format) {\n    format = format || this.DefaultFormat;\n\n    var info = this._transformString(str, network, type, format);\n\n    return new Address(info.hashBuffer, info.network, info.type);\n  }\n  /**\n   * Instantiate an address from an Object\n   *\n   * @param {string} json - An JSON string or Object with keys: hash, network and type\n   * @returns {Address} A new valid instance of an Address\n   */\n\n\n  static fromObject(obj) {\n    preconditions.checkState(JSUtil.isHexa(obj.hash), \"Unexpected hash, \\\"\".concat(obj.hash, \"\\\", expected to be hex.\"));\n    var hashBuffer = Buffer.from(obj.hash, 'hex');\n    return new Address(hashBuffer, obj.network, obj.type);\n  }\n  /**\n   * Will return a validation error if exists\n   *\n   * @example\n   * ```javascript\n   * // a network mismatch error\n   * var error = this.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n   * ```\n   *\n   * @param {string} data - The encoded data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string} type - The type of address: 'script' or 'pubkey'\n   * @returns {null|Error} The corresponding error message\n   */\n\n\n  static getValidationError(data, network, type) {\n    var error;\n\n    try {\n      // eslint-disable-next-line no-new\n      new Address(data, network, type);\n    } catch (e) {\n      error = e;\n    }\n\n    return error;\n  }\n  /**\n   * Will return a boolean if an address is valid\n   *\n   * @example\n   * ```javascript\n   * assert(this.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n   * ```\n   *\n   * @param {string} data - The encoded data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string} type - The type of address: 'script' or 'pubkey'\n   * @returns {boolean} The corresponding error message\n   */\n\n\n  static isValid(data, network, type) {\n    return !this.getValidationError(data, network, type);\n  }\n  /**\n   * Returns true if an address is of pay to public key hash type\n   * @return boolean\n   */\n\n\n  isPayToPublicKeyHash() {\n    return this.type === Address.PayToPublicKeyHash;\n  }\n  /**\n   * Returns true if an address is of pay to script hash type\n   * @return boolean\n   */\n\n\n  isPayToScriptHash() {\n    return this.type === Address.PayToScriptHash;\n  }\n  /**\n   * Will return a buffer representation of the address\n   *\n   * @returns {Buffer} Bitcoin address buffer\n   */\n\n\n  toBuffer() {\n    var version = Buffer.from([this.network[this.type]]);\n    var buf = Buffer.concat([version, this.hashBuffer]);\n    return buf;\n  }\n  /**\n   * @returns {Object} A plain object with the address information\n   */\n\n\n  toObject() {\n    return {\n      hash: this.hashBuffer.toString('hex'),\n      type: this.type,\n      network: this.network.toString()\n    };\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n  /**\n   * Will return a the string representation of the address\n   *\n   * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {string} Bitcoin address\n   */\n\n\n  toString(format) {\n    format = format || Address.DefaultFormat;\n\n    if (format === Address.LegacyFormat) {\n      return this._toStringLegacy();\n    }\n\n    if (format === Address.BitpayFormat) {\n      return this._toStringBitpay();\n    }\n\n    if (format === Address.CashAddrFormat) {\n      return this._toStringCashAddr();\n    }\n\n    throw new TypeError('Unrecognized address format.');\n  }\n  /**\n   * Will return a the string representation of the address in legacy format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringLegacy() {\n    return Base58Check.encode(this.toBuffer());\n  }\n  /**\n   * Will return a the string representation of the address in Bitpay format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringBitpay() {\n    var buffer = this.toBuffer();\n\n    if (this.network.toString() === 'livenet') {\n      if (this.type === Address.PayToPublicKeyHash) {\n        buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n      } else if (this.type === Address.PayToScriptHash) {\n        buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n      }\n    }\n\n    return Base58Check.encode(buffer);\n  }\n  /**\n   * Will return a the string representation of the address in CashAddr format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringCashAddr() {\n    var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n    var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n    return cashaddr.encode(prefix, type, this.hashBuffer);\n  }\n  /**\n   * Will return a string formatted for the console\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  inspect() {\n    return \"<Address: \".concat(this.toString(), \", type: \").concat(this.type, \", network: \").concat(this.network, \">\");\n  }\n\n}\n\nAddress.LegacyFormat = 'legacy';\nAddress.BitpayFormat = 'bitpay';\nAddress.CashAddrFormat = 'cashaddr';\nAddress.DefaultFormat = Address.LegacyFormat;\nAddress.PayToPublicKeyHash = 'pubkeyhash';\nAddress.PayToScriptHash = 'scripthash';\nvar GENESIS_BITS = 0x1d00ffff;\n/**\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\n * the properties of the BlockHeader\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {BlockHeader} - An instance of block header\n * @constructor\n */\n\nclass BlockHeader {\n  constructor(arg) {\n    if (!(this instanceof BlockHeader)) {\n      return new BlockHeader(arg);\n    }\n\n    var info = BlockHeader._from(arg);\n\n    this.version = info.version;\n    this.prevHash = info.prevHash;\n    this.merkleRoot = info.merkleRoot;\n    this.time = info.time;\n    this.timestamp = info.time;\n    this.bits = info.bits;\n    this.nonce = info.nonce;\n\n    if (info.hash) {\n      preconditions.checkState(this.hash === info.hash, 'Argument object hash does not match block hash.');\n    }\n\n    return this;\n  }\n  /**\n   * @param {*} - A Buffer, JSON string or Object\n   * @returns {Object} - An object representing block header data\n   * @throws {TypeError} - If the argument was not recognized\n   * @private\n   */\n\n\n  static _from(arg) {\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = BlockHeader._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      info = BlockHeader._fromObject(arg);\n    } else {\n      throw new TypeError('Unrecognized argument for BlockHeader');\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A JSON string\n   * @returns {Object} - An object representing block header data\n   * @private\n   */\n\n\n  static _fromObject(data) {\n    preconditions.checkArgument(data, 'data is required');\n    var prevHash = data.prevHash;\n    var merkleRoot = data.merkleRoot;\n\n    if (_.isString(data.prevHash)) {\n      prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\n    }\n\n    if (_.isString(data.merkleRoot)) {\n      merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\n    }\n\n    var info = {\n      hash: data.hash,\n      version: data.version,\n      prevHash,\n      merkleRoot,\n      time: data.time,\n      timestamp: data.time,\n      bits: data.bits,\n      nonce: data.nonce\n    };\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromObject(obj) {\n    var info = this._fromObject(obj);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {Binary} - Raw block binary data or buffer\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromRawBlock(data) {\n    if (!BufferUtil.isBuffer(data)) {\n      data = Buffer.from(data, 'binary');\n    }\n\n    var br = BufferReader(data);\n    br.pos = BlockHeader.Constants.START_OF_HEADER;\n\n    var info = this._fromBufferReader(br);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {Buffer} - A buffer of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromBuffer(buf) {\n    var info = this._fromBufferReader(BufferReader(buf));\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {string} - A hex encoded buffer of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromString(str) {\n    var buf = Buffer.from(str, 'hex');\n    return this.fromBuffer(buf);\n  }\n  /**\n   * @param {BufferReader} - A BufferReader of the block header\n   * @returns {Object} - An object representing block header data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var info = {};\n    info.version = br.readInt32LE();\n    info.prevHash = br.read(32);\n    info.merkleRoot = br.read(32);\n    info.time = br.readUInt32LE();\n    info.bits = br.readUInt32LE();\n    info.nonce = br.readUInt32LE();\n    return info;\n  }\n  /**\n   * @param {BufferReader} - A BufferReader of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromBufferReader(br) {\n    var info = this._fromBufferReader(br);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @returns {Object} - A plain object of the BlockHeader\n   */\n\n\n  toJSON() {\n    return {\n      hash: this.hash,\n      version: this.version,\n      prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\n      merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\n      time: this.time,\n      bits: this.bits,\n      nonce: this.nonce\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * @returns {Buffer} - A Buffer of the BlockHeader\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @returns {string} - A hex encoded string of the BlockHeader\n   */\n\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n  /**\n   * @param {BufferWriter} - An existing instance BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\n   */\n\n\n  toBufferWriter(bw) {\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.writeInt32LE(this.version);\n    bw.write(this.prevHash);\n    bw.write(this.merkleRoot);\n    bw.writeUInt32LE(this.time);\n    bw.writeUInt32LE(this.bits);\n    bw.writeUInt32LE(this.nonce);\n    return bw;\n  }\n  /**\n   * Returns the target difficulty for this block\n   * @param {Number} bits\n   * @returns {BN} An instance of BN with the decoded difficulty bits\n   */\n\n\n  getTargetDifficulty(bits) {\n    bits = bits || this.bits;\n    var target = new BN(bits & 0xffffff);\n    var mov = 8 * ((bits >>> 24) - 3);\n\n    while (mov > 0) {\n      target = target.mul(new BN(2));\n      mov -= 1;\n    }\n\n    return target;\n  }\n  /**\n   * @link https://en.bitcoin.it/wiki/Difficulty\n   * @return {Number}\n   */\n\n\n  getDifficulty() {\n    var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(10 ** 8));\n    var currentTargetBN = this.getTargetDifficulty();\n    var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\n    var decimalPos = difficultyString.length - 8;\n    var leftOfDecimal = \"\".concat(difficultyString.slice(0, decimalPos));\n    var rightOfDecimal = \"\".concat(difficultyString.slice(decimalPos));\n    difficultyString = \"\".concat(leftOfDecimal, \".\").concat(rightOfDecimal);\n    return parseFloat(difficultyString);\n  }\n  /**\n   * @returns {Buffer} - The little endian hash buffer of the header\n   */\n\n\n  _getHash() {\n    var buf = this.toBuffer();\n    return Hash.sha256sha256(buf);\n  }\n  /**\n   * @returns {Boolean} - If timestamp is not too far in the future\n   */\n\n\n  validTimestamp() {\n    var currentTime = Math.round(new Date().getTime() / 1000);\n\n    if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\n   */\n\n\n  validProofOfWork() {\n    var pow = new BN(this.id, 'hex');\n    var target = this.getTargetDifficulty();\n\n    if (pow.cmp(target) > 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {string} - A string formatted for the console\n   */\n\n\n  inspect() {\n    return \"<BlockHeader \".concat(this.id, \">\");\n  }\n\n}\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get() {\n    if (!this._id) {\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\n    }\n\n    return this._id;\n  },\n\n  set: _.noop\n};\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\nBlockHeader.Constants = {\n  START_OF_HEADER: 8,\n  // Start buffer position in raw block data\n  MAX_TIME_OFFSET: 2 * 60 * 60,\n  // The max a timestamp can be in the future\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nclass Output {\n  constructor(args) {\n    if (_.isObject(args)) {\n      this.satoshis = args.satoshis;\n\n      if (BufferUtil.isBuffer(args.script)) {\n        this._scriptBuffer = args.script;\n      } else {\n        var script;\n\n        if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\n          script = Buffer.from(args.script, 'hex');\n        } else {\n          script = args.script;\n        }\n\n        this.setScript(script);\n      }\n    } else {\n      throw new TypeError('Unrecognized argument for Output');\n    }\n  }\n\n  get script() {\n    if (this._script) {\n      return this._script;\n    }\n\n    this.setScriptFromBuffer(this._scriptBuffer);\n    return this._script;\n  }\n\n  get satoshis() {\n    return this._satoshis;\n  }\n\n  set satoshis(num) {\n    if (num instanceof BN) {\n      this._satoshisBN = num;\n      this._satoshis = num.toNumber();\n    } else if (_.isString(num)) {\n      this._satoshis = parseInt(num, 10);\n      this._satoshisBN = BN.fromNumber(this._satoshis);\n    } else {\n      preconditions.checkArgument(JSUtil.isNaturalNumber(num), 'Output satoshis is not a natural number');\n      this._satoshisBN = BN.fromNumber(num);\n      this._satoshis = num;\n    }\n\n    preconditions.checkState(JSUtil.isNaturalNumber(this._satoshis), 'Output satoshis is not a natural number');\n  }\n\n  get satoshisBN() {\n    return this._satoshisBN;\n  }\n\n  set satoshisBN(num) {\n    this._satoshisBN = num;\n    this._satoshis = num.toNumber();\n    preconditions.checkState(JSUtil.isNaturalNumber(this._satoshis), 'Output satoshis is not a natural number');\n  }\n\n  static fromObject(data) {\n    return new Output(data);\n  }\n\n  static fromBufferReader(br) {\n    var obj = {};\n    obj.satoshis = br.readUInt64LEBN();\n    var size = br.readVarintNum();\n\n    if (size !== 0) {\n      obj.script = br.read(size);\n    } else {\n      obj.script = Buffer.from([]);\n    }\n\n    return new Output(obj);\n  }\n\n  invalidSatoshis() {\n    if (this._satoshis > MAX_SAFE_INTEGER) {\n      return 'transaction txout satoshis greater than max safe integer';\n    }\n\n    if (this._satoshis !== this._satoshisBN.toNumber()) {\n      return 'transaction txout satoshis has corrupted value';\n    }\n\n    if (this._satoshis < 0) {\n      return 'transaction txout negative';\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    var obj = {\n      satoshis: this.satoshis\n    };\n    obj.script = this._scriptBuffer.toString('hex');\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  setScriptFromBuffer(buff) {\n    this._scriptBuffer = buff;\n\n    try {\n      this._script = Script.fromBuffer(this._scriptBuffer);\n      this._script._isOutput = true;\n    } catch (e) {\n      if (e instanceof errors.Script.InvalidBuffer) {\n        this._script = null;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  setScript(script) {\n    if (script instanceof Script) {\n      this._scriptBuffer = script.toBuffer();\n      this._script = script;\n      this._script._isOutput = true;\n    } else if (_.isString(script)) {\n      this._script = Script.fromString(script);\n      this._scriptBuffer = this._script.toBuffer();\n      this._script._isOutput = true;\n    } else if (BufferUtil.isBuffer(script)) {\n      this.setScriptFromBuffer(script);\n    } else {\n      throw new TypeError('Invalid argument type: script');\n    }\n\n    return this;\n  }\n\n  inspect() {\n    var scriptStr;\n\n    if (this.script) {\n      scriptStr = this.script.inspect();\n    } else {\n      scriptStr = this._scriptBuffer.toString('hex');\n    }\n\n    return \"<Output (\".concat(this.satoshis, \" sats) \").concat(scriptStr, \">\");\n  }\n\n  toBufferWriter(writer) {\n    if (!writer) {\n      writer = new BufferWriter();\n    }\n\n    writer.writeUInt64LEBN(this._satoshisBN);\n    var script = this._scriptBuffer;\n    writer.writeVarintNum(script.length);\n    writer.write(script);\n    return writer;\n  }\n\n}\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n\n  if (obj) {\n    this.set(obj);\n  }\n};\n\nECDSA.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; // the endianness of hashbuf\n\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function () {\n  for (var i = 0; i < 4; i += 1) {\n    this.sig.i = i;\n    var Qprime = void 0;\n\n    try {\n      Qprime = this.toPublicKey();\n\n      if (Qprime.point.eq(this.pubkey.point)) {\n        this.sig.compressed = this.pubkey.compressed;\n        return this;\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function (str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function () {\n  var N = Point.getN();\n  var k;\n\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n\n  this.k = k;\n  return this;\n}; // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nECDSA.prototype.deterministicK = function (badrs) {\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN(); // also explained in 3.2, we must ensure T is in the proper range (0, N)\n\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i += 1) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n}; // Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\n\n\nECDSA.prototype.toPublicKey = function () {\n  var i = this.sig.i;\n  preconditions.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, 'i must be equal to 0, 1, 2, or 3');\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s; // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1;\n  var n = Point.getN();\n  var G = Point.getG(); // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  } // Compute -e from e\n\n\n  var eNeg = e.neg().umod(n); // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n\n  var rInv = r.invm(n); // var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function () {\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  }\n\n  return false;\n};\n\nECDSA.toLowS = function (s) {\n  // enforce low s\n  // see BIP 62, \"low S values in signatures\"\n  var maxS = '7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0';\n\n  if (s.gt(BN.fromBuffer(Buffer.from(maxS, 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n\n  return s;\n};\n\nECDSA.prototype._findSignature = function (d, e) {\n  var N = Point.getN();\n  var G = Point.getG(); // try different values of k until r, s are valid\n\n  var badrs = 0;\n  var Q;\n  var r;\n  var s;\n\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n\n    badrs += 1;\n    var k = this.k;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s,\n    r\n  };\n};\n\nECDSA.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  preconditions.checkState(hashbuf && privkey && d, 'invalid parameters');\n  preconditions.checkState(BufferUtil.isBuffer(hashbuf), 'hashbuf must be a buffer');\n  preconditions.checkState(hashbuf.length === 32, 'hashbuf must be 32 bytes');\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n\n  obj.compressed = this.pubkey.compressed;\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function () {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function () {\n  var obj = {};\n\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n\n  return this;\n};\n\nECDSA.sign = function (hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf,\n    endian,\n    privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function (hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf,\n    endian,\n    sig,\n    pubkey\n  }).verify().verified;\n};\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\nvar ENABLE_SIGHASH_FORKID = true;\n\nclass Sighash {\n  static sighashForForkId(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n    var input = transaction.inputs[inputNumber];\n    preconditions.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n\n    function GetPrevoutHash(tx) {\n      var writer = new BufferWriter();\n\n      _.each(tx.inputs, txIn => {\n        writer.writeReverse(txIn.prevTxId);\n        writer.writeUInt32LE(txIn.outputIndex);\n      });\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    function GetSequenceHash(tx) {\n      var writer = new BufferWriter();\n\n      _.each(tx.inputs, txIn => {\n        writer.writeUInt32LE(txIn.sequenceNumber);\n      });\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    function GetOutputsHash(tx, n) {\n      var writer = new BufferWriter();\n\n      if (_.isUndefined(n)) {\n        _.each(tx.outputs, output => {\n          output.toBufferWriter(writer);\n        });\n      } else {\n        tx.outputs[n].toBufferWriter(writer);\n      }\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    var hashPrevouts = BufferUtil.emptyBuffer(32);\n    var hashSequence = BufferUtil.emptyBuffer(32);\n    var hashOutputs = BufferUtil.emptyBuffer(32);\n\n    if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n      hashPrevouts = GetPrevoutHash(transaction);\n    }\n\n    if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {\n      hashSequence = GetSequenceHash(transaction);\n    }\n\n    if ((sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {\n      hashOutputs = GetOutputsHash(transaction);\n    } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n      hashOutputs = GetOutputsHash(transaction, inputNumber);\n    }\n\n    var writer = new BufferWriter(); // Version\n\n    writer.writeInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n    writer.write(hashPrevouts);\n    writer.write(hashSequence); //  outpoint (32-byte hash + 4-byte little endian)\n\n    writer.writeReverse(input.prevTxId);\n    writer.writeUInt32LE(input.outputIndex); // scriptCode of the input (serialized as scripts inside CTxOuts)\n\n    writer.writeVarintNum(subscript.toBuffer().length);\n    writer.write(subscript.toBuffer()); // value of the output spent by this input (8-byte little endian)\n\n    writer.writeUInt64LEBN(satoshisBN); // nSequence of the input (4-byte little endian)\n\n    var sequenceNumber = input.sequenceNumber;\n    writer.writeUInt32LE(sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n    writer.write(hashOutputs); // Locktime\n\n    writer.writeUInt32LE(transaction.nLockTime); // sighashType\n\n    writer.writeUInt32LE(sighashType >>> 0);\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n  /**\n   * Returns a buffer of length 32 bytes with the hash that needs to be signed\n   * for OP_CHECKSIG.\n   *\n   * @name Signing.sighash\n   * @param {Transaction} transaction the transaction to sign\n   * @param {number} sighashType the type of the hash\n   * @param {number} inputNumber the input index for the signature\n   * @param {Script} subscript the script that will be signed\n   * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n   *\n   */\n\n\n  static sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n    // Copy transaction\n    var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n    subscript = new Script(subscript);\n\n    if (sighashType & Signature.SIGHASH_FORKID && ENABLE_SIGHASH_FORKID) {\n      return Sighash.sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n    } // For no ForkId sighash, separators need to be removed.\n\n\n    subscript.removeCodeseparators();\n    var i;\n\n    for (i = 0; i < txcopy.inputs.length; i += 1) {\n      // Blank signatures for other inputs\n      txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n    }\n\n    txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n    if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n      // clear all sequenceNumbers\n      for (i = 0; i < txcopy.inputs.length; i += 1) {\n        if (i !== inputNumber) {\n          txcopy.inputs[i].sequenceNumber = 0;\n        }\n      }\n    }\n\n    if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n      txcopy.outputs = [];\n    } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n      // The SIGHASH_SINGLE bug.\n      // https://bitcointalk.org/index.php?topic=260595.0\n      if (inputNumber >= txcopy.outputs.length) {\n        return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n      }\n\n      txcopy.outputs.length = inputNumber + 1;\n\n      for (i = 0; i < inputNumber; i += 1) {\n        txcopy.outputs[i] = new Output({\n          satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n          script: Script.empty()\n        });\n      }\n    }\n\n    if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n      txcopy.inputs = [txcopy.inputs[inputNumber]];\n    }\n\n    var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n  /**\n   * Create a signature\n   *\n   * @name Signing.sign\n   * @param {Transaction} transaction\n   * @param {PrivateKey} privateKey\n   * @param {number} sighash\n   * @param {number} inputIndex\n   * @param {Script} subscript\n   * @param {satoshisBN} input's amount\n   * @return {Signature}\n   */\n\n\n  static sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n    var hashbuf = Sighash.sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n    var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n  /**\n   * Verify a signature\n   *\n   * @name Signing.verify\n   * @param {Transaction} transaction\n   * @param {Signature} signature\n   * @param {PublicKey} publicKey\n   * @param {number} inputIndex\n   * @param {Script} subscript\n   * @param {satoshisBN} input's amount\n   * @return {boolean}\n   */\n\n\n  static verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n    preconditions.checkArgument(!_.isUndefined(transaction));\n    preconditions.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n    var hashbuf = Sighash.sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n\n}\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\n\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\n\nclass Input {\n  constructor(params) {\n    if (!(this instanceof Input)) {\n      return new Input(params);\n    }\n\n    if (params) {\n      return this._fromObject(params);\n    }\n  }\n\n  get script() {\n    if (this.isNull()) {\n      return null;\n    }\n\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n\n    return this._script;\n  }\n\n  static fromObject(obj) {\n    preconditions.checkArgument(obj !== null && typeof obj === 'object');\n    return new Input()._fromObject(obj);\n  }\n\n  _fromObject(params) {\n    if (params.script === undefined && params.scriptBuffer === undefined) {\n      throw new errors.Transaction.Input.MissingScript();\n    }\n\n    this.prevTxId = typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId) ? Buffer.from(params.prevTxId, 'hex') : params.prevTxId;\n\n    if (params.output) {\n      this.output = params.output instanceof Output ? params.output : new Output(params.output);\n    }\n\n    this.outputIndex = params.outputIndex === undefined ? params.txoutnum : params.outputIndex;\n\n    if (params.sequenceNumber !== undefined) {\n      this.sequenceNumber = params.sequenceNumber;\n    } else if (params.seqnum !== undefined) {\n      this.sequenceNumber = params.seqnum;\n    } else {\n      this.sequenceNumber = DEFAULT_SEQNUMBER;\n    }\n\n    this.setScript(params.scriptBuffer || params.script);\n    return this;\n  }\n\n  toJSON() {\n    var obj = {\n      prevTxId: this.prevTxId.toString('hex'),\n      outputIndex: this.outputIndex,\n      sequenceNumber: this.sequenceNumber,\n      script: this._scriptBuffer.toString('hex')\n    }; // add human readable form if input contains valid script\n\n    if (this.script) {\n      obj.scriptString = this.script.toString();\n    }\n\n    if (this.output) {\n      obj.output = this.output.toObject();\n    }\n\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  static fromBufferReader(br) {\n    var input = new Input();\n    input.prevTxId = br.readReverse(32);\n    input.outputIndex = br.readUInt32LE();\n    input._scriptBuffer = br.readVarLengthBuffer();\n    input.sequenceNumber = br.readUInt32LE(); // TODO: return different classes according to which input it is\n    // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n\n    return input;\n  }\n\n  toBufferWriter(writer) {\n    writer = writer || new BufferWriter();\n    writer.writeReverse(this.prevTxId);\n    writer.writeUInt32LE(this.outputIndex);\n    var script = this._scriptBuffer;\n    writer.writeVarintNum(script.length);\n    writer.write(script);\n    writer.writeUInt32LE(this.sequenceNumber);\n    return writer;\n  }\n\n  setScript(script) {\n    this._script = null;\n\n    if (script instanceof Script) {\n      this._script = script;\n      this._script._isInput = true;\n      this._scriptBuffer = script.toBuffer();\n    } else if (JSUtil.isHexa(script)) {\n      // hex string script\n      this._scriptBuffer = Buffer.from(script, 'hex');\n    } else if (typeof script === 'string') {\n      // human readable string script\n      this._script = new Script(script);\n      this._script._isInput = true;\n      this._scriptBuffer = this._script.toBuffer();\n    } else if (BufferUtil.isBuffer(script)) {\n      // buffer script\n      this._scriptBuffer = Buffer.from(script);\n    } else {\n      throw new TypeError('Invalid argument type: script');\n    }\n\n    return this;\n  }\n  /**\n   * Retrieve signatures for the provided PrivateKey.\n   *\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key to use when signing\n   * @param {number} inputIndex - the index of this input in the provided transaction\n   * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n   * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n   *     public key associated with the private key provided\n   * @abstract\n   */\n\n\n  getSignatures() {\n    throw new errors.AbstractMethodInvoked(\"\".concat('Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ').concat(JSON.stringify(this)));\n  }\n\n  isFullySigned() {\n    throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n  }\n\n  isFinal() {\n    return this.sequenceNumber !== 4294967295;\n  }\n\n  addSignature() {\n    throw new errors.AbstractMethodInvoked('Input#addSignature');\n  }\n\n  clearSignatures() {\n    throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN);\n  }\n  /**\n   * @returns true if this is a coinbase input (represents no input)\n   */\n\n\n  isNull() {\n    return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff;\n  }\n\n  _estimateSize() {\n    return this.toBufferWriter().toBuffer().length;\n  }\n\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\n/**\n * @desc\n * Wrapper around Signature with fields related to signing a transaction specifically\n *\n * @param {Object|string|TransactionSignature} arg\n * @constructor\n */\n\nclass TransactionSignature extends Signature {\n  constructor(arg) {\n    super(arg);\n\n    if (arg instanceof TransactionSignature) {\n      return arg;\n    }\n\n    if (_.isObject(arg)) {\n      return this._fromObject(arg);\n    }\n\n    throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\n  }\n\n  _fromObject(arg) {\n    TransactionSignature._checkObjectArgs(arg);\n\n    this.publicKey = new PublicKey(arg.publicKey);\n    this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\n    this.outputIndex = arg.outputIndex;\n    this.inputIndex = arg.inputIndex;\n\n    if (arg.signature instanceof Signature) {\n      this.signature = arg.signature;\n    } else if (BufferUtil.isBuffer(arg.signature)) {\n      this.signature = Signature.fromBuffer(arg.signature);\n    } else {\n      this.signature = Signature.fromString(arg.signature);\n    }\n\n    this.sigtype = arg.sigtype;\n    return this;\n  }\n\n  static _checkObjectArgs(arg) {\n    preconditions.checkArgument(PublicKey(arg.publicKey), 'publicKey');\n    preconditions.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex');\n    preconditions.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex');\n    preconditions.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number');\n    preconditions.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number');\n    preconditions.checkArgument(arg.signature, 'signature');\n    preconditions.checkArgument(arg.prevTxId, 'prevTxId');\n    preconditions.checkState(arg.signature instanceof Signature || BufferUtil.isBuffer(arg.signature) || JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\n    preconditions.checkState(BufferUtil.isBuffer(arg.prevTxId) || JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\n    preconditions.checkArgument(arg.sigtype, 'sigtype');\n    preconditions.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number');\n  }\n  /**\n   * Serializes a transaction to a plain JS object\n   * @return {Object}\n   */\n\n\n  toJSON() {\n    return {\n      publicKey: this.publicKey.toString(),\n      prevTxId: this.prevTxId.toString('hex'),\n      outputIndex: this.outputIndex,\n      inputIndex: this.inputIndex,\n      signature: this.signature.toString(),\n      sigtype: this.sigtype\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * Builds a TransactionSignature from an object\n   * @param {Object} object\n   * @return {TransactionSignature}\n   */\n\n\n  static fromObject(object) {\n    preconditions.checkArgument(object);\n    return new TransactionSignature(object);\n  }\n\n}\n\nclass MultiSigScriptHashInput extends Input {\n  constructor(input, pubkeys, threshold, signatures, redeemScript) {\n    super(input, pubkeys, threshold, signatures, redeemScript);\n    var self = this;\n    pubkeys = pubkeys || input.publicKeys;\n    this.threshold = threshold || input.threshold;\n    signatures = signatures || input.signatures;\n    this.publicKeys = _.sortBy(pubkeys, publicKey => publicKey.toString('hex'));\n    this.redeemScript = redeemScript || Script.buildMultisigOut(this.publicKeys, this.threshold); // $.checkState(\n    //   Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),\n    //   'RedeemScript does not hash to the provided output'\n    // )\n\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      self.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  } // eslint-disable-next-line max-len\n\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n      cachedMultisig: this.redeemScript\n    }));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    return this.publicKeys.filter(publicKey => !this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript, this.output.satoshisBN);\n  }\n\n  _estimateSize() {\n    return MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;\n  }\n\n}\n\nMultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\n\nMultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\n\nMultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\n\nclass MultiSigInput extends Input {\n  constructor(input, pubkeys, threshold, signatures) {\n    super(input, pubkeys, threshold, signatures);\n    pubkeys = pubkeys || input.publicKeys;\n    this.threshold = threshold || input.threshold;\n    signatures = signatures || input.signatures;\n    this.publicKeys = _.sortBy(pubkeys, publicKey => publicKey.toString('hex')); // $.checkState(\n    //   Script.buildMultisigOut(this.publicKeys, this.threshold).equals(this.output.script),\n    //   \"Provided public keys don't match to the provided output script\"\n    // )\n\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      this.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  }\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    return this.publicKeys.filter(publicKey => !this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN);\n  }\n  /**\n   * @param {Buffer[]} signatures\n   * @param {PublicKey[]} publicKeys\n   * @param {Transaction} transaction\n   * @param {Integer} inputIndex\n   * @param {Input} input\n   * @returns {TransactionSignature[]}\n   */\n  // eslint-disable-next-line max-len\n\n\n  static normalizeSignatures(transaction, input, inputIndex, signatures, publicKeys) {\n    return publicKeys.map(pubKey => {\n      var signatureMatch = null;\n      signatures = signatures.filter(signatureBuffer => {\n        if (signatureMatch) {\n          return true;\n        }\n\n        var signature = new TransactionSignature({\n          signature: Signature.fromTxFormat(signatureBuffer),\n          publicKey: pubKey,\n          prevTxId: input.prevTxId,\n          outputIndex: input.outputIndex,\n          inputIndex,\n          sigtype: Signature.SIGHASH_ALL\n        });\n        signature.signature.nhashtype = signature.sigtype;\n        var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script);\n\n        if (isMatch) {\n          signatureMatch = signature;\n          return false;\n        }\n\n        return true;\n      });\n      return signatureMatch || null;\n    });\n  }\n\n  _estimateSize() {\n    return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n  }\n\n}\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n */\n\nclass PublicKeyInput extends Input {\n  /**\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n   * @param {number} index - the index of the input in the transaction input vector\n   * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n   * @return {Array} of objects that can be\n   */\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKey = privateKey.toPublicKey();\n\n    if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n      return [new TransactionSignature({\n        publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n        sigtype\n      })];\n    }\n\n    return [];\n  }\n  /**\n   * Add the provided signature\n   *\n   * @param {Object} signature\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @param {number=} signature.sigtype\n   * @return {PublicKeyInput} this, for chaining\n   */\n\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.setScript(Script.buildPublicKeyIn(signature.signature.toDER(), signature.sigtype));\n    return this;\n  }\n  /**\n   * Clear the input's signature\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  clearSignatures() {\n    this.setScript(Script.empty());\n    return this;\n  }\n  /**\n   * Query whether the input is signed\n   * @return {boolean}\n   */\n\n\n  isFullySigned() {\n    return this.script.isPublicKeyIn();\n  }\n\n  _estimateSize() {\n    return PublicKeyInput.SCRIPT_MAX_SIZE;\n  }\n\n}\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n */\n\nclass PublicKeyHashInput extends Input {\n  /**\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n   * @param {number} index - the index of the input in the transaction input vector\n   * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n   * @param {Buffer=} hashData - the precalculated hash of the public key associated with the\n   *   privateKey provided\n   * @return {Array} of objects that can be\n   */\n  // eslint-disable-next-line max-len\n  getSignatures(transaction, privateKey, index, sigtype, hashData) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n\n    if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n      return [new TransactionSignature({\n        publicKey: privateKey.toPublicKey(),\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n        sigtype\n      })];\n    }\n\n    return [];\n  }\n  /**\n   * Add the provided signature\n   *\n   * @param {Object} signature\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @param {number=} signature.sigtype\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    var script = Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(), signature.sigtype);\n    this.setScript(script);\n    return this;\n  }\n  /**\n   * Clear the input's signature\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  clearSignatures() {\n    this.setScript(Script.empty());\n    return this;\n  }\n  /**\n   * Query whether the input is signed\n   * @return {boolean}\n   */\n\n\n  isFullySigned() {\n    return this.script.isPublicKeyHashIn();\n  }\n\n  _estimateSize() {\n    return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n\n}\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nvar UNITS = {\n  BTC: [1e8, 8],\n  mBTC: [1e5, 5],\n  uBTC: [1e2, 2],\n  bits: [1e2, 2],\n  satoshis: [1, 0]\n};\n/**\n * Utility for handling and converting bitcoins units. The supported units are\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\n * It also allows to be created from a fiat amount and the exchange rate, or\n * alternatively using the {fromFiat} static method.\n * You can consult for different representation of a unit instance using it's\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\n * the unit accessors. It also can be converted to a fiat amount by providing the\n * corresponding BTC/fiat exchange rate.\n *\n * @example\n * ```javascript\n * var sats = Unit.fromBTC(1.3).toSatoshis();\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\n * var bits = Unit.fromFiat(1.3, 350).bits;\n * var btc = new Unit(1.3, Unit.bits).BTC;\n * ```\n *\n * @param {Number} amount - The amount to be represented\n * @param {String|Number} code - The unit of the amount or the exchange rate\n * @returns {Unit} A new instance of an Unit\n * @constructor\n */\n\nfunction Unit(amount, code) {\n  if (!(this instanceof Unit)) {\n    return new Unit(amount, code);\n  } // convert fiat to BTC\n\n\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n\n    amount /= code;\n    code = Unit.BTC;\n  }\n\n  this._value = this._from(amount, code);\n  var self = this;\n\n  var defineAccesor = function defineAccesor(key) {\n    Object.defineProperty(self, key, {\n      get() {\n        return self.to(key);\n      },\n\n      enumerable: true\n    });\n  };\n\n  Object.keys(UNITS).forEach(defineAccesor);\n}\n\nObject.keys(UNITS).forEach(key => {\n  Unit[key] = key;\n});\n/**\n * Returns a Unit instance created from JSON string or object\n *\n * @param {String|Object} json - JSON with keys: amount and code\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromObject = function fromObject(data) {\n  preconditions.checkArgument(_.isObject(data), 'Argument is expected to be an object');\n  return new Unit(data.amount, data.code);\n};\n/**\n * Returns a Unit instance created from an amount in BTC\n *\n * @param {Number} amount - The amount in BTC\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromBTC = function (amount) {\n  return new Unit(amount, Unit.BTC);\n};\n/**\n * Returns a Unit instance created from an amount in mBTC\n *\n * @param {Number} amount - The amount in mBTC\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromMilis = function (amount) {\n  return new Unit(amount, Unit.mBTC);\n};\n\nUnit.fromMillis = Unit.fromMilis;\n/**\n * Returns a Unit instance created from an amount in bits\n *\n * @param {Number} amount - The amount in bits\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromBits = function (amount) {\n  return new Unit(amount, Unit.bits);\n};\n\nUnit.fromMicros = Unit.fromBits;\n/**\n * Returns a Unit instance created from an amount in satoshis\n *\n * @param {Number} amount - The amount in satoshis\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromSatoshis = function (amount) {\n  return new Unit(amount, Unit.satoshis);\n};\n/**\n * Returns a Unit instance created from a fiat amount and exchange rate.\n *\n * @param {Number} amount - The amount in fiat\n * @param {Number} rate - The exchange rate BTC/fiat\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromFiat = function (amount, rate) {\n  return new Unit(amount, rate);\n};\n\nUnit.prototype._from = function (amount, code) {\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  return parseInt((amount * UNITS[code][0]).toFixed(), 10);\n};\n/**\n * Returns the value represented in the specified unit\n *\n * @param {String|Number} code - The unit code or exchange rate\n * @returns {Number} The converted value\n */\n\n\nUnit.prototype.to = function (code) {\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n\n    return parseFloat((this.BTC * code).toFixed(2));\n  }\n\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  var value = this._value / UNITS[code][0];\n  return parseFloat(value.toFixed(UNITS[code][1]));\n};\n/**\n * Returns the value represented in BTC\n *\n * @returns {Number} The value converted to BTC\n */\n\n\nUnit.prototype.toBTC = function () {\n  return this.to(Unit.BTC);\n};\n/**\n * Returns the value represented in mBTC\n *\n * @returns {Number} The value converted to mBTC\n */\n\n\nUnit.prototype.toMilis = function () {\n  return this.to(Unit.mBTC);\n};\n\nUnit.prototype.toMillis = Unit.prototype.toMilis;\n/**\n * Returns the value represented in bits\n *\n * @returns {Number} The value converted to bits\n */\n\nUnit.prototype.toBits = function () {\n  return this.to(Unit.bits);\n};\n\nUnit.prototype.toMicros = Unit.prototype.toBits;\n/**\n * Returns the value represented in satoshis\n *\n * @returns {Number} The value converted to satoshis\n */\n\nUnit.prototype.toSatoshis = function () {\n  return this.to(Unit.satoshis);\n};\n/**\n * Returns the value represented in fiat\n *\n * @param {string} rate - The exchange rate between BTC/currency\n * @returns {Number} The value converted to satoshis\n */\n\n\nUnit.prototype.atRate = function (rate) {\n  return this.to(rate);\n};\n/**\n * Returns a the string representation of the value in satoshis\n *\n * @returns {string} the value in satoshis\n */\n\n\nUnit.prototype.toString = function () {\n  return \"\".concat(this.satoshis, \" satoshis\");\n};\n/**\n * Returns a plain object representation of the Unit\n *\n * @returns {Object} An object with the keys: amount and code\n */\n\n\nUnit.prototype.toJSON = function toObject() {\n  return {\n    amount: this.BTC,\n    code: Unit.BTC\n  };\n};\n\nUnit.prototype.toObject = Unit.prototype.toJSON;\n/**\n * Returns a string formatted for the console\n *\n * @returns {string} the value in satoshis\n */\n\nUnit.prototype.inspect = function () {\n  return \"<Unit: \".concat(this.toString(), \">\");\n};\n/**\n * Represents an unspent output information: its script, associated amount and address,\n * transaction id and output index.\n *\n * @constructor\n * @param {object} data\n * @param {string} data.txid the previous transaction id\n * @param {string=} data.txId alias for `txid`\n * @param {number} data.vout the index in the transaction\n * @param {number=} data.outputIndex alias for `vout`\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\n * @param {string|Script=} data.script alias for `scriptPubKey`\n * @param {number} data.amount amount of bitcoins associated\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis\n *   (1 BTC = 1e8 satoshis)\n * @param {string|Address=} data.address the associated address to the script, if provided\n */\n\n\nclass UnspentOutput {\n  constructor(data) {\n    preconditions.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\n    var address = data.address ? new Address(data.address) : undefined;\n    var txId = data.txid ? data.txid : data.txId;\n\n    if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\n      // TODO: Use the errors library\n      throw new Error('Invalid TXID in object', data);\n    }\n\n    var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\n\n    if (!_.isNumber(outputIndex)) {\n      throw new Error(\"Invalid outputIndex, received \".concat(outputIndex));\n    }\n\n    preconditions.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script), 'Must provide the scriptPubKey for that output!');\n    var script = new Script(data.scriptPubKey || data.script);\n    preconditions.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis), 'Must provide an amount for the output');\n    var amount = !_.isUndefined(data.amount) ? Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    JSUtil.defineImmutable(this, {\n      address,\n      txId,\n      outputIndex,\n      script,\n      satoshis: amount\n    });\n  }\n  /**\n   * Provide an informative output when displaying this object in the console\n   * @returns string\n   */\n\n\n  inspect() {\n    var unspent = \"UnspentOutput: \".concat(this.txId, \":\").concat(this.outputIndex);\n    var satoshis = \"satoshis: \".concat(this.satoshis);\n    var address = \"address: \".concat(this.address);\n    return \"<\".concat(unspent, \", \").concat(satoshis, \", \").concat(address, \">\");\n  }\n  /**\n   * String representation: just \"txid:index\"\n   * @returns string\n   */\n\n\n  toString() {\n    return \"\".concat(this.txId, \":\").concat(this.outputIndex);\n  }\n  /**\n   * Deserialize an UnspentOutput from an object\n   * @param {object|string} data\n   * @return UnspentOutput\n   */\n\n\n  static fromObject(data) {\n    return new UnspentOutput(data);\n  }\n  /**\n   * Returns a plain object (no prototype or methods) with the associated info for this output\n   * @return {object}\n   */\n\n\n  toJSON() {\n    return {\n      address: this.address ? this.address.toString() : undefined,\n      txid: this.txId,\n      vout: this.outputIndex,\n      scriptPubKey: this.script.toBuffer().toString('hex'),\n      amount: Unit.fromSatoshis(this.satoshis).toBTC()\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n}\n\nvar compare = Buffer.compare || bufferCompare;\nvar CURRENT_VERSION = 1;\nvar DEFAULT_NLOCKTIME = 0;\nvar MAX_BLOCK_SIZE = 1000000;\n/**\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\n *\n * @param {*} serialized\n * @constructor\n */\n\nclass Transaction {\n  constructor(serialized) {\n    this.inputs = [];\n    this.outputs = [];\n    this._inputAmount = undefined;\n    this._outputAmount = undefined;\n\n    if (serialized) {\n      if (serialized instanceof Transaction) {\n        return Transaction.shallowCopy(serialized);\n      }\n\n      if (JSUtil.isHexa(serialized)) {\n        this.fromString(serialized);\n      } else if (BufferUtil.isBuffer(serialized)) {\n        this.fromBuffer(serialized);\n      } else if (_.isObject(serialized)) {\n        this.fromObject(serialized);\n      } else {\n        throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\n      }\n    } else {\n      this._newTransaction();\n    }\n  }\n\n  get hash() {\n    return new BufferReader(this._getHash()).readReverse().toString('hex');\n  }\n\n  get id() {\n    return new BufferReader(this._getHash()).readReverse().toString('hex');\n  }\n\n  get inputAmount() {\n    return this._getInputAmount();\n  }\n\n  get outputAmount() {\n    return this._getOutputAmount();\n  }\n  /**\n   * Retrieve the little endian hash of the transaction (used for serialization)\n   * @return {Buffer}\n   */\n\n\n  _getHash() {\n    return Hash.sha256sha256(this.toBuffer());\n  }\n  /**\n   * Retrieve a hexa string that can be used with bitcoind's CLI interface\n   * (decoderawtransaction, sendrawtransaction)\n   *\n   * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\n   *   it's expected to contain a set of flags to skip certain tests:\n   * * `disableAll`: disable all checks\n   * * `disableSmallFees`: disable checking for fees that are too small\n   * * `disableLargeFees`: disable checking for fees that are too large\n   * * `disableIsFullySigned`: disable checking if all inputs are fully signed\n   * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\n   * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than\n   *    the sum of the input amounts\n   * @return {string}\n   */\n\n\n  serialize(unsafe) {\n    if (unsafe === true || unsafe && unsafe.disableAll) {\n      return this.uncheckedSerialize();\n    }\n\n    return this.checkedSerialize(unsafe);\n  }\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n\n  uncheckedSerialize() {\n    return this.toString();\n  }\n  /**\n   * Retrieve a hexa string that can be used with bitcoind's CLI interface\n   * (decoderawtransaction, sendrawtransaction)\n   *\n   * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n   * @return {string}\n   */\n\n\n  checkedSerialize(opts) {\n    var serializationError = this.getSerializationError(opts);\n\n    if (serializationError) {\n      serializationError.message += ' - For more information please see: https://bitcore.io/api/lib/transaction#serialization-checks';\n      throw serializationError;\n    }\n\n    return this.uncheckedSerialize();\n  }\n\n  invalidSatoshis() {\n    return this.outputs.some(output => output.invalidSatoshis());\n  }\n  /**\n   * Retrieve a possible error that could appear when trying to serialize and\n   * broadcast this transaction.\n   *\n   * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n   * @return {bitcore.Error}\n   */\n\n\n  getSerializationError() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.invalidSatoshis()) {\n      return new errors.Transaction.InvalidSatoshis();\n    }\n\n    var unspent = this._getUnspentValue();\n\n    var unspentError;\n\n    if (unspent < 0) {\n      if (!opts.disableMoreOutputThanInput) {\n        unspentError = new errors.Transaction.InvalidOutputAmountSum();\n      }\n    } else {\n      unspentError = this._hasFeeError(opts, unspent);\n    }\n\n    return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts);\n  }\n\n  _hasFeeError(opts, unspent) {\n    if (this._fee !== undefined && this._fee !== unspent) {\n      return new errors.Transaction.FeeError.Different(\"Unspent value is \".concat(unspent, \" but specified fee is \").concat(this._fee));\n    }\n\n    if (!opts.disableLargeFees) {\n      var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\n\n      if (unspent > maximumFee) {\n        if (this._missingChange()) {\n          return new errors.Transaction.ChangeAddressMissing('Fee is too large and no change address was provided');\n        }\n\n        return new errors.Transaction.FeeError.TooLarge(\"expected less than \".concat(maximumFee, \" but got \").concat(unspent));\n      }\n    }\n\n    if (!opts.disableSmallFees) {\n      var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\n\n      if (unspent < minimumFee) {\n        return new errors.Transaction.FeeError.TooSmall(\"expected more than \".concat(minimumFee, \" but got \").concat(unspent));\n      }\n    }\n\n    return undefined;\n  }\n\n  _missingChange() {\n    return !this._changeScript;\n  }\n\n  _hasDustOutputs(opts) {\n    if (!opts.disableDustOutputs) {\n      // eslint-disable-next-line max-len\n      var dustOutputs = this.outputs.filter(output => output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut());\n\n      if (dustOutputs.length > 0) {\n        return new errors.Transaction.DustOutputs();\n      }\n    }\n\n    return undefined;\n  }\n\n  _isMissingSignatures(opts) {\n    if (!opts.disableIsFullySigned && !this.isFullySigned()) {\n      return new errors.Transaction.MissingSignatures();\n    }\n\n    return undefined;\n  }\n\n  inspect() {\n    return \"<Transaction: \".concat(this.uncheckedSerialize(), \">\");\n  }\n\n  toBuffer() {\n    var writer = new BufferWriter();\n    return this.toBufferWriter(writer).toBuffer();\n  }\n\n  toBufferWriter(writer) {\n    writer.writeInt32LE(this.version);\n    writer.writeVarintNum(this.inputs.length);\n    this.inputs.forEach(input => input.toBufferWriter(writer));\n    writer.writeVarintNum(this.outputs.length);\n    this.outputs.forEach(output => output.toBufferWriter(writer));\n    writer.writeUInt32LE(this.nLockTime);\n    return writer;\n  }\n\n  fromBuffer(buffer) {\n    var reader = new BufferReader(buffer);\n    return this.fromBufferReader(reader);\n  }\n\n  fromBufferReader(reader) {\n    preconditions.checkArgument(!reader.finished(), 'No transaction data received when creating transaction from buffer');\n    var i;\n    this.version = reader.readInt32LE();\n    var sizeTxIns = reader.readVarintNum();\n\n    for (i = 0; i < sizeTxIns; i += 1) {\n      var input = Input.fromBufferReader(reader);\n      this.inputs.push(input);\n    }\n\n    var sizeTxOuts = reader.readVarintNum();\n\n    for (i = 0; i < sizeTxOuts; i += 1) {\n      this.outputs.push(Output.fromBufferReader(reader));\n    }\n\n    this.nLockTime = reader.readUInt32LE();\n    return this;\n  }\n\n  toJSON() {\n    var inputs = this.inputs.map(input => input.toObject());\n    var outputs = this.outputs.map(output => output.toObject());\n    var obj = {\n      hash: this.hash,\n      version: this.version,\n      inputs,\n      outputs,\n      nLockTime: this.nLockTime\n    };\n\n    if (this._changeScript) {\n      obj.changeScript = this._changeScript.toString();\n    }\n\n    if (this._changeIndex !== undefined) {\n      obj.changeIndex = this._changeIndex;\n    }\n\n    if (this._fee !== undefined) {\n      obj.fee = this._fee;\n    }\n\n    if (this._dataInputs !== undefined) {\n      obj.dataInputs = this._dataInputs;\n    }\n\n    if (this._dataOutputs !== undefined) {\n      obj.dataOutputs = this._dataOutputs;\n    }\n\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  fromObject(arg) {\n    preconditions.checkArgument(_.isObject(arg) || arg instanceof Transaction);\n    var transaction = arg instanceof Transaction ? arg.toObject() : arg;\n    transaction.inputs.forEach(input => {\n      if (!input.output || !input.output.script) {\n        this.uncheckedAddInput(new Input(input));\n        return;\n      }\n\n      var script = new Script(input.output.script);\n      var txin;\n\n      if (script.isPublicKeyHashOut()) {\n        txin = new PublicKeyHashInput(input);\n      } else if (script.isScriptHashOut() && input.publicKeys && input.threshold) {\n        txin = new MultiSigScriptHashInput(input, input.publicKeys, input.threshold, input.signatures);\n      } else if (script.isPublicKeyOut()) {\n        txin = new PublicKeyInput(input);\n      } else {\n        throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\n      }\n\n      this.addInput(txin);\n    });\n    transaction.outputs.forEach(output => this.addOutput(new Output(output)));\n\n    if (transaction.changeIndex) {\n      this._changeIndex = transaction.changeIndex;\n    }\n\n    if (transaction.changeScript) {\n      this._changeScript = new Script(transaction.changeScript);\n    }\n\n    if (transaction.fee) {\n      this._fee = transaction.fee;\n    }\n\n    this.nLockTime = transaction.nLockTime;\n    this.version = transaction.version;\n\n    this._checkConsistency(arg);\n\n    return this;\n  }\n\n  _checkConsistency(arg) {\n    if (this._changeIndex !== undefined) {\n      preconditions.checkState(this._changeScript, 'Change script missing');\n      preconditions.checkState(this.outputs[this._changeIndex], 'Change output missing');\n      preconditions.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), 'Script in argument does not match script in transaction');\n    }\n\n    if (arg && arg.hash) {\n      preconditions.checkState(arg.hash === this.hash, 'Hash in argument does not match transaction hash');\n    }\n  }\n  /**\n   * Sets nLockTime so that transaction is not valid until the desired date(a\n   * timestamp in seconds since UNIX epoch is also accepted)\n   *\n   * @param {Date | Number} time\n   * @return {Transaction} this\n   */\n\n\n  lockUntilDate(time) {\n    preconditions.checkArgument(time);\n\n    if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      throw new errors.Transaction.LockTimeTooEarly();\n    }\n\n    if (_.isDate(time)) {\n      time = time.getTime() / 1000;\n    }\n\n    this.inputs.forEach(input => {\n      if (input.sequenceNumber === Input.DEFAULT_SEQNUMBER) {\n        input.sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n      }\n    });\n    this.nLockTime = time;\n    return this;\n  }\n  /**\n   * Sets nLockTime so that transaction is not valid until the desired block\n   * height.\n   *\n   * @param {Number} height\n   * @return {Transaction} this\n   */\n\n\n  lockUntilBlockHeight(height) {\n    preconditions.checkArgument(_.isNumber(height), 'Block height must be a number');\n\n    if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      throw new errors.Transaction.BlockHeightTooHigh();\n    }\n\n    if (height < 0) {\n      throw new errors.Transaction.NLockTimeOutOfRange();\n    }\n\n    this.inputs.forEach(input => {\n      if (input.sequenceNumber === Input.DEFAULT_SEQNUMBER) {\n        input.sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n      }\n    });\n    this.nLockTime = height;\n    return this;\n  }\n  /**\n   *  Returns a semantic version of the transaction's nLockTime.\n   *  @return {Number|Date}\n   *  If nLockTime is 0, it returns null,\n   *  if it is < 500000000, it returns a block height (number)\n   *  else it returns a Date object.\n   */\n\n\n  getLockTime() {\n    if (!this.nLockTime) {\n      return null;\n    }\n\n    if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      return this.nLockTime;\n    }\n\n    return new Date(1000 * this.nLockTime);\n  }\n\n  fromString(string) {\n    this.fromBuffer(Buffer.from(string, 'hex'));\n  }\n\n  _newTransaction() {\n    this.version = CURRENT_VERSION;\n    this.nLockTime = DEFAULT_NLOCKTIME;\n  }\n  /**\n   * Add an input to this transaction. This is a high level interface\n   * to add an input, for more control, use @{link Transaction#addInput}.\n   *\n   * Can receive, as output information, the output of bitcoind's `listunspent` command,\n   * and a slightly fancier format recognized by bitcore:\n   *\n   * ```\n   * {\n   *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n   *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n   *  outputIndex: 0,\n   *  script: Script.empty(),\n   *  satoshis: 1020000\n   * }\n   * ```\n   * Where `address` can be either a string or a bitcore Address object. The\n   * same is true for `script`, which can be a string or a bitcore Script.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @example\n   * ```javascript\n   * var transaction = new Transaction();\n   *\n   * // From a pay to public key hash output from bitcoind's listunspent\n   * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n   *\n   * // From a pay to public key hash output\n   * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n   *\n   * // From a multisig P2SH output\n   * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n   *                  ['03000...', '02000...'], 2);\n   * ```\n   *\n   * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} txs\n   * @param {Array=} pubkeys\n   * @param {number=} threshold\n   */\n\n\n  from(txs, pubkeys, threshold) {\n    if (Array.isArray(txs)) {\n      txs.forEach(tx => this.from(tx, pubkeys, threshold));\n      return this;\n    } // TODO: Maybe prevTxId should be a string? Or defined as read only property?\n    // Check if the utxo has already been added as an input\n\n\n    var utxoExists = this.inputs.some(input => input.prevTxId.toString('hex') === txs.txId && input.outputIndex === txs.outputIndex);\n    var Clazz;\n    var utxo = new UnspentOutput(txs);\n\n    if (utxoExists) {\n      return this; // P2SH case\n    }\n\n    if (pubkeys && threshold) {\n      preconditions.checkArgument(threshold <= pubkeys.length, 'Number of signatures must be greater than the number of public keys');\n\n      if (utxo.script.isMultisigOut()) {\n        Clazz = MultiSigInput;\n      } else if (utxo.script.isScriptHashOut()) {\n        Clazz = MultiSigScriptHashInput;\n      } else {\n        Clazz = MultiSigInput;\n      } // non P2SH case\n\n    } else if (utxo.script.isPublicKeyHashOut()) {\n      Clazz = PublicKeyHashInput;\n    } else if (utxo.script.isPublicKeyOut()) {\n      Clazz = PublicKeyInput;\n    } else {\n      Clazz = Input;\n    }\n\n    var input = new Clazz({\n      output: new Output({\n        script: utxo.script,\n        satoshis: utxo.satoshis\n      }),\n      prevTxId: utxo.txId,\n      outputIndex: utxo.outputIndex,\n      script: Script.empty()\n    }, pubkeys, threshold);\n    this.addInput(input);\n    return this;\n  }\n  /**\n   * Add an input to this transaction. The input must be an instance of the `Input` class.\n   * It should have information about the Output that it's spending, but if it's not already\n   * set, two additional parameters, `outputScript` and `satoshis` can be provided.\n   *\n   * @param {Input} input\n   * @param {String|Script} outputScript\n   * @param {number} satoshis\n   * @return Transaction this, for chaining\n   */\n\n\n  addInput(input, outputScript, satoshis) {\n    preconditions.checkArgumentType(input, Input, 'Trying to add input of type other than input');\n\n    if (!input.output && (outputScript === undefined || satoshis === undefined)) {\n      throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\n    }\n\n    if (!input.output && outputScript && satoshis !== undefined) {\n      outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\n      preconditions.checkArgumentType(satoshis, 'number', 'Satoshis must be a number when adding input');\n      input.output = new Output({\n        script: outputScript,\n        satoshis\n      });\n    }\n\n    return this.uncheckedAddInput(input);\n  }\n  /**\n   * Add an input to this transaction, without checking that the input has information about\n   * the output that it's spending.\n   *\n   * @param {Input} input\n   * @return Transaction this, for chaining\n   */\n\n\n  uncheckedAddInput(input) {\n    preconditions.checkArgumentType(input, Input, 'Trying to add input of type other than input');\n    this.inputs.push(input);\n    this._inputAmount = undefined;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Returns true if the transaction has enough info on all inputs to be correctly validated\n   *\n   * @return {boolean}\n   */\n\n\n  hasAllUtxoInfo() {\n    return this.inputs.map(input => !!input.output);\n  }\n  /**\n   * Manually set the fee for this transaction. Beware that this resets all the signatures\n   * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n   * be reset).\n   *\n   * @param {number} amount satoshis to be sent\n   * @return {Transaction} this, for chaining\n   */\n\n\n  fee(amount) {\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    this._fee = amount;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\n   * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n   * be reset).\n   *\n   * @param {number} amount satoshis per KB to be sent\n   * @return {Transaction} this, for chaining\n   */\n\n\n  feePerKb(amount) {\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    this._feePerKb = amount;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Set the change address for this transaction\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {Address} address An address for change to be sent to.\n   * @return {Transaction} this, for chaining\n   */\n\n\n  change(address) {\n    preconditions.checkArgument(address, 'Address is required');\n    this._changeScript = Script.fromAddress(address);\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * @return {Output} change output, if it exists\n   */\n\n\n  getChangeOutput() {\n    if (this._changeIndex !== undefined) {\n      return this.outputs[this._changeIndex];\n    }\n\n    return null;\n  }\n  /**\n   * Add an output to the transaction.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {(string|Address|Array.<Transaction~toObject>)} address\n   * @param {number} amount in satoshis\n   * @return {Transaction} this, for chaining\n   */\n\n\n  to(address, amount) {\n    if (Array.isArray(address)) {\n      var self = this;\n      address.forEach(to => self.to(to.address, to.satoshis));\n      return this;\n    }\n\n    preconditions.checkArgument(JSUtil.isNaturalNumber(amount), 'Amount is expected to be a positive integer');\n    this.addOutput(new Output({\n      script: Script(new Address(address)),\n      satoshis: amount\n    }));\n    return this;\n  }\n  /**\n   * Add an OP_RETURN output to the transaction.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\n   *    In case of a string, the UTF-8 representation will be stored\n   * @return {Transaction} this, for chaining\n   */\n\n\n  addData(value) {\n    this.addOutput(new Output({\n      script: Script.buildDataOut(value),\n      satoshis: 0\n    }));\n    return this;\n  }\n  /**\n   * Add an output to the transaction.\n   *\n   * @param {Output} output the output to add.\n   * @return {Transaction} this, for chaining\n   */\n\n\n  addOutput(output) {\n    preconditions.checkArgumentType(output, Output, 'Output needs to be of type output');\n\n    this._addOutput(output);\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Remove all outputs from the transaction.\n   *\n   * @return {Transaction} this, for chaining\n   */\n\n\n  clearOutputs() {\n    this.outputs = [];\n\n    this._clearSignatures();\n\n    this._outputAmount = undefined;\n    this._changeIndex = undefined;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n\n  _addOutput(output) {\n    this.outputs.push(output);\n    this._outputAmount = undefined;\n  }\n  /**\n   * Calculates or gets the total output amount in satoshis\n   *\n   * @return {Number} the transaction total output amount\n   */\n\n\n  _getOutputAmount() {\n    if (this._outputAmount === undefined) {\n      this._outputAmount = this.outputs.reduce((acc, output) => acc + output.satoshis, 0);\n    }\n\n    return this._outputAmount;\n  }\n  /**\n   * Calculates or gets the total input amount in satoshis\n   *\n   * @return {Number} the transaction total input amount\n   */\n\n\n  _getInputAmount() {\n    if (this._inputAmount === undefined) {\n      var self = this;\n      this._inputAmount = 0;\n      this.inputs.forEach(input => {\n        if (input.output === undefined) {\n          throw new errors.Transaction.Input.MissingPreviousOutput();\n        }\n\n        self._inputAmount += input.output.satoshis;\n      });\n    }\n\n    return this._inputAmount;\n  }\n\n  _updateChangeOutput() {\n    if (!this._changeScript) {\n      return;\n    }\n\n    this._clearSignatures();\n\n    if (this._changeIndex !== undefined) {\n      this._removeOutput(this._changeIndex);\n    }\n\n    var available = this._getUnspentValue();\n\n    var fee = this.getFee();\n    var changeAmount = available - fee;\n\n    if (changeAmount > 0) {\n      this._changeIndex = this.outputs.length;\n\n      this._addOutput(new Output({\n        script: this._changeScript,\n        satoshis: changeAmount\n      }));\n    } else {\n      this._changeIndex = undefined;\n    }\n  }\n  /**\n   * Calculates the fee of the transaction.\n   *\n   * If there's a fixed fee set, return that.\n   *\n   * If there is no change output set, the fee is the\n   * total value of the outputs minus inputs. Note that\n   * a serialized transaction only specifies the value\n   * of its outputs. (The value of inputs are recorded\n   * in the previous transaction outputs being spent.)\n   * This method therefore raises a \"MissingPreviousOutput\"\n   * error when called on a serialized transaction.\n   *\n   * If there's no fee set and no change address,\n   * estimate the fee based on size.\n   *\n   * @return {Number} fee of this transaction in satoshis\n   */\n\n\n  getFee() {\n    if (this.isCoinbase()) {\n      return 0;\n    }\n\n    if (this._fee !== undefined) {\n      return this._fee;\n    } // if no change output is set, fees should equal all the unspent amount\n\n\n    if (!this._changeScript) {\n      return this._getUnspentValue();\n    }\n\n    return this._estimateFee();\n  }\n  /**\n   * Estimates fee from serialized transaction size in bytes.\n   */\n\n\n  _estimateFee() {\n    var estimatedSize = this._estimateSize();\n\n    var available = this._getUnspentValue();\n\n    return Transaction._estimateFee(estimatedSize, available, this._feePerKb);\n  }\n\n  _getUnspentValue() {\n    return this._getInputAmount() - this._getOutputAmount();\n  }\n\n  _clearSignatures() {\n    this.inputs.forEach(input => input.clearSignatures());\n  }\n\n  _estimateSize() {\n    var result = this.inputs.reduce((acc, input) => acc + input._estimateSize(), Transaction.MAXIMUM_EXTRA_SIZE);\n    result = this.outputs.reduce((acc, output) => acc + output.script.toBuffer().length + 9, result);\n    return result;\n  }\n\n  _removeOutput(index) {\n    var output = this.outputs[index];\n    this.outputs = this.outputs.filter(val => val !== output);\n    this._outputAmount = undefined;\n  }\n\n  removeOutput(index) {\n    this._removeOutput(index);\n\n    this._updateChangeOutput();\n  }\n  /**\n   * Sort a transaction's inputs and outputs according to BIP69\n   *\n   * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\n   * @return {Transaction} this\n   */\n\n\n  sort() {\n    /* eslint-disable max-len */\n    this.sortInputs(inputs => {\n      var copy = Array.prototype.concat.apply([], inputs);\n      copy.sort((first, second) => compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex);\n      return copy;\n    });\n    this.sortOutputs(outputs => {\n      var copy = Array.prototype.concat.apply([], outputs);\n      copy.sort((first, second) => first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()));\n      return copy;\n    });\n    /* eslint-enable max-len */\n\n    return this;\n  }\n  /**\n   * Randomize this transaction's outputs ordering. The shuffling algorithm is a\n   * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\n   *\n   * @return {Transaction} this\n   */\n\n\n  shuffleOutputs() {\n    return this.sortOutputs(_.shuffle);\n  }\n  /**\n   * Sort this transaction's outputs, according to a given sorting function that\n   * takes an array as argument and returns a new array, with the same elements\n   * but with a different order. The argument function MUST NOT modify the order\n   * of the original array\n   *\n   * @param {Function} sortingFunction\n   * @return {Transaction} this\n   */\n\n\n  sortOutputs(sortingFunction) {\n    var outs = sortingFunction(this.outputs);\n    return this._newOutputOrder(outs);\n  }\n  /**\n   * Sort this transaction's inputs, according to a given sorting function that\n   * takes an array as argument and returns a new array, with the same elements\n   * but with a different order.\n   *\n   * @param {Function} sortingFunction\n   * @return {Transaction} this\n   */\n\n\n  sortInputs(sortingFunction) {\n    this.inputs = sortingFunction(this.inputs);\n\n    this._clearSignatures();\n\n    return this;\n  }\n\n  _newOutputOrder(newOutputs) {\n    var isInvalidSorting = this.outputs.length !== newOutputs.length || _.difference(this.outputs, newOutputs).length !== 0;\n\n    if (isInvalidSorting) {\n      throw new errors.Transaction.InvalidSorting();\n    }\n\n    if (this._changeIndex !== undefined) {\n      var changeOutput = this.outputs[this._changeIndex];\n      this._changeIndex = _.findIndex(newOutputs, changeOutput);\n    }\n\n    this.outputs = newOutputs;\n    return this;\n  }\n\n  removeInput(txId, outputIndex) {\n    var index;\n\n    if (!outputIndex && _.isNumber(txId)) {\n      index = txId;\n    } else {\n      index = _.findIndex(this.inputs, input => input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex);\n    }\n\n    if (index < 0 || index >= this.inputs.length) {\n      throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\n    }\n\n    var input = this.inputs[index];\n    this.inputs = _.without(this.inputs, input);\n    this._inputAmount = undefined;\n\n    this._updateChangeOutput();\n  }\n  /**\n   * Sign the transaction using one or more private keys.\n   *\n   * It tries to sign each input, verifying that the signature will be valid\n   * (matches a public key).\n   *\n   * @param {Array|String|PrivateKey} privateKeys\n   * @param {number} sigtype\n   * @return {Transaction} this, for chaining\n   */\n\n\n  sign(privateKeys, sigtype) {\n    preconditions.checkState(this.hasAllUtxoInfo(), 'Cannot sign because an input is not defined');\n    var self = this;\n\n    if (Array.isArray(privateKeys)) {\n      privateKeys.forEach(privateKey => self.sign(privateKey, sigtype));\n      return this;\n    }\n\n    var signatures = this.getSignatures(privateKeys, sigtype);\n    signatures.forEach(signature => self.applySignature(signature));\n    return this;\n  }\n\n  getSignatures(privKey, sigtype) {\n    privKey = new PrivateKey(privKey); // By default, signs using ALL|FORKID\n\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var transaction = this;\n    var results = [];\n    var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\n    this.inputs.forEach((input, index) => {\n      var signatures = input.getSignatures(transaction, privKey, index, sigtype, hashData);\n      signatures.forEach(signature => results.push(signature));\n    });\n    return results;\n  }\n  /**\n   * Add a signature to the transaction\n   *\n   * @param {Object} signature\n   * @param {number} signature.inputIndex\n   * @param {number} signature.sigtype\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @return {Transaction} this, for chaining\n   */\n\n\n  applySignature(signature) {\n    this.inputs[signature.inputIndex].addSignature(this, signature);\n    return this;\n  }\n\n  isFullySigned() {\n    this.inputs.forEach(input => {\n      if (input.isFullySigned === Input.prototype.isFullySigned) {\n        throw new errors.Transaction.UnableToVerifySignature('Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction');\n      }\n    });\n    return this.inputs.map(input => input.isFullySigned()).every(x => x);\n  }\n\n  isValidSignature(signature) {\n    var self = this;\n\n    if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\n      throw new errors.Transaction.UnableToVerifySignature('Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction');\n    }\n\n    return this.inputs[signature.inputIndex].isValidSignature(self, signature);\n  }\n  /**\n   * @returns {bool} whether the signature is valid for this transaction input\n   */\n\n\n  verifySignature(sig, pubkey, nin, subscript) {\n    return Sighash.verify(this, sig, pubkey, nin, subscript);\n  }\n  /**\n   * Check that a transaction passes basic sanity tests. If not, return a string\n   * describing the error. This function contains the same logic as\n   * CheckTransaction in bitcoin core.\n   */\n\n\n  verify() {\n    var i; // Basic checks that don't depend on any context\n\n    if (this.inputs.length === 0) {\n      return 'transaction txins empty';\n    }\n\n    if (this.outputs.length === 0) {\n      return 'transaction txouts empty';\n    } // Check for negative or overflow output values\n\n\n    var valueoutbn = new BN(0);\n\n    for (i = 0; i < this.outputs.length; i += 1) {\n      if (this.outputs[i].invalidSatoshis()) {\n        return 'Transaction output contains invalid amount';\n      }\n\n      if (this.outputs[i]._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\n        return 'Transaction output contains too high satoshi amount';\n      }\n\n      valueoutbn = valueoutbn.add(this.outputs[i]._satoshisBN);\n\n      if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\n        return 'Transaction output contains too high satoshi amount';\n      }\n    } // Size limits\n\n\n    if (this.toBuffer().length > MAX_BLOCK_SIZE) {\n      return 'Transaction over the maximum block size';\n    } // Check for duplicate inputs\n\n\n    var txinmap = {};\n\n    for (i = 0; i < this.inputs.length; i += 1) {\n      var inputid = \"\".concat(this.inputs[i].prevTxId, \":\").concat(this.inputs[i].outputIndex);\n\n      if (txinmap[inputid] !== undefined) {\n        return 'Transaction contains duplicate input';\n      }\n\n      txinmap[inputid] = true;\n    }\n\n    var isCoinbase = this.isCoinbase();\n\n    if (isCoinbase) {\n      var buf = this.inputs[0]._scriptBuffer;\n\n      if (buf.length < 2 || buf.length > 100) {\n        return 'Coinbase transaction script size invalid';\n      }\n    } else if (this.inputs.filter(input => input.isNull()).length > 0) {\n      return 'Transaction has null input';\n    }\n\n    return true;\n  }\n  /**\n   * Analogous to bitcoind's IsCoinBase function in transaction.h\n   */\n\n\n  isCoinbase() {\n    return this.inputs.length === 1 && this.inputs[0].isNull();\n  }\n  /**\n   * Determines if this transaction can be replaced in the mempool with another\n   * transaction that provides a sufficiently higher fee (RBF).\n   */\n\n\n  isRBF() {\n    return this.inputs.some(input => input.sequenceNumber < Input.MAXINT - 1);\n  }\n  /**\n   * Enable this transaction to be replaced in the mempool (RBF) if a transaction\n   * includes a sufficiently higher fee. It will set the sequenceNumber to\n   * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\n   * already enable RBF.\n   */\n\n\n  enableRBF() {\n    this.inputs = this.inputs.map(input => {\n      if (input.sequenceNumber >= Input.MAXINT - 1) {\n        input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\n      }\n\n      return input;\n    });\n    return this;\n  }\n  /**\n   * Create a 'shallow' copy of the transaction, by serializing and deserializing\n   * it dropping any additional information that inputs and outputs may have hold\n   *\n   * @param {Transaction} transaction\n   * @return {Transaction}\n   */\n\n\n  static shallowCopy(transaction) {\n    return new Transaction(transaction.toBuffer());\n  }\n\n  static _estimateFee(size, amountAvailable, feePerKb) {\n    var fee = Math.ceil(size / 1000 * (feePerKb || Transaction.FEE_PER_KB));\n\n    if (amountAvailable > fee) {\n      size += Transaction.CHANGE_OUTPUT_MAX_SIZE;\n    }\n\n    return Math.ceil(size / 1000 * (feePerKb || Transaction.FEE_PER_KB));\n  }\n\n} // Minimum amount for an output for it not to be considered a dust output\n\n\nTransaction.DUST_AMOUNT = 546; // Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big\n// difference.\n\nTransaction.FEE_SECURITY_MARGIN = 150; // max amount of satoshis in circulation\n\nTransaction.MAX_MONEY = 21000000 * 1e8; // nlocktime limit to be considered block height rather than a timestamp\n\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8; // Max value for an unsigned 32 bit value\n\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295; // Value used for fee estimation (satoshis per kilobyte)\n\nTransaction.FEE_PER_KB = 20000; // Safe upper bound for change address script size in bytes\n\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\n\nclass Block {\n  constructor(arg) {\n    if (!(this instanceof Block)) {\n      return new Block(arg);\n    }\n\n    _.extend(this, Block._from(arg));\n\n    return this;\n  }\n  /**\n   * @param {*} - A Buffer, JSON string or Object\n   * @returns {Object} - An object representing block data\n   * @throws {TypeError} - If the argument was not recognized\n   * @private\n   */\n\n\n  static _from(arg) {\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = Block._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      info = Block._fromObject(arg);\n    } else {\n      throw new TypeError('Unrecognized argument for Block');\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Object} - An object representing block data\n   * @private\n   */\n\n\n  static _fromObject(data) {\n    var transactions = [];\n    data.transactions.forEach(tx => {\n      if (tx instanceof Transaction) {\n        transactions.push(tx);\n      } else {\n        transactions.push(new Transaction().fromObject(tx));\n      }\n    });\n    var info = {\n      header: BlockHeader.fromObject(data.header),\n      transactions\n    };\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromObject(obj) {\n    var info = Block._fromObject(obj);\n\n    return new Block(info);\n  }\n  /**\n   * @param {BufferReader} - Block data\n   * @returns {Object} - An object representing the block data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var info = {};\n    preconditions.checkState(!br.finished(), 'No block data received');\n    info.header = BlockHeader.fromBufferReader(br);\n    var transactions = br.readVarintNum();\n    info.transactions = [];\n\n    for (var i = 0; i < transactions; i += 1) {\n      info.transactions.push(new Transaction().fromBufferReader(br));\n    }\n\n    return info;\n  }\n  /**\n   * @param {BufferReader} - A buffer reader of the block\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromBufferReader(br) {\n    preconditions.checkArgument(br, 'br is required');\n\n    var info = Block._fromBufferReader(br);\n\n    return new Block(info);\n  }\n  /**\n   * @param {Buffer} - A buffer of the block\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromBuffer(buf) {\n    return Block.fromBufferReader(new BufferReader(buf));\n  }\n  /**\n   * @param {string} - str - A hex encoded string of the block\n   * @returns {Block} - A hex encoded string of the block\n   */\n\n\n  static fromString(str) {\n    var buf = Buffer.from(str, 'hex');\n    return Block.fromBuffer(buf);\n  }\n  /**\n   * @param {Binary} - Raw block binary data or buffer\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromRawBlock(data) {\n    if (!BufferUtil.isBuffer(data)) {\n      data = Buffer.from(data, 'binary');\n    }\n\n    var br = BufferReader(data);\n    br.pos = Block.Values.START_OF_BLOCK;\n\n    var info = Block._fromBufferReader(br);\n\n    return new Block(info);\n  }\n  /**\n   * @returns {Object} - A plain object with the block properties\n   */\n\n\n  toJSON() {\n    var transactions = [];\n    this.transactions.forEach(tx => {\n      transactions.push(tx.toObject());\n    });\n    return {\n      header: this.header.toObject(),\n      transactions\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * @returns {Buffer} - A buffer of the block\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @returns {string} - A hex encoded string of the block\n   */\n\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n  /**\n   * @param {BufferWriter} - An existing instance of BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n   */\n\n\n  toBufferWriter(bw) {\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.write(this.header.toBuffer());\n    bw.writeVarintNum(this.transactions.length);\n\n    for (var i = 0; i < this.transactions.length; i += 1) {\n      this.transactions[i].toBufferWriter(bw);\n    }\n\n    return bw;\n  }\n  /**\n   * Will iterate through each transaction and return an array of hashes\n   * @returns {Array} - An array with transaction hashes\n   */\n\n\n  getTransactionHashes() {\n    var hashes = [];\n\n    if (this.transactions.length === 0) {\n      return [Block.Values.NULL_HASH];\n    }\n\n    for (var t = 0; t < this.transactions.length; t += 1) {\n      hashes.push(this.transactions[t]._getHash());\n    }\n\n    return hashes;\n  }\n  /**\n   * Will build a merkle tree of all the transactions, ultimately arriving at\n   * a single point, the merkle root.\n   * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n   * @returns {Array} - An array with each level of the tree after the other.\n   */\n\n\n  getMerkleTree() {\n    var tree = this.getTransactionHashes();\n    var j = 0;\n\n    for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n      for (var i = 0; i < size; i += 2) {\n        var i2 = Math.min(i + 1, size - 1);\n        var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n        tree.push(Hash.sha256sha256(buf));\n      }\n\n      j += size;\n    }\n\n    return tree;\n  }\n  /**\n   * Calculates the merkleRoot from the transactions.\n   * @returns {Buffer} - A buffer of the merkle root hash\n   */\n\n\n  getMerkleRoot() {\n    var tree = this.getMerkleTree();\n    return tree[tree.length - 1];\n  }\n  /**\n   * Verifies that the transactions in the block match the header merkle root\n   * @returns {Boolean} - If the merkle roots match\n   */\n\n\n  validMerkleRoot() {\n    var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n    var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n    if (h.cmp(c) !== 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Buffer} - The little endian hash buffer of the header\n   */\n\n\n  _getHash() {\n    return this.header._getHash();\n  }\n  /**\n   * @returns {string} - A string formatted for the console\n   */\n\n\n  inspect() {\n    return \"<Block \".concat(this.id, \">\");\n  }\n\n} // https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\n\n\nBlock.MAX_BLOCK_SIZE = 1000000;\nvar idProperty$1 = {\n  configurable: false,\n  enumerable: true,\n\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n\n    return this._id;\n  },\n\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty$1);\nObject.defineProperty(Block.prototype, 'hash', idProperty$1);\nBlock.Values = {\n  START_OF_BLOCK: 8,\n  // Start of block in raw block data\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n}; // refactor progress\n\nvar hdErrors = errors.HDPublicKey;\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\nfunction HDPublicKey(arg) {\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      }\n\n      if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      }\n\n      if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n        return new HDPrivateKey(arg).hdPublicKey;\n      }\n\n      throw error;\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        }\n\n        return this._buildFromObject(arg);\n      }\n\n      throw new hdErrors.UnrecognizedArgument(arg);\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  }\n\n  throw new hdErrors.InvalidDerivationArgument(arg);\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode,\n    publicKey\n  });\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce((prev, index) => prev._deriveWithNumber(index), this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Networks.livenet.xprivkey || version === Networks.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Networks.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Networks.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  // TODO: Type validation\n  var publicKey;\n\n  if (_.isString(arg.publicKey)) {\n    publicKey = BufferUtil.hexToBuffer(arg.publicKey);\n  } else if (BufferUtil.isBuffer(arg.publicKey)) {\n    publicKey = arg.publicKey;\n  } else {\n    publicKey = arg.publicKey.toBuffer();\n  }\n\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Networks.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey,\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.publicKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n    throw new errors.InvalidB58Checksum(concat, checksum);\n  }\n\n  var network = Networks.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey,\n    network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey,\n    fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), \"\".concat(name, \" argument is not a buffer, it's \").concat(typeof buff));\n    assert(buff.length === size, \"\".concat(name, \" size unexpected: found \").concat(buff.length, \", expected \").concat(size));\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  preconditions.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  preconditions.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return \"<HDPublicKey: \".concat(this.xpubkey, \">\");\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Networks.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON;\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nvar hdErrors$1 = errors.HDPrivateKey;\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\n\nfunction HDPrivateKey(arg) {\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Networks.get(arg)) {\n    return this._generateRandomly(arg);\n  }\n\n  if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors$1.UnrecognizedArgument(arg);\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\n\n\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/'); // Special cases:\n\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(step => {\n    var isHardened = step.slice(-1) === \"'\";\n\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n\n    var index = +step; // cast to number\n\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n  return _.some(indexes, Number.isNaN) ? null : indexes;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead.\n * This is not BIP32 compliant.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.derive = function (arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  }\n\n  throw new hdErrors$1.InvalidDerivationArgument(arg);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  }\n\n  throw new hdErrors$1.InvalidDerivationArgument(arg);\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors$1.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({\n      size: 32\n    });\n    assert(privateKeyBuffer.length === 32, 'private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode,\n    privateKey\n  });\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors$1.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce((prev, index) => prev._deriveWithNumber(index, null, nonCompliant), this);\n  return derived;\n};\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\n\n\nHDPrivateKey.getSerializedError = function (data, network) {\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors$1.UnrecognizedArgument('Expected string or buffer');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors$1.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Networks.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(0, 4);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPrivateKey.fromString = function (arg) {\n  preconditions.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function (arg) {\n  preconditions.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  // TODO: Type validation\n  var checksum;\n\n  if (arg.checksum) {\n    if (arg.checksum.length) {\n      checksum = arg.checksum;\n    } else {\n      checksum = BufferUtil.integerAsBuffer(arg.checksum);\n    }\n  }\n\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Networks.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\n\n\nHDPrivateKey.fromSeed = function (hexa, network) {\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors$1.InvalidEntropyArgument(hexa);\n  }\n\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors$1.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors$1.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Networks.get(network) || Networks.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.privateKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\n\n\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = Buffer.concat(sequence);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n    throw new errors.InvalidB58Checksum(concat);\n  }\n\n  var network = Networks.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey = Base58Check.encode(Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey,\n    network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey,\n    publicKey,\n    fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n\n    get() {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey;\n    }\n\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n\n    get() {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey.xpubkey;\n    }\n\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), \"\".concat(name, \" argument is not a buffer\"));\n    assert(buff.length === size, \"\".concat(name, \" size unexpected: found \").concat(buff.length, \", expected \").concat(size));\n  };\n\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\n\n\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\n\n\nHDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Networks.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON;\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\n\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\n\n\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', \"m'\", \"M'\"];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\n\nclass MerkleBlock {\n  constructor(arg) {\n    if (!(this instanceof MerkleBlock)) {\n      return new MerkleBlock(arg);\n    }\n\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = MerkleBlock._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      var header;\n\n      if (arg.header instanceof BlockHeader) {\n        header = arg.header;\n      } else {\n        header = BlockHeader.fromObject(arg.header);\n      }\n\n      info = {\n        /**\n         * @name MerkleBlock#header\n         * @type {BlockHeader}\n         */\n        header,\n\n        /**\n         * @name MerkleBlock#numTransactions\n         * @type {Number}\n         */\n        numTransactions: arg.numTransactions,\n\n        /**\n         * @name MerkleBlock#hashes\n         * @type {String[]}\n         */\n        hashes: arg.hashes,\n\n        /**\n         * @name MerkleBlock#flags\n         * @type {Number[]}\n         */\n        flags: arg.flags\n      };\n    } else {\n      throw new TypeError('Unrecognized argument for MerkleBlock');\n    }\n\n    _.extend(this, info);\n\n    this._flagBitsUsed = 0;\n    this._hashesUsed = 0;\n    return this;\n  }\n  /**\n   * @param {Buffer} - MerkleBlock data in a Buffer object\n   * @returns {MerkleBlock} - A MerkleBlock object\n   */\n\n\n  static fromBuffer(buf) {\n    return MerkleBlock.fromBufferReader(BufferReader(buf));\n  }\n  /**\n   * @param {BufferReader} - MerkleBlock data in a BufferReader object\n   * @returns {MerkleBlock} - A MerkleBlock object\n   */\n\n\n  static fromBufferReader(br) {\n    return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n  }\n  /**\n   * @returns {Buffer} - A buffer of the block\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @param {BufferWriter} - An existing instance of BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n   */\n\n\n  toBufferWriter(bw) {\n    var i;\n\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.write(this.header.toBuffer());\n    bw.writeUInt32LE(this.numTransactions);\n    bw.writeVarintNum(this.hashes.length);\n\n    for (i = 0; i < this.hashes.length; i += 1) {\n      bw.write(Buffer.from(this.hashes[i], 'hex'));\n    }\n\n    bw.writeVarintNum(this.flags.length);\n\n    for (i = 0; i < this.flags.length; i += 1) {\n      bw.writeUInt8(this.flags[i]);\n    }\n\n    return bw;\n  }\n  /**\n   * @returns {Object} - A plain object with the MerkleBlock properties\n   */\n\n\n  toJSON() {\n    return {\n      header: this.header.toObject(),\n      numTransactions: this.numTransactions,\n      hashes: this.hashes,\n      flags: this.flags\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * Verify that the MerkleBlock is valid\n   * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n   */\n\n\n  validMerkleTree() {\n    preconditions.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n    preconditions.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n    if (this.hashes.length > this.numTransactions) {\n      return false;\n    } // Can't have more flag bits than num hashes\n\n\n    if (this.flags.length * 8 < this.hashes.length) {\n      return false;\n    }\n\n    var height = this._calcTreeHeight();\n\n    var opts = {\n      hashesUsed: 0,\n      flagBitsUsed: 0\n    };\n\n    var root = this._traverseMerkleTree(height, 0, opts);\n\n    if (opts.hashesUsed !== this.hashes.length) {\n      return false;\n    }\n\n    return BufferUtil.equals(root, this.header.merkleRoot);\n  }\n  /**\n   * Traverse a the tree in this MerkleBlock, validating it along the way\n   * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n   * @param {Number} - depth - Current height\n   * @param {Number} - pos - Current position in the tree\n   * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n   * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n   * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n   * @param {Array} - opts.txs - Will finish populated by transactions found during traversal\n   * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n   * @private\n   */\n\n\n  _traverseMerkleTree(depth, pos, opts) {\n    opts = opts || {};\n    opts.txs = opts.txs || [];\n    opts.flagBitsUsed = opts.flagBitsUsed || 0;\n    opts.hashesUsed = opts.hashesUsed || 0;\n\n    if (opts.flagBitsUsed > this.flags.length * 8) {\n      return null;\n    }\n\n    var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed & 7) & 1;\n    opts.flagBitsUsed += 1;\n\n    if (depth === 0 || !isParentOfMatch) {\n      if (opts.hashesUsed >= this.hashes.length) {\n        return null;\n      }\n\n      var hash = this.hashes[opts.hashesUsed];\n      opts.hashesUsed += 1;\n\n      if (depth === 0 && isParentOfMatch) {\n        opts.txs.push(hash);\n      }\n\n      return Buffer.from(hash, 'hex');\n    }\n\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n\n    var right = left;\n\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n\n    return Hash.sha256sha256(Buffer.concat([left, right]));\n  }\n  /** Calculates the width of a merkle tree at a given height.\n   *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n   * @param {Number} - Height at which we want the tree width\n   * @returns {Number} - Width of the tree at a given height\n   * @private\n   */\n\n\n  _calcTreeWidth(height) {\n    return this.numTransactions + (1 << height) - 1 >> height;\n  }\n  /** Calculates the height of the merkle tree in this MerkleBlock\n   * @param {Number} - Height at which we want the tree width\n   * @returns {Number} - Height of the merkle tree in this MerkleBlock\n   * @private\n   */\n\n\n  _calcTreeHeight() {\n    var height = 0;\n\n    while (this._calcTreeWidth(height) > 1) {\n      height += 1;\n    }\n\n    return height;\n  }\n  /**\n   * @param {Transaction|String} - Transaction or Transaction ID Hash\n   * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n   * @private\n   */\n\n\n  hasTransaction(tx) {\n    preconditions.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n    preconditions.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n    var hash = tx;\n\n    if (tx instanceof Transaction) {\n      // We need to reverse the id hash for the lookup\n      hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n    }\n\n    var txs = [];\n\n    var height = this._calcTreeHeight();\n\n    this._traverseMerkleTree(height, 0, {\n      txs\n    });\n\n    return txs.indexOf(hash) !== -1;\n  }\n  /**\n   * @param {Buffer} - MerkleBlock data\n   * @returns {Object} - An Object representing merkleblock data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var i;\n    preconditions.checkState(!br.finished(), 'No merkleblock data received');\n    var info = {};\n    info.header = BlockHeader.fromBufferReader(br);\n    info.numTransactions = br.readUInt32LE();\n    var numHashes = br.readVarintNum();\n    info.hashes = [];\n\n    for (i = 0; i < numHashes; i += 1) {\n      info.hashes.push(br.read(32).toString('hex'));\n    }\n\n    var numFlags = br.readVarintNum();\n    info.flags = [];\n\n    for (i = 0; i < numFlags; i += 1) {\n      info.flags.push(br.readUInt8());\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromObject(obj) {\n    return new MerkleBlock(obj);\n  }\n\n}\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\n\n\nclass Message {\n  constructor(message) {\n    preconditions.checkArgument(_.isString(message), 'First argument should be a string');\n    this.message = message;\n    return this;\n  }\n\n  magicHash() {\n    var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n    var messageBuffer = Buffer.from(this.message);\n    var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n    var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n    var hash = Hash.sha256sha256(buf);\n    return hash;\n  }\n\n  _sign(privateKey) {\n    preconditions.checkArgument(privateKey instanceof PrivateKey, 'First argument should be a PrivateKey');\n    var hash = this.magicHash();\n    var ecdsa = new ECDSA();\n    ecdsa.hashbuf = hash;\n    ecdsa.privkey = privateKey;\n    ecdsa.pubkey = privateKey.toPublicKey();\n    ecdsa.signRandomK();\n    ecdsa.calci();\n    return ecdsa.sig;\n  }\n  /**\n   * Will sign a message with a given bitcoin private key.\n   *\n   * @param {PrivateKey} privateKey - An instance of PrivateKey\n   * @returns {String} A base64 encoded compact signature\n   */\n\n\n  sign(privateKey) {\n    var signature = this._sign(privateKey);\n\n    return signature.toCompact().toString('base64');\n  }\n\n  _verify(publicKey, signature) {\n    preconditions.checkArgument(publicKey instanceof PublicKey, 'First argument should be a PublicKey');\n    preconditions.checkArgument(signature instanceof Signature, 'Second argument should be a Signature');\n    var hash = this.magicHash();\n    var verified = ECDSA.verify(hash, signature, publicKey);\n\n    if (!verified) {\n      this.error = 'The signature was invalid';\n    }\n\n    return verified;\n  }\n  /**\n   * Will return a boolean if the signature is valid for a given bitcoin address.\n   * If it isn't the specific reason is accessible via the \"error\" member.\n   *\n   * @param {Address|String} bitcoinAddress - A bitcoin address\n   * @param {String} signatureString - A base64 encoded compact signature\n   * @returns {Boolean}\n   */\n\n\n  verify(bitcoinAddress, signatureString) {\n    preconditions.checkArgument(bitcoinAddress);\n    preconditions.checkArgument(signatureString && _.isString(signatureString));\n\n    if (_.isString(bitcoinAddress)) {\n      bitcoinAddress = Address.fromString(bitcoinAddress);\n    }\n\n    var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64')); // recover the public key\n\n    var ecdsa = new ECDSA();\n    ecdsa.hashbuf = this.magicHash();\n    ecdsa.sig = signature;\n    var publicKey = ecdsa.toPublicKey();\n    var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network); // check that the recovered address and specified address match\n\n    if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n      this.error = 'The signature did not match the message digest';\n      return false;\n    }\n\n    return this._verify(publicKey, signature);\n  }\n  /**\n   * Instantiate a message from a message string\n   *\n   * @param {String} str - A string of the message\n   * @returns {Message} A new instance of a Message\n   */\n\n\n  static fromString(str) {\n    return new Message(str);\n  }\n  /**\n   * Instantiate a message from JSON\n   *\n   * @param {String} json - An JSON string or Object with keys: message\n   * @returns {Message} A new instance of a Message\n   */\n\n\n  static fromJSON(json) {\n    if (JSUtil.isValidJSON(json)) {\n      json = JSON.parse(json);\n    }\n\n    return new Message(json.message);\n  }\n  /**\n   * @returns {Object} A plain object with the message information\n   */\n\n\n  toObject() {\n    return {\n      message: this.message\n    };\n  }\n  /**\n   * @returns {String} A JSON representation of the message information\n   */\n\n\n  toJSON() {\n    return JSON.stringify(this.toObject());\n  }\n  /**\n   * Will return a the string representation of the message\n   *\n   * @returns {String} Message\n   */\n\n\n  toString() {\n    return this.message;\n  }\n  /**\n   * Will return a string formatted for the console\n   *\n   * @returns {String} Message\n   */\n\n\n  inspect() {\n    return \"<Message: \".concat(this.toString(), \">\");\n  }\n\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n/**\n * PDKBF2\n * Credit to: https://github.com/stayradiated/pbkdf2-sha512\n * Copyright (c) 2014, JP Richardson Copyright (c) 2010-2011 Intalio Pte, All Rights Reserved\n */\n\nfunction pbkdf2(key, salt, iterations, dkLen) {\n  var hLen = 64; // SHA512 Mac length\n\n  if (dkLen > (2 ** 32 - 1) * hLen) {\n    throw Error('Requested key length too long');\n  }\n\n  if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n    throw new TypeError('key must a string or Buffer');\n  }\n\n  if (typeof salt !== 'string' && !Buffer.isBuffer(salt)) {\n    throw new TypeError('salt must a string or Buffer');\n  }\n\n  if (typeof key === 'string') {\n    key = Buffer.from(key);\n  }\n\n  if (typeof salt === 'string') {\n    salt = Buffer.from(salt);\n  }\n\n  var DK = Buffer.alloc(dkLen);\n  var U = Buffer.alloc(hLen);\n  var T = Buffer.alloc(hLen);\n  var block1 = Buffer.alloc(salt.length + 4);\n  var l = Math.ceil(dkLen / hLen);\n  var r = dkLen - (l - 1) * hLen;\n  salt.copy(block1, 0, 0, salt.length);\n\n  for (var i = 1; i <= l; i += 1) {\n    block1[salt.length + 0] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i >> 0 & 0xff;\n    var digest = hash.hmac(hash.sha512, key).update(block1).digest();\n    U = Buffer.from(digest);\n    U.copy(T, 0, 0, hLen);\n\n    for (var j = 1; j < iterations; j += 1) {\n      var innerDigest = hash.hmac(hash.sha512, key).update(U).digest();\n      U = Buffer.from(innerDigest);\n\n      for (var k = 0; k < hLen; k += 1) {\n        T[k] ^= U[k];\n      }\n    }\n\n    var destPos = (i - 1) * hLen;\n    var len = i === l ? r : hLen;\n    T.copy(DK, destPos, 0, len);\n  }\n\n  return DK;\n}\n\nvar CHINESE = ['的', '一', '是', '在', '不', '了', '有', '和', '人', '这', '中', '大', '为', '上', '个', '国', '我', '以', '要', '他', '时', '来', '用', '们', '生', '到', '作', '地', '于', '出', '就', '分', '对', '成', '会', '可', '主', '发', '年', '动', '同', '工', '也', '能', '下', '过', '子', '说', '产', '种', '面', '而', '方', '后', '多', '定', '行', '学', '法', '所', '民', '得', '经', '十', '三', '之', '进', '着', '等', '部', '度', '家', '电', '力', '里', '如', '水', '化', '高', '自', '二', '理', '起', '小', '物', '现', '实', '加', '量', '都', '两', '体', '制', '机', '当', '使', '点', '从', '业', '本', '去', '把', '性', '好', '应', '开', '它', '合', '还', '因', '由', '其', '些', '然', '前', '外', '天', '政', '四', '日', '那', '社', '义', '事', '平', '形', '相', '全', '表', '间', '样', '与', '关', '各', '重', '新', '线', '内', '数', '正', '心', '反', '你', '明', '看', '原', '又', '么', '利', '比', '或', '但', '质', '气', '第', '向', '道', '命', '此', '变', '条', '只', '没', '结', '解', '问', '意', '建', '月', '公', '无', '系', '军', '很', '情', '者', '最', '立', '代', '想', '已', '通', '并', '提', '直', '题', '党', '程', '展', '五', '果', '料', '象', '员', '革', '位', '入', '常', '文', '总', '次', '品', '式', '活', '设', '及', '管', '特', '件', '长', '求', '老', '头', '基', '资', '边', '流', '路', '级', '少', '图', '山', '统', '接', '知', '较', '将', '组', '见', '计', '别', '她', '手', '角', '期', '根', '论', '运', '农', '指', '几', '九', '区', '强', '放', '决', '西', '被', '干', '做', '必', '战', '先', '回', '则', '任', '取', '据', '处', '队', '南', '给', '色', '光', '门', '即', '保', '治', '北', '造', '百', '规', '热', '领', '七', '海', '口', '东', '导', '器', '压', '志', '世', '金', '增', '争', '济', '阶', '油', '思', '术', '极', '交', '受', '联', '什', '认', '六', '共', '权', '收', '证', '改', '清', '美', '再', '采', '转', '更', '单', '风', '切', '打', '白', '教', '速', '花', '带', '安', '场', '身', '车', '例', '真', '务', '具', '万', '每', '目', '至', '达', '走', '积', '示', '议', '声', '报', '斗', '完', '类', '八', '离', '华', '名', '确', '才', '科', '张', '信', '马', '节', '话', '米', '整', '空', '元', '况', '今', '集', '温', '传', '土', '许', '步', '群', '广', '石', '记', '需', '段', '研', '界', '拉', '林', '律', '叫', '且', '究', '观', '越', '织', '装', '影', '算', '低', '持', '音', '众', '书', '布', '复', '容', '儿', '须', '际', '商', '非', '验', '连', '断', '深', '难', '近', '矿', '千', '周', '委', '素', '技', '备', '半', '办', '青', '省', '列', '习', '响', '约', '支', '般', '史', '感', '劳', '便', '团', '往', '酸', '历', '市', '克', '何', '除', '消', '构', '府', '称', '太', '准', '精', '值', '号', '率', '族', '维', '划', '选', '标', '写', '存', '候', '毛', '亲', '快', '效', '斯', '院', '查', '江', '型', '眼', '王', '按', '格', '养', '易', '置', '派', '层', '片', '始', '却', '专', '状', '育', '厂', '京', '识', '适', '属', '圆', '包', '火', '住', '调', '满', '县', '局', '照', '参', '红', '细', '引', '听', '该', '铁', '价', '严', '首', '底', '液', '官', '德', '随', '病', '苏', '失', '尔', '死', '讲', '配', '女', '黄', '推', '显', '谈', '罪', '神', '艺', '呢', '席', '含', '企', '望', '密', '批', '营', '项', '防', '举', '球', '英', '氧', '势', '告', '李', '台', '落', '木', '帮', '轮', '破', '亚', '师', '围', '注', '远', '字', '材', '排', '供', '河', '态', '封', '另', '施', '减', '树', '溶', '怎', '止', '案', '言', '士', '均', '武', '固', '叶', '鱼', '波', '视', '仅', '费', '紧', '爱', '左', '章', '早', '朝', '害', '续', '轻', '服', '试', '食', '充', '兵', '源', '判', '护', '司', '足', '某', '练', '差', '致', '板', '田', '降', '黑', '犯', '负', '击', '范', '继', '兴', '似', '余', '坚', '曲', '输', '修', '故', '城', '夫', '够', '送', '笔', '船', '占', '右', '财', '吃', '富', '春', '职', '觉', '汉', '画', '功', '巴', '跟', '虽', '杂', '飞', '检', '吸', '助', '升', '阳', '互', '初', '创', '抗', '考', '投', '坏', '策', '古', '径', '换', '未', '跑', '留', '钢', '曾', '端', '责', '站', '简', '述', '钱', '副', '尽', '帝', '射', '草', '冲', '承', '独', '令', '限', '阿', '宣', '环', '双', '请', '超', '微', '让', '控', '州', '良', '轴', '找', '否', '纪', '益', '依', '优', '顶', '础', '载', '倒', '房', '突', '坐', '粉', '敌', '略', '客', '袁', '冷', '胜', '绝', '析', '块', '剂', '测', '丝', '协', '诉', '念', '陈', '仍', '罗', '盐', '友', '洋', '错', '苦', '夜', '刑', '移', '频', '逐', '靠', '混', '母', '短', '皮', '终', '聚', '汽', '村', '云', '哪', '既', '距', '卫', '停', '烈', '央', '察', '烧', '迅', '境', '若', '印', '洲', '刻', '括', '激', '孔', '搞', '甚', '室', '待', '核', '校', '散', '侵', '吧', '甲', '游', '久', '菜', '味', '旧', '模', '湖', '货', '损', '预', '阻', '毫', '普', '稳', '乙', '妈', '植', '息', '扩', '银', '语', '挥', '酒', '守', '拿', '序', '纸', '医', '缺', '雨', '吗', '针', '刘', '啊', '急', '唱', '误', '训', '愿', '审', '附', '获', '茶', '鲜', '粮', '斤', '孩', '脱', '硫', '肥', '善', '龙', '演', '父', '渐', '血', '欢', '械', '掌', '歌', '沙', '刚', '攻', '谓', '盾', '讨', '晚', '粒', '乱', '燃', '矛', '乎', '杀', '药', '宁', '鲁', '贵', '钟', '煤', '读', '班', '伯', '香', '介', '迫', '句', '丰', '培', '握', '兰', '担', '弦', '蛋', '沉', '假', '穿', '执', '答', '乐', '谁', '顺', '烟', '缩', '征', '脸', '喜', '松', '脚', '困', '异', '免', '背', '星', '福', '买', '染', '井', '概', '慢', '怕', '磁', '倍', '祖', '皇', '促', '静', '补', '评', '翻', '肉', '践', '尼', '衣', '宽', '扬', '棉', '希', '伤', '操', '垂', '秋', '宜', '氢', '套', '督', '振', '架', '亮', '末', '宪', '庆', '编', '牛', '触', '映', '雷', '销', '诗', '座', '居', '抓', '裂', '胞', '呼', '娘', '景', '威', '绿', '晶', '厚', '盟', '衡', '鸡', '孙', '延', '危', '胶', '屋', '乡', '临', '陆', '顾', '掉', '呀', '灯', '岁', '措', '束', '耐', '剧', '玉', '赵', '跳', '哥', '季', '课', '凯', '胡', '额', '款', '绍', '卷', '齐', '伟', '蒸', '殖', '永', '宗', '苗', '川', '炉', '岩', '弱', '零', '杨', '奏', '沿', '露', '杆', '探', '滑', '镇', '饭', '浓', '航', '怀', '赶', '库', '夺', '伊', '灵', '税', '途', '灭', '赛', '归', '召', '鼓', '播', '盘', '裁', '险', '康', '唯', '录', '菌', '纯', '借', '糖', '盖', '横', '符', '私', '努', '堂', '域', '枪', '润', '幅', '哈', '竟', '熟', '虫', '泽', '脑', '壤', '碳', '欧', '遍', '侧', '寨', '敢', '彻', '虑', '斜', '薄', '庭', '纳', '弹', '饲', '伸', '折', '麦', '湿', '暗', '荷', '瓦', '塞', '床', '筑', '恶', '户', '访', '塔', '奇', '透', '梁', '刀', '旋', '迹', '卡', '氯', '遇', '份', '毒', '泥', '退', '洗', '摆', '灰', '彩', '卖', '耗', '夏', '择', '忙', '铜', '献', '硬', '予', '繁', '圈', '雪', '函', '亦', '抽', '篇', '阵', '阴', '丁', '尺', '追', '堆', '雄', '迎', '泛', '爸', '楼', '避', '谋', '吨', '野', '猪', '旗', '累', '偏', '典', '馆', '索', '秦', '脂', '潮', '爷', '豆', '忽', '托', '惊', '塑', '遗', '愈', '朱', '替', '纤', '粗', '倾', '尚', '痛', '楚', '谢', '奋', '购', '磨', '君', '池', '旁', '碎', '骨', '监', '捕', '弟', '暴', '割', '贯', '殊', '释', '词', '亡', '壁', '顿', '宝', '午', '尘', '闻', '揭', '炮', '残', '冬', '桥', '妇', '警', '综', '招', '吴', '付', '浮', '遭', '徐', '您', '摇', '谷', '赞', '箱', '隔', '订', '男', '吹', '园', '纷', '唐', '败', '宋', '玻', '巨', '耕', '坦', '荣', '闭', '湾', '键', '凡', '驻', '锅', '救', '恩', '剥', '凝', '碱', '齿', '截', '炼', '麻', '纺', '禁', '废', '盛', '版', '缓', '净', '睛', '昌', '婚', '涉', '筒', '嘴', '插', '岸', '朗', '庄', '街', '藏', '姑', '贸', '腐', '奴', '啦', '惯', '乘', '伙', '恢', '匀', '纱', '扎', '辩', '耳', '彪', '臣', '亿', '璃', '抵', '脉', '秀', '萨', '俄', '网', '舞', '店', '喷', '纵', '寸', '汗', '挂', '洪', '贺', '闪', '柬', '爆', '烯', '津', '稻', '墙', '软', '勇', '像', '滚', '厘', '蒙', '芳', '肯', '坡', '柱', '荡', '腿', '仪', '旅', '尾', '轧', '冰', '贡', '登', '黎', '削', '钻', '勒', '逃', '障', '氨', '郭', '峰', '币', '港', '伏', '轨', '亩', '毕', '擦', '莫', '刺', '浪', '秘', '援', '株', '健', '售', '股', '岛', '甘', '泡', '睡', '童', '铸', '汤', '阀', '休', '汇', '舍', '牧', '绕', '炸', '哲', '磷', '绩', '朋', '淡', '尖', '启', '陷', '柴', '呈', '徒', '颜', '泪', '稍', '忘', '泵', '蓝', '拖', '洞', '授', '镜', '辛', '壮', '锋', '贫', '虚', '弯', '摩', '泰', '幼', '廷', '尊', '窗', '纲', '弄', '隶', '疑', '氏', '宫', '姐', '震', '瑞', '怪', '尤', '琴', '循', '描', '膜', '违', '夹', '腰', '缘', '珠', '穷', '森', '枝', '竹', '沟', '催', '绳', '忆', '邦', '剩', '幸', '浆', '栏', '拥', '牙', '贮', '礼', '滤', '钠', '纹', '罢', '拍', '咱', '喊', '袖', '埃', '勤', '罚', '焦', '潜', '伍', '墨', '欲', '缝', '姓', '刊', '饱', '仿', '奖', '铝', '鬼', '丽', '跨', '默', '挖', '链', '扫', '喝', '袋', '炭', '污', '幕', '诸', '弧', '励', '梅', '奶', '洁', '灾', '舟', '鉴', '苯', '讼', '抱', '毁', '懂', '寒', '智', '埔', '寄', '届', '跃', '渡', '挑', '丹', '艰', '贝', '碰', '拔', '爹', '戴', '码', '梦', '芽', '熔', '赤', '渔', '哭', '敬', '颗', '奔', '铅', '仲', '虎', '稀', '妹', '乏', '珍', '申', '桌', '遵', '允', '隆', '螺', '仓', '魏', '锐', '晓', '氮', '兼', '隐', '碍', '赫', '拨', '忠', '肃', '缸', '牵', '抢', '博', '巧', '壳', '兄', '杜', '讯', '诚', '碧', '祥', '柯', '页', '巡', '矩', '悲', '灌', '龄', '伦', '票', '寻', '桂', '铺', '圣', '恐', '恰', '郑', '趣', '抬', '荒', '腾', '贴', '柔', '滴', '猛', '阔', '辆', '妻', '填', '撤', '储', '签', '闹', '扰', '紫', '砂', '递', '戏', '吊', '陶', '伐', '喂', '疗', '瓶', '婆', '抚', '臂', '摸', '忍', '虾', '蜡', '邻', '胸', '巩', '挤', '偶', '弃', '槽', '劲', '乳', '邓', '吉', '仁', '烂', '砖', '租', '乌', '舰', '伴', '瓜', '浅', '丙', '暂', '燥', '橡', '柳', '迷', '暖', '牌', '秧', '胆', '详', '簧', '踏', '瓷', '谱', '呆', '宾', '糊', '洛', '辉', '愤', '竞', '隙', '怒', '粘', '乃', '绪', '肩', '籍', '敏', '涂', '熙', '皆', '侦', '悬', '掘', '享', '纠', '醒', '狂', '锁', '淀', '恨', '牲', '霸', '爬', '赏', '逆', '玩', '陵', '祝', '秒', '浙', '貌', '役', '彼', '悉', '鸭', '趋', '凤', '晨', '畜', '辈', '秩', '卵', '署', '梯', '炎', '滩', '棋', '驱', '筛', '峡', '冒', '啥', '寿', '译', '浸', '泉', '帽', '迟', '硅', '疆', '贷', '漏', '稿', '冠', '嫩', '胁', '芯', '牢', '叛', '蚀', '奥', '鸣', '岭', '羊', '凭', '串', '塘', '绘', '酵', '融', '盆', '锡', '庙', '筹', '冻', '辅', '摄', '袭', '筋', '拒', '僚', '旱', '钾', '鸟', '漆', '沈', '眉', '疏', '添', '棒', '穗', '硝', '韩', '逼', '扭', '侨', '凉', '挺', '碗', '栽', '炒', '杯', '患', '馏', '劝', '豪', '辽', '勃', '鸿', '旦', '吏', '拜', '狗', '埋', '辊', '掩', '饮', '搬', '骂', '辞', '勾', '扣', '估', '蒋', '绒', '雾', '丈', '朵', '姆', '拟', '宇', '辑', '陕', '雕', '偿', '蓄', '崇', '剪', '倡', '厅', '咬', '驶', '薯', '刷', '斥', '番', '赋', '奉', '佛', '浇', '漫', '曼', '扇', '钙', '桃', '扶', '仔', '返', '俗', '亏', '腔', '鞋', '棱', '覆', '框', '悄', '叔', '撞', '骗', '勘', '旺', '沸', '孤', '吐', '孟', '渠', '屈', '疾', '妙', '惜', '仰', '狠', '胀', '谐', '抛', '霉', '桑', '岗', '嘛', '衰', '盗', '渗', '脏', '赖', '涌', '甜', '曹', '阅', '肌', '哩', '厉', '烃', '纬', '毅', '昨', '伪', '症', '煮', '叹', '钉', '搭', '茎', '笼', '酷', '偷', '弓', '锥', '恒', '杰', '坑', '鼻', '翼', '纶', '叙', '狱', '逮', '罐', '络', '棚', '抑', '膨', '蔬', '寺', '骤', '穆', '冶', '枯', '册', '尸', '凸', '绅', '坯', '牺', '焰', '轰', '欣', '晋', '瘦', '御', '锭', '锦', '丧', '旬', '锻', '垄', '搜', '扑', '邀', '亭', '酯', '迈', '舒', '脆', '酶', '闲', '忧', '酚', '顽', '羽', '涨', '卸', '仗', '陪', '辟', '惩', '杭', '姚', '肚', '捉', '飘', '漂', '昆', '欺', '吾', '郎', '烷', '汁', '呵', '饰', '萧', '雅', '邮', '迁', '燕', '撒', '姻', '赴', '宴', '烦', '债', '帐', '斑', '铃', '旨', '醇', '董', '饼', '雏', '姿', '拌', '傅', '腹', '妥', '揉', '贤', '拆', '歪', '葡', '胺', '丢', '浩', '徽', '昂', '垫', '挡', '览', '贪', '慰', '缴', '汪', '慌', '冯', '诺', '姜', '谊', '凶', '劣', '诬', '耀', '昏', '躺', '盈', '骑', '乔', '溪', '丛', '卢', '抹', '闷', '咨', '刮', '驾', '缆', '悟', '摘', '铒', '掷', '颇', '幻', '柄', '惠', '惨', '佳', '仇', '腊', '窝', '涤', '剑', '瞧', '堡', '泼', '葱', '罩', '霍', '捞', '胎', '苍', '滨', '俩', '捅', '湘', '砍', '霞', '邵', '萄', '疯', '淮', '遂', '熊', '粪', '烘', '宿', '档', '戈', '驳', '嫂', '裕', '徙', '箭', '捐', '肠', '撑', '晒', '辨', '殿', '莲', '摊', '搅', '酱', '屏', '疫', '哀', '蔡', '堵', '沫', '皱', '畅', '叠', '阁', '莱', '敲', '辖', '钩', '痕', '坝', '巷', '饿', '祸', '丘', '玄', '溜', '曰', '逻', '彭', '尝', '卿', '妨', '艇', '吞', '韦', '怨', '矮', '歇'];\nvar ENGLISH = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];\nvar FRENCH = ['abaisser', 'abandon', 'abdiquer', 'abeille', 'abolir', 'aborder', 'aboutir', 'aboyer', 'abrasif', 'abreuver', 'abriter', 'abroger', 'abrupt', 'absence', 'absolu', 'absurde', 'abusif', 'abyssal', 'académie', 'acajou', 'acarien', 'accabler', 'accepter', 'acclamer', 'accolade', 'accroche', 'accuser', 'acerbe', 'achat', 'acheter', 'aciduler', 'acier', 'acompte', 'acquérir', 'acronyme', 'acteur', 'actif', 'actuel', 'adepte', 'adéquat', 'adhésif', 'adjectif', 'adjuger', 'admettre', 'admirer', 'adopter', 'adorer', 'adoucir', 'adresse', 'adroit', 'adulte', 'adverbe', 'aérer', 'aéronef', 'affaire', 'affecter', 'affiche', 'affreux', 'affubler', 'agacer', 'agencer', 'agile', 'agiter', 'agrafer', 'agréable', 'agrume', 'aider', 'aiguille', 'ailier', 'aimable', 'aisance', 'ajouter', 'ajuster', 'alarmer', 'alchimie', 'alerte', 'algèbre', 'algue', 'aliéner', 'aliment', 'alléger', 'alliage', 'allouer', 'allumer', 'alourdir', 'alpaga', 'altesse', 'alvéole', 'amateur', 'ambigu', 'ambre', 'aménager', 'amertume', 'amidon', 'amiral', 'amorcer', 'amour', 'amovible', 'amphibie', 'ampleur', 'amusant', 'analyse', 'anaphore', 'anarchie', 'anatomie', 'ancien', 'anéantir', 'angle', 'angoisse', 'anguleux', 'animal', 'annexer', 'annonce', 'annuel', 'anodin', 'anomalie', 'anonyme', 'anormal', 'antenne', 'antidote', 'anxieux', 'apaiser', 'apéritif', 'aplanir', 'apologie', 'appareil', 'appeler', 'apporter', 'appuyer', 'aquarium', 'aqueduc', 'arbitre', 'arbuste', 'ardeur', 'ardoise', 'argent', 'arlequin', 'armature', 'armement', 'armoire', 'armure', 'arpenter', 'arracher', 'arriver', 'arroser', 'arsenic', 'artériel', 'article', 'aspect', 'asphalte', 'aspirer', 'assaut', 'asservir', 'assiette', 'associer', 'assurer', 'asticot', 'astre', 'astuce', 'atelier', 'atome', 'atrium', 'atroce', 'attaque', 'attentif', 'attirer', 'attraper', 'aubaine', 'auberge', 'audace', 'audible', 'augurer', 'aurore', 'automne', 'autruche', 'avaler', 'avancer', 'avarice', 'avenir', 'averse', 'aveugle', 'aviateur', 'avide', 'avion', 'aviser', 'avoine', 'avouer', 'avril', 'axial', 'axiome', 'badge', 'bafouer', 'bagage', 'baguette', 'baignade', 'balancer', 'balcon', 'baleine', 'balisage', 'bambin', 'bancaire', 'bandage', 'banlieue', 'bannière', 'banquier', 'barbier', 'baril', 'baron', 'barque', 'barrage', 'bassin', 'bastion', 'bataille', 'bateau', 'batterie', 'baudrier', 'bavarder', 'belette', 'bélier', 'belote', 'bénéfice', 'berceau', 'berger', 'berline', 'bermuda', 'besace', 'besogne', 'bétail', 'beurre', 'biberon', 'bicycle', 'bidule', 'bijou', 'bilan', 'bilingue', 'billard', 'binaire', 'biologie', 'biopsie', 'biotype', 'biscuit', 'bison', 'bistouri', 'bitume', 'bizarre', 'blafard', 'blague', 'blanchir', 'blessant', 'blinder', 'blond', 'bloquer', 'blouson', 'bobard', 'bobine', 'boire', 'boiser', 'bolide', 'bonbon', 'bondir', 'bonheur', 'bonifier', 'bonus', 'bordure', 'borne', 'botte', 'boucle', 'boueux', 'bougie', 'boulon', 'bouquin', 'bourse', 'boussole', 'boutique', 'boxeur', 'branche', 'brasier', 'brave', 'brebis', 'brèche', 'breuvage', 'bricoler', 'brigade', 'brillant', 'brioche', 'brique', 'brochure', 'broder', 'bronzer', 'brousse', 'broyeur', 'brume', 'brusque', 'brutal', 'bruyant', 'buffle', 'buisson', 'bulletin', 'bureau', 'burin', 'bustier', 'butiner', 'butoir', 'buvable', 'buvette', 'cabanon', 'cabine', 'cachette', 'cadeau', 'cadre', 'caféine', 'caillou', 'caisson', 'calculer', 'calepin', 'calibre', 'calmer', 'calomnie', 'calvaire', 'camarade', 'caméra', 'camion', 'campagne', 'canal', 'caneton', 'canon', 'cantine', 'canular', 'capable', 'caporal', 'caprice', 'capsule', 'capter', 'capuche', 'carabine', 'carbone', 'caresser', 'caribou', 'carnage', 'carotte', 'carreau', 'carton', 'cascade', 'casier', 'casque', 'cassure', 'causer', 'caution', 'cavalier', 'caverne', 'caviar', 'cédille', 'ceinture', 'céleste', 'cellule', 'cendrier', 'censurer', 'central', 'cercle', 'cérébral', 'cerise', 'cerner', 'cerveau', 'cesser', 'chagrin', 'chaise', 'chaleur', 'chambre', 'chance', 'chapitre', 'charbon', 'chasseur', 'chaton', 'chausson', 'chavirer', 'chemise', 'chenille', 'chéquier', 'chercher', 'cheval', 'chien', 'chiffre', 'chignon', 'chimère', 'chiot', 'chlorure', 'chocolat', 'choisir', 'chose', 'chouette', 'chrome', 'chute', 'cigare', 'cigogne', 'cimenter', 'cinéma', 'cintrer', 'circuler', 'cirer', 'cirque', 'citerne', 'citoyen', 'citron', 'civil', 'clairon', 'clameur', 'claquer', 'classe', 'clavier', 'client', 'cligner', 'climat', 'clivage', 'cloche', 'clonage', 'cloporte', 'cobalt', 'cobra', 'cocasse', 'cocotier', 'coder', 'codifier', 'coffre', 'cogner', 'cohésion', 'coiffer', 'coincer', 'colère', 'colibri', 'colline', 'colmater', 'colonel', 'combat', 'comédie', 'commande', 'compact', 'concert', 'conduire', 'confier', 'congeler', 'connoter', 'consonne', 'contact', 'convexe', 'copain', 'copie', 'corail', 'corbeau', 'cordage', 'corniche', 'corpus', 'correct', 'cortège', 'cosmique', 'costume', 'coton', 'coude', 'coupure', 'courage', 'couteau', 'couvrir', 'coyote', 'crabe', 'crainte', 'cravate', 'crayon', 'créature', 'créditer', 'crémeux', 'creuser', 'crevette', 'cribler', 'crier', 'cristal', 'critère', 'croire', 'croquer', 'crotale', 'crucial', 'cruel', 'crypter', 'cubique', 'cueillir', 'cuillère', 'cuisine', 'cuivre', 'culminer', 'cultiver', 'cumuler', 'cupide', 'curatif', 'curseur', 'cyanure', 'cycle', 'cylindre', 'cynique', 'daigner', 'damier', 'danger', 'danseur', 'dauphin', 'débattre', 'débiter', 'déborder', 'débrider', 'débutant', 'décaler', 'décembre', 'déchirer', 'décider', 'déclarer', 'décorer', 'décrire', 'décupler', 'dédale', 'déductif', 'déesse', 'défensif', 'défiler', 'défrayer', 'dégager', 'dégivrer', 'déglutir', 'dégrafer', 'déjeuner', 'délice', 'déloger', 'demander', 'demeurer', 'démolir', 'dénicher', 'dénouer', 'dentelle', 'dénuder', 'départ', 'dépenser', 'déphaser', 'déplacer', 'déposer', 'déranger', 'dérober', 'désastre', 'descente', 'désert', 'désigner', 'désobéir', 'dessiner', 'destrier', 'détacher', 'détester', 'détourer', 'détresse', 'devancer', 'devenir', 'deviner', 'devoir', 'diable', 'dialogue', 'diamant', 'dicter', 'différer', 'digérer', 'digital', 'digne', 'diluer', 'dimanche', 'diminuer', 'dioxyde', 'directif', 'diriger', 'discuter', 'disposer', 'dissiper', 'distance', 'divertir', 'diviser', 'docile', 'docteur', 'dogme', 'doigt', 'domaine', 'domicile', 'dompter', 'donateur', 'donjon', 'donner', 'dopamine', 'dortoir', 'dorure', 'dosage', 'doseur', 'dossier', 'dotation', 'douanier', 'double', 'douceur', 'douter', 'doyen', 'dragon', 'draper', 'dresser', 'dribbler', 'droiture', 'duperie', 'duplexe', 'durable', 'durcir', 'dynastie', 'éblouir', 'écarter', 'écharpe', 'échelle', 'éclairer', 'éclipse', 'éclore', 'écluse', 'école', 'économie', 'écorce', 'écouter', 'écraser', 'écrémer', 'écrivain', 'écrou', 'écume', 'écureuil', 'édifier', 'éduquer', 'effacer', 'effectif', 'effigie', 'effort', 'effrayer', 'effusion', 'égaliser', 'égarer', 'éjecter', 'élaborer', 'élargir', 'électron', 'élégant', 'éléphant', 'élève', 'éligible', 'élitisme', 'éloge', 'élucider', 'éluder', 'emballer', 'embellir', 'embryon', 'émeraude', 'émission', 'emmener', 'émotion', 'émouvoir', 'empereur', 'employer', 'emporter', 'emprise', 'émulsion', 'encadrer', 'enchère', 'enclave', 'encoche', 'endiguer', 'endosser', 'endroit', 'enduire', 'énergie', 'enfance', 'enfermer', 'enfouir', 'engager', 'engin', 'englober', 'énigme', 'enjamber', 'enjeu', 'enlever', 'ennemi', 'ennuyeux', 'enrichir', 'enrobage', 'enseigne', 'entasser', 'entendre', 'entier', 'entourer', 'entraver', 'énumérer', 'envahir', 'enviable', 'envoyer', 'enzyme', 'éolien', 'épaissir', 'épargne', 'épatant', 'épaule', 'épicerie', 'épidémie', 'épier', 'épilogue', 'épine', 'épisode', 'épitaphe', 'époque', 'épreuve', 'éprouver', 'épuisant', 'équerre', 'équipe', 'ériger', 'érosion', 'erreur', 'éruption', 'escalier', 'espadon', 'espèce', 'espiègle', 'espoir', 'esprit', 'esquiver', 'essayer', 'essence', 'essieu', 'essorer', 'estime', 'estomac', 'estrade', 'étagère', 'étaler', 'étanche', 'étatique', 'éteindre', 'étendoir', 'éternel', 'éthanol', 'éthique', 'ethnie', 'étirer', 'étoffer', 'étoile', 'étonnant', 'étourdir', 'étrange', 'étroit', 'étude', 'euphorie', 'évaluer', 'évasion', 'éventail', 'évidence', 'éviter', 'évolutif', 'évoquer', 'exact', 'exagérer', 'exaucer', 'exceller', 'excitant', 'exclusif', 'excuse', 'exécuter', 'exemple', 'exercer', 'exhaler', 'exhorter', 'exigence', 'exiler', 'exister', 'exotique', 'expédier', 'explorer', 'exposer', 'exprimer', 'exquis', 'extensif', 'extraire', 'exulter', 'fable', 'fabuleux', 'facette', 'facile', 'facture', 'faiblir', 'falaise', 'fameux', 'famille', 'farceur', 'farfelu', 'farine', 'farouche', 'fasciner', 'fatal', 'fatigue', 'faucon', 'fautif', 'faveur', 'favori', 'fébrile', 'féconder', 'fédérer', 'félin', 'femme', 'fémur', 'fendoir', 'féodal', 'fermer', 'féroce', 'ferveur', 'festival', 'feuille', 'feutre', 'février', 'fiasco', 'ficeler', 'fictif', 'fidèle', 'figure', 'filature', 'filetage', 'filière', 'filleul', 'filmer', 'filou', 'filtrer', 'financer', 'finir', 'fiole', 'firme', 'fissure', 'fixer', 'flairer', 'flamme', 'flasque', 'flatteur', 'fléau', 'flèche', 'fleur', 'flexion', 'flocon', 'flore', 'fluctuer', 'fluide', 'fluvial', 'folie', 'fonderie', 'fongible', 'fontaine', 'forcer', 'forgeron', 'formuler', 'fortune', 'fossile', 'foudre', 'fougère', 'fouiller', 'foulure', 'fourmi', 'fragile', 'fraise', 'franchir', 'frapper', 'frayeur', 'frégate', 'freiner', 'frelon', 'frémir', 'frénésie', 'frère', 'friable', 'friction', 'frisson', 'frivole', 'froid', 'fromage', 'frontal', 'frotter', 'fruit', 'fugitif', 'fuite', 'fureur', 'furieux', 'furtif', 'fusion', 'futur', 'gagner', 'galaxie', 'galerie', 'gambader', 'garantir', 'gardien', 'garnir', 'garrigue', 'gazelle', 'gazon', 'géant', 'gélatine', 'gélule', 'gendarme', 'général', 'génie', 'genou', 'gentil', 'géologie', 'géomètre', 'géranium', 'germe', 'gestuel', 'geyser', 'gibier', 'gicler', 'girafe', 'givre', 'glace', 'glaive', 'glisser', 'globe', 'gloire', 'glorieux', 'golfeur', 'gomme', 'gonfler', 'gorge', 'gorille', 'goudron', 'gouffre', 'goulot', 'goupille', 'gourmand', 'goutte', 'graduel', 'graffiti', 'graine', 'grand', 'grappin', 'gratuit', 'gravir', 'grenat', 'griffure', 'griller', 'grimper', 'grogner', 'gronder', 'grotte', 'groupe', 'gruger', 'grutier', 'gruyère', 'guépard', 'guerrier', 'guide', 'guimauve', 'guitare', 'gustatif', 'gymnaste', 'gyrostat', 'habitude', 'hachoir', 'halte', 'hameau', 'hangar', 'hanneton', 'haricot', 'harmonie', 'harpon', 'hasard', 'hélium', 'hématome', 'herbe', 'hérisson', 'hermine', 'héron', 'hésiter', 'heureux', 'hiberner', 'hibou', 'hilarant', 'histoire', 'hiver', 'homard', 'hommage', 'homogène', 'honneur', 'honorer', 'honteux', 'horde', 'horizon', 'horloge', 'hormone', 'horrible', 'houleux', 'housse', 'hublot', 'huileux', 'humain', 'humble', 'humide', 'humour', 'hurler', 'hydromel', 'hygiène', 'hymne', 'hypnose', 'idylle', 'ignorer', 'iguane', 'illicite', 'illusion', 'image', 'imbiber', 'imiter', 'immense', 'immobile', 'immuable', 'impact', 'impérial', 'implorer', 'imposer', 'imprimer', 'imputer', 'incarner', 'incendie', 'incident', 'incliner', 'incolore', 'indexer', 'indice', 'inductif', 'inédit', 'ineptie', 'inexact', 'infini', 'infliger', 'informer', 'infusion', 'ingérer', 'inhaler', 'inhiber', 'injecter', 'injure', 'innocent', 'inoculer', 'inonder', 'inscrire', 'insecte', 'insigne', 'insolite', 'inspirer', 'instinct', 'insulter', 'intact', 'intense', 'intime', 'intrigue', 'intuitif', 'inutile', 'invasion', 'inventer', 'inviter', 'invoquer', 'ironique', 'irradier', 'irréel', 'irriter', 'isoler', 'ivoire', 'ivresse', 'jaguar', 'jaillir', 'jambe', 'janvier', 'jardin', 'jauger', 'jaune', 'javelot', 'jetable', 'jeton', 'jeudi', 'jeunesse', 'joindre', 'joncher', 'jongler', 'joueur', 'jouissif', 'journal', 'jovial', 'joyau', 'joyeux', 'jubiler', 'jugement', 'junior', 'jupon', 'juriste', 'justice', 'juteux', 'juvénile', 'kayak', 'kimono', 'kiosque', 'label', 'labial', 'labourer', 'lacérer', 'lactose', 'lagune', 'laine', 'laisser', 'laitier', 'lambeau', 'lamelle', 'lampe', 'lanceur', 'langage', 'lanterne', 'lapin', 'largeur', 'larme', 'laurier', 'lavabo', 'lavoir', 'lecture', 'légal', 'léger', 'légume', 'lessive', 'lettre', 'levier', 'lexique', 'lézard', 'liasse', 'libérer', 'libre', 'licence', 'licorne', 'liège', 'lièvre', 'ligature', 'ligoter', 'ligue', 'limer', 'limite', 'limonade', 'limpide', 'linéaire', 'lingot', 'lionceau', 'liquide', 'lisière', 'lister', 'lithium', 'litige', 'littoral', 'livreur', 'logique', 'lointain', 'loisir', 'lombric', 'loterie', 'louer', 'lourd', 'loutre', 'louve', 'loyal', 'lubie', 'lucide', 'lucratif', 'lueur', 'lugubre', 'luisant', 'lumière', 'lunaire', 'lundi', 'luron', 'lutter', 'luxueux', 'machine', 'magasin', 'magenta', 'magique', 'maigre', 'maillon', 'maintien', 'mairie', 'maison', 'majorer', 'malaxer', 'maléfice', 'malheur', 'malice', 'mallette', 'mammouth', 'mandater', 'maniable', 'manquant', 'manteau', 'manuel', 'marathon', 'marbre', 'marchand', 'mardi', 'maritime', 'marqueur', 'marron', 'marteler', 'mascotte', 'massif', 'matériel', 'matière', 'matraque', 'maudire', 'maussade', 'mauve', 'maximal', 'méchant', 'méconnu', 'médaille', 'médecin', 'méditer', 'méduse', 'meilleur', 'mélange', 'mélodie', 'membre', 'mémoire', 'menacer', 'mener', 'menhir', 'mensonge', 'mentor', 'mercredi', 'mérite', 'merle', 'messager', 'mesure', 'métal', 'météore', 'méthode', 'métier', 'meuble', 'miauler', 'microbe', 'miette', 'mignon', 'migrer', 'milieu', 'million', 'mimique', 'mince', 'minéral', 'minimal', 'minorer', 'minute', 'miracle', 'miroiter', 'missile', 'mixte', 'mobile', 'moderne', 'moelleux', 'mondial', 'moniteur', 'monnaie', 'monotone', 'monstre', 'montagne', 'monument', 'moqueur', 'morceau', 'morsure', 'mortier', 'moteur', 'motif', 'mouche', 'moufle', 'moulin', 'mousson', 'mouton', 'mouvant', 'multiple', 'munition', 'muraille', 'murène', 'murmure', 'muscle', 'muséum', 'musicien', 'mutation', 'muter', 'mutuel', 'myriade', 'myrtille', 'mystère', 'mythique', 'nageur', 'nappe', 'narquois', 'narrer', 'natation', 'nation', 'nature', 'naufrage', 'nautique', 'navire', 'nébuleux', 'nectar', 'néfaste', 'négation', 'négliger', 'négocier', 'neige', 'nerveux', 'nettoyer', 'neurone', 'neutron', 'neveu', 'niche', 'nickel', 'nitrate', 'niveau', 'noble', 'nocif', 'nocturne', 'noirceur', 'noisette', 'nomade', 'nombreux', 'nommer', 'normatif', 'notable', 'notifier', 'notoire', 'nourrir', 'nouveau', 'novateur', 'novembre', 'novice', 'nuage', 'nuancer', 'nuire', 'nuisible', 'numéro', 'nuptial', 'nuque', 'nutritif', 'obéir', 'objectif', 'obliger', 'obscur', 'observer', 'obstacle', 'obtenir', 'obturer', 'occasion', 'occuper', 'océan', 'octobre', 'octroyer', 'octupler', 'oculaire', 'odeur', 'odorant', 'offenser', 'officier', 'offrir', 'ogive', 'oiseau', 'oisillon', 'olfactif', 'olivier', 'ombrage', 'omettre', 'onctueux', 'onduler', 'onéreux', 'onirique', 'opale', 'opaque', 'opérer', 'opinion', 'opportun', 'opprimer', 'opter', 'optique', 'orageux', 'orange', 'orbite', 'ordonner', 'oreille', 'organe', 'orgueil', 'orifice', 'ornement', 'orque', 'ortie', 'osciller', 'osmose', 'ossature', 'otarie', 'ouragan', 'ourson', 'outil', 'outrager', 'ouvrage', 'ovation', 'oxyde', 'oxygène', 'ozone', 'paisible', 'palace', 'palmarès', 'palourde', 'palper', 'panache', 'panda', 'pangolin', 'paniquer', 'panneau', 'panorama', 'pantalon', 'papaye', 'papier', 'papoter', 'papyrus', 'paradoxe', 'parcelle', 'paresse', 'parfumer', 'parler', 'parole', 'parrain', 'parsemer', 'partager', 'parure', 'parvenir', 'passion', 'pastèque', 'paternel', 'patience', 'patron', 'pavillon', 'pavoiser', 'payer', 'paysage', 'peigne', 'peintre', 'pelage', 'pélican', 'pelle', 'pelouse', 'peluche', 'pendule', 'pénétrer', 'pénible', 'pensif', 'pénurie', 'pépite', 'péplum', 'perdrix', 'perforer', 'période', 'permuter', 'perplexe', 'persil', 'perte', 'peser', 'pétale', 'petit', 'pétrir', 'peuple', 'pharaon', 'phobie', 'phoque', 'photon', 'phrase', 'physique', 'piano', 'pictural', 'pièce', 'pierre', 'pieuvre', 'pilote', 'pinceau', 'pipette', 'piquer', 'pirogue', 'piscine', 'piston', 'pivoter', 'pixel', 'pizza', 'placard', 'plafond', 'plaisir', 'planer', 'plaque', 'plastron', 'plateau', 'pleurer', 'plexus', 'pliage', 'plomb', 'plonger', 'pluie', 'plumage', 'pochette', 'poésie', 'poète', 'pointe', 'poirier', 'poisson', 'poivre', 'polaire', 'policier', 'pollen', 'polygone', 'pommade', 'pompier', 'ponctuel', 'pondérer', 'poney', 'portique', 'position', 'posséder', 'posture', 'potager', 'poteau', 'potion', 'pouce', 'poulain', 'poumon', 'pourpre', 'poussin', 'pouvoir', 'prairie', 'pratique', 'précieux', 'prédire', 'préfixe', 'prélude', 'prénom', 'présence', 'prétexte', 'prévoir', 'primitif', 'prince', 'prison', 'priver', 'problème', 'procéder', 'prodige', 'profond', 'progrès', 'proie', 'projeter', 'prologue', 'promener', 'propre', 'prospère', 'protéger', 'prouesse', 'proverbe', 'prudence', 'pruneau', 'psychose', 'public', 'puceron', 'puiser', 'pulpe', 'pulsar', 'punaise', 'punitif', 'pupitre', 'purifier', 'puzzle', 'pyramide', 'quasar', 'querelle', 'question', 'quiétude', 'quitter', 'quotient', 'racine', 'raconter', 'radieux', 'ragondin', 'raideur', 'raisin', 'ralentir', 'rallonge', 'ramasser', 'rapide', 'rasage', 'ratisser', 'ravager', 'ravin', 'rayonner', 'réactif', 'réagir', 'réaliser', 'réanimer', 'recevoir', 'réciter', 'réclamer', 'récolter', 'recruter', 'reculer', 'recycler', 'rédiger', 'redouter', 'refaire', 'réflexe', 'réformer', 'refrain', 'refuge', 'régalien', 'région', 'réglage', 'régulier', 'réitérer', 'rejeter', 'rejouer', 'relatif', 'relever', 'relief', 'remarque', 'remède', 'remise', 'remonter', 'remplir', 'remuer', 'renard', 'renfort', 'renifler', 'renoncer', 'rentrer', 'renvoi', 'replier', 'reporter', 'reprise', 'reptile', 'requin', 'réserve', 'résineux', 'résoudre', 'respect', 'rester', 'résultat', 'rétablir', 'retenir', 'réticule', 'retomber', 'retracer', 'réunion', 'réussir', 'revanche', 'revivre', 'révolte', 'révulsif', 'richesse', 'rideau', 'rieur', 'rigide', 'rigoler', 'rincer', 'riposter', 'risible', 'risque', 'rituel', 'rival', 'rivière', 'rocheux', 'romance', 'rompre', 'ronce', 'rondin', 'roseau', 'rosier', 'rotatif', 'rotor', 'rotule', 'rouge', 'rouille', 'rouleau', 'routine', 'royaume', 'ruban', 'rubis', 'ruche', 'ruelle', 'rugueux', 'ruiner', 'ruisseau', 'ruser', 'rustique', 'rythme', 'sabler', 'saboter', 'sabre', 'sacoche', 'safari', 'sagesse', 'saisir', 'salade', 'salive', 'salon', 'saluer', 'samedi', 'sanction', 'sanglier', 'sarcasme', 'sardine', 'saturer', 'saugrenu', 'saumon', 'sauter', 'sauvage', 'savant', 'savonner', 'scalpel', 'scandale', 'scélérat', 'scénario', 'sceptre', 'schéma', 'science', 'scinder', 'score', 'scrutin', 'sculpter', 'séance', 'sécable', 'sécher', 'secouer', 'sécréter', 'sédatif', 'séduire', 'seigneur', 'séjour', 'sélectif', 'semaine', 'sembler', 'semence', 'séminal', 'sénateur', 'sensible', 'sentence', 'séparer', 'séquence', 'serein', 'sergent', 'sérieux', 'serrure', 'sérum', 'service', 'sésame', 'sévir', 'sevrage', 'sextuple', 'sidéral', 'siècle', 'siéger', 'siffler', 'sigle', 'signal', 'silence', 'silicium', 'simple', 'sincère', 'sinistre', 'siphon', 'sirop', 'sismique', 'situer', 'skier', 'social', 'socle', 'sodium', 'soigneux', 'soldat', 'soleil', 'solitude', 'soluble', 'sombre', 'sommeil', 'somnoler', 'sonde', 'songeur', 'sonnette', 'sonore', 'sorcier', 'sortir', 'sosie', 'sottise', 'soucieux', 'soudure', 'souffle', 'soulever', 'soupape', 'source', 'soutirer', 'souvenir', 'spacieux', 'spatial', 'spécial', 'sphère', 'spiral', 'stable', 'station', 'sternum', 'stimulus', 'stipuler', 'strict', 'studieux', 'stupeur', 'styliste', 'sublime', 'substrat', 'subtil', 'subvenir', 'succès', 'sucre', 'suffixe', 'suggérer', 'suiveur', 'sulfate', 'superbe', 'supplier', 'surface', 'suricate', 'surmener', 'surprise', 'sursaut', 'survie', 'suspect', 'syllabe', 'symbole', 'symétrie', 'synapse', 'syntaxe', 'système', 'tabac', 'tablier', 'tactile', 'tailler', 'talent', 'talisman', 'talonner', 'tambour', 'tamiser', 'tangible', 'tapis', 'taquiner', 'tarder', 'tarif', 'tartine', 'tasse', 'tatami', 'tatouage', 'taupe', 'taureau', 'taxer', 'témoin', 'temporel', 'tenaille', 'tendre', 'teneur', 'tenir', 'tension', 'terminer', 'terne', 'terrible', 'tétine', 'texte', 'thème', 'théorie', 'thérapie', 'thorax', 'tibia', 'tiède', 'timide', 'tirelire', 'tiroir', 'tissu', 'titane', 'titre', 'tituber', 'toboggan', 'tolérant', 'tomate', 'tonique', 'tonneau', 'toponyme', 'torche', 'tordre', 'tornade', 'torpille', 'torrent', 'torse', 'tortue', 'totem', 'toucher', 'tournage', 'tousser', 'toxine', 'traction', 'trafic', 'tragique', 'trahir', 'train', 'trancher', 'travail', 'trèfle', 'tremper', 'trésor', 'treuil', 'triage', 'tribunal', 'tricoter', 'trilogie', 'triomphe', 'tripler', 'triturer', 'trivial', 'trombone', 'tronc', 'tropical', 'troupeau', 'tuile', 'tulipe', 'tumulte', 'tunnel', 'turbine', 'tuteur', 'tutoyer', 'tuyau', 'tympan', 'typhon', 'typique', 'tyran', 'ubuesque', 'ultime', 'ultrason', 'unanime', 'unifier', 'union', 'unique', 'unitaire', 'univers', 'uranium', 'urbain', 'urticant', 'usage', 'usine', 'usuel', 'usure', 'utile', 'utopie', 'vacarme', 'vaccin', 'vagabond', 'vague', 'vaillant', 'vaincre', 'vaisseau', 'valable', 'valise', 'vallon', 'valve', 'vampire', 'vanille', 'vapeur', 'varier', 'vaseux', 'vassal', 'vaste', 'vecteur', 'vedette', 'végétal', 'véhicule', 'veinard', 'véloce', 'vendredi', 'vénérer', 'venger', 'venimeux', 'ventouse', 'verdure', 'vérin', 'vernir', 'verrou', 'verser', 'vertu', 'veston', 'vétéran', 'vétuste', 'vexant', 'vexer', 'viaduc', 'viande', 'victoire', 'vidange', 'vidéo', 'vignette', 'vigueur', 'vilain', 'village', 'vinaigre', 'violon', 'vipère', 'virement', 'virtuose', 'virus', 'visage', 'viseur', 'vision', 'visqueux', 'visuel', 'vital', 'vitesse', 'viticole', 'vitrine', 'vivace', 'vivipare', 'vocation', 'voguer', 'voile', 'voisin', 'voiture', 'volaille', 'volcan', 'voltiger', 'volume', 'vorace', 'vortex', 'voter', 'vouloir', 'voyage', 'voyelle', 'wagon', 'xénon', 'yacht', 'zèbre', 'zénith', 'zeste', 'zoologie'];\nvar ITALIAN = ['abaco', 'abbaglio', 'abbinato', 'abete', 'abisso', 'abolire', 'abrasivo', 'abrogato', 'accadere', 'accenno', 'accusato', 'acetone', 'achille', 'acido', 'acqua', 'acre', 'acrilico', 'acrobata', 'acuto', 'adagio', 'addebito', 'addome', 'adeguato', 'aderire', 'adipe', 'adottare', 'adulare', 'affabile', 'affetto', 'affisso', 'affranto', 'aforisma', 'afoso', 'africano', 'agave', 'agente', 'agevole', 'aggancio', 'agire', 'agitare', 'agonismo', 'agricolo', 'agrumeto', 'aguzzo', 'alabarda', 'alato', 'albatro', 'alberato', 'albo', 'albume', 'alce', 'alcolico', 'alettone', 'alfa', 'algebra', 'aliante', 'alibi', 'alimento', 'allagato', 'allegro', 'allievo', 'allodola', 'allusivo', 'almeno', 'alogeno', 'alpaca', 'alpestre', 'altalena', 'alterno', 'alticcio', 'altrove', 'alunno', 'alveolo', 'alzare', 'amalgama', 'amanita', 'amarena', 'ambito', 'ambrato', 'ameba', 'america', 'ametista', 'amico', 'ammasso', 'ammenda', 'ammirare', 'ammonito', 'amore', 'ampio', 'ampliare', 'amuleto', 'anacardo', 'anagrafe', 'analista', 'anarchia', 'anatra', 'anca', 'ancella', 'ancora', 'andare', 'andrea', 'anello', 'angelo', 'angolare', 'angusto', 'anima', 'annegare', 'annidato', 'anno', 'annuncio', 'anonimo', 'anticipo', 'anzi', 'apatico', 'apertura', 'apode', 'apparire', 'appetito', 'appoggio', 'approdo', 'appunto', 'aprile', 'arabica', 'arachide', 'aragosta', 'araldica', 'arancio', 'aratura', 'arazzo', 'arbitro', 'archivio', 'ardito', 'arenile', 'argento', 'argine', 'arguto', 'aria', 'armonia', 'arnese', 'arredato', 'arringa', 'arrosto', 'arsenico', 'arso', 'artefice', 'arzillo', 'asciutto', 'ascolto', 'asepsi', 'asettico', 'asfalto', 'asino', 'asola', 'aspirato', 'aspro', 'assaggio', 'asse', 'assoluto', 'assurdo', 'asta', 'astenuto', 'astice', 'astratto', 'atavico', 'ateismo', 'atomico', 'atono', 'attesa', 'attivare', 'attorno', 'attrito', 'attuale', 'ausilio', 'austria', 'autista', 'autonomo', 'autunno', 'avanzato', 'avere', 'avvenire', 'avviso', 'avvolgere', 'azione', 'azoto', 'azzimo', 'azzurro', 'babele', 'baccano', 'bacino', 'baco', 'badessa', 'badilata', 'bagnato', 'baita', 'balcone', 'baldo', 'balena', 'ballata', 'balzano', 'bambino', 'bandire', 'baraonda', 'barbaro', 'barca', 'baritono', 'barlume', 'barocco', 'basilico', 'basso', 'batosta', 'battuto', 'baule', 'bava', 'bavosa', 'becco', 'beffa', 'belgio', 'belva', 'benda', 'benevole', 'benigno', 'benzina', 'bere', 'berlina', 'beta', 'bibita', 'bici', 'bidone', 'bifido', 'biga', 'bilancia', 'bimbo', 'binocolo', 'biologo', 'bipede', 'bipolare', 'birbante', 'birra', 'biscotto', 'bisesto', 'bisnonno', 'bisonte', 'bisturi', 'bizzarro', 'blando', 'blatta', 'bollito', 'bonifico', 'bordo', 'bosco', 'botanico', 'bottino', 'bozzolo', 'braccio', 'bradipo', 'brama', 'branca', 'bravura', 'bretella', 'brevetto', 'brezza', 'briglia', 'brillante', 'brindare', 'broccolo', 'brodo', 'bronzina', 'brullo', 'bruno', 'bubbone', 'buca', 'budino', 'buffone', 'buio', 'bulbo', 'buono', 'burlone', 'burrasca', 'bussola', 'busta', 'cadetto', 'caduco', 'calamaro', 'calcolo', 'calesse', 'calibro', 'calmo', 'caloria', 'cambusa', 'camerata', 'camicia', 'cammino', 'camola', 'campale', 'canapa', 'candela', 'cane', 'canino', 'canotto', 'cantina', 'capace', 'capello', 'capitolo', 'capogiro', 'cappero', 'capra', 'capsula', 'carapace', 'carcassa', 'cardo', 'carisma', 'carovana', 'carretto', 'cartolina', 'casaccio', 'cascata', 'caserma', 'caso', 'cassone', 'castello', 'casuale', 'catasta', 'catena', 'catrame', 'cauto', 'cavillo', 'cedibile', 'cedrata', 'cefalo', 'celebre', 'cellulare', 'cena', 'cenone', 'centesimo', 'ceramica', 'cercare', 'certo', 'cerume', 'cervello', 'cesoia', 'cespo', 'ceto', 'chela', 'chiaro', 'chicca', 'chiedere', 'chimera', 'china', 'chirurgo', 'chitarra', 'ciao', 'ciclismo', 'cifrare', 'cigno', 'cilindro', 'ciottolo', 'circa', 'cirrosi', 'citrico', 'cittadino', 'ciuffo', 'civetta', 'civile', 'classico', 'clinica', 'cloro', 'cocco', 'codardo', 'codice', 'coerente', 'cognome', 'collare', 'colmato', 'colore', 'colposo', 'coltivato', 'colza', 'coma', 'cometa', 'commando', 'comodo', 'computer', 'comune', 'conciso', 'condurre', 'conferma', 'congelare', 'coniuge', 'connesso', 'conoscere', 'consumo', 'continuo', 'convegno', 'coperto', 'copione', 'coppia', 'copricapo', 'corazza', 'cordata', 'coricato', 'cornice', 'corolla', 'corpo', 'corredo', 'corsia', 'cortese', 'cosmico', 'costante', 'cottura', 'covato', 'cratere', 'cravatta', 'creato', 'credere', 'cremoso', 'crescita', 'creta', 'criceto', 'crinale', 'crisi', 'critico', 'croce', 'cronaca', 'crostata', 'cruciale', 'crusca', 'cucire', 'cuculo', 'cugino', 'cullato', 'cupola', 'curatore', 'cursore', 'curvo', 'cuscino', 'custode', 'dado', 'daino', 'dalmata', 'damerino', 'daniela', 'dannoso', 'danzare', 'datato', 'davanti', 'davvero', 'debutto', 'decennio', 'deciso', 'declino', 'decollo', 'decreto', 'dedicato', 'definito', 'deforme', 'degno', 'delegare', 'delfino', 'delirio', 'delta', 'demenza', 'denotato', 'dentro', 'deposito', 'derapata', 'derivare', 'deroga', 'descritto', 'deserto', 'desiderio', 'desumere', 'detersivo', 'devoto', 'diametro', 'dicembre', 'diedro', 'difeso', 'diffuso', 'digerire', 'digitale', 'diluvio', 'dinamico', 'dinnanzi', 'dipinto', 'diploma', 'dipolo', 'diradare', 'dire', 'dirotto', 'dirupo', 'disagio', 'discreto', 'disfare', 'disgelo', 'disposto', 'distanza', 'disumano', 'dito', 'divano', 'divelto', 'dividere', 'divorato', 'doblone', 'docente', 'doganale', 'dogma', 'dolce', 'domato', 'domenica', 'dominare', 'dondolo', 'dono', 'dormire', 'dote', 'dottore', 'dovuto', 'dozzina', 'drago', 'druido', 'dubbio', 'dubitare', 'ducale', 'duna', 'duomo', 'duplice', 'duraturo', 'ebano', 'eccesso', 'ecco', 'eclissi', 'economia', 'edera', 'edicola', 'edile', 'editoria', 'educare', 'egemonia', 'egli', 'egoismo', 'egregio', 'elaborato', 'elargire', 'elegante', 'elencato', 'eletto', 'elevare', 'elfico', 'elica', 'elmo', 'elsa', 'eluso', 'emanato', 'emblema', 'emesso', 'emiro', 'emotivo', 'emozione', 'empirico', 'emulo', 'endemico', 'enduro', 'energia', 'enfasi', 'enoteca', 'entrare', 'enzima', 'epatite', 'epilogo', 'episodio', 'epocale', 'eppure', 'equatore', 'erario', 'erba', 'erboso', 'erede', 'eremita', 'erigere', 'ermetico', 'eroe', 'erosivo', 'errante', 'esagono', 'esame', 'esanime', 'esaudire', 'esca', 'esempio', 'esercito', 'esibito', 'esigente', 'esistere', 'esito', 'esofago', 'esortato', 'esoso', 'espanso', 'espresso', 'essenza', 'esso', 'esteso', 'estimare', 'estonia', 'estroso', 'esultare', 'etilico', 'etnico', 'etrusco', 'etto', 'euclideo', 'europa', 'evaso', 'evidenza', 'evitato', 'evoluto', 'evviva', 'fabbrica', 'faccenda', 'fachiro', 'falco', 'famiglia', 'fanale', 'fanfara', 'fango', 'fantasma', 'fare', 'farfalla', 'farinoso', 'farmaco', 'fascia', 'fastoso', 'fasullo', 'faticare', 'fato', 'favoloso', 'febbre', 'fecola', 'fede', 'fegato', 'felpa', 'feltro', 'femmina', 'fendere', 'fenomeno', 'fermento', 'ferro', 'fertile', 'fessura', 'festivo', 'fetta', 'feudo', 'fiaba', 'fiducia', 'fifa', 'figurato', 'filo', 'finanza', 'finestra', 'finire', 'fiore', 'fiscale', 'fisico', 'fiume', 'flacone', 'flamenco', 'flebo', 'flemma', 'florido', 'fluente', 'fluoro', 'fobico', 'focaccia', 'focoso', 'foderato', 'foglio', 'folata', 'folclore', 'folgore', 'fondente', 'fonetico', 'fonia', 'fontana', 'forbito', 'forchetta', 'foresta', 'formica', 'fornaio', 'foro', 'fortezza', 'forzare', 'fosfato', 'fosso', 'fracasso', 'frana', 'frassino', 'fratello', 'freccetta', 'frenata', 'fresco', 'frigo', 'frollino', 'fronde', 'frugale', 'frutta', 'fucilata', 'fucsia', 'fuggente', 'fulmine', 'fulvo', 'fumante', 'fumetto', 'fumoso', 'fune', 'funzione', 'fuoco', 'furbo', 'furgone', 'furore', 'fuso', 'futile', 'gabbiano', 'gaffe', 'galateo', 'gallina', 'galoppo', 'gambero', 'gamma', 'garanzia', 'garbo', 'garofano', 'garzone', 'gasdotto', 'gasolio', 'gastrico', 'gatto', 'gaudio', 'gazebo', 'gazzella', 'geco', 'gelatina', 'gelso', 'gemello', 'gemmato', 'gene', 'genitore', 'gennaio', 'genotipo', 'gergo', 'ghepardo', 'ghiaccio', 'ghisa', 'giallo', 'gilda', 'ginepro', 'giocare', 'gioiello', 'giorno', 'giove', 'girato', 'girone', 'gittata', 'giudizio', 'giurato', 'giusto', 'globulo', 'glutine', 'gnomo', 'gobba', 'golf', 'gomito', 'gommone', 'gonfio', 'gonna', 'governo', 'gracile', 'grado', 'grafico', 'grammo', 'grande', 'grattare', 'gravoso', 'grazia', 'greca', 'gregge', 'grifone', 'grigio', 'grinza', 'grotta', 'gruppo', 'guadagno', 'guaio', 'guanto', 'guardare', 'gufo', 'guidare', 'ibernato', 'icona', 'identico', 'idillio', 'idolo', 'idra', 'idrico', 'idrogeno', 'igiene', 'ignaro', 'ignorato', 'ilare', 'illeso', 'illogico', 'illudere', 'imballo', 'imbevuto', 'imbocco', 'imbuto', 'immane', 'immerso', 'immolato', 'impacco', 'impeto', 'impiego', 'importo', 'impronta', 'inalare', 'inarcare', 'inattivo', 'incanto', 'incendio', 'inchino', 'incisivo', 'incluso', 'incontro', 'incrocio', 'incubo', 'indagine', 'india', 'indole', 'inedito', 'infatti', 'infilare', 'inflitto', 'ingaggio', 'ingegno', 'inglese', 'ingordo', 'ingrosso', 'innesco', 'inodore', 'inoltrare', 'inondato', 'insano', 'insetto', 'insieme', 'insonnia', 'insulina', 'intasato', 'intero', 'intonaco', 'intuito', 'inumidire', 'invalido', 'invece', 'invito', 'iperbole', 'ipnotico', 'ipotesi', 'ippica', 'iride', 'irlanda', 'ironico', 'irrigato', 'irrorare', 'isolato', 'isotopo', 'isterico', 'istituto', 'istrice', 'italia', 'iterare', 'labbro', 'labirinto', 'lacca', 'lacerato', 'lacrima', 'lacuna', 'laddove', 'lago', 'lampo', 'lancetta', 'lanterna', 'lardoso', 'larga', 'laringe', 'lastra', 'latenza', 'latino', 'lattuga', 'lavagna', 'lavoro', 'legale', 'leggero', 'lembo', 'lentezza', 'lenza', 'leone', 'lepre', 'lesivo', 'lessato', 'lesto', 'letterale', 'leva', 'levigato', 'libero', 'lido', 'lievito', 'lilla', 'limatura', 'limitare', 'limpido', 'lineare', 'lingua', 'liquido', 'lira', 'lirica', 'lisca', 'lite', 'litigio', 'livrea', 'locanda', 'lode', 'logica', 'lombare', 'londra', 'longevo', 'loquace', 'lorenzo', 'loto', 'lotteria', 'luce', 'lucidato', 'lumaca', 'luminoso', 'lungo', 'lupo', 'luppolo', 'lusinga', 'lusso', 'lutto', 'macabro', 'macchina', 'macero', 'macinato', 'madama', 'magico', 'maglia', 'magnete', 'magro', 'maiolica', 'malafede', 'malgrado', 'malinteso', 'malsano', 'malto', 'malumore', 'mana', 'mancia', 'mandorla', 'mangiare', 'manifesto', 'mannaro', 'manovra', 'mansarda', 'mantide', 'manubrio', 'mappa', 'maratona', 'marcire', 'maretta', 'marmo', 'marsupio', 'maschera', 'massaia', 'mastino', 'materasso', 'matricola', 'mattone', 'maturo', 'mazurca', 'meandro', 'meccanico', 'mecenate', 'medesimo', 'meditare', 'mega', 'melassa', 'melis', 'melodia', 'meninge', 'meno', 'mensola', 'mercurio', 'merenda', 'merlo', 'meschino', 'mese', 'messere', 'mestolo', 'metallo', 'metodo', 'mettere', 'miagolare', 'mica', 'micelio', 'michele', 'microbo', 'midollo', 'miele', 'migliore', 'milano', 'milite', 'mimosa', 'minerale', 'mini', 'minore', 'mirino', 'mirtillo', 'miscela', 'missiva', 'misto', 'misurare', 'mitezza', 'mitigare', 'mitra', 'mittente', 'mnemonico', 'modello', 'modifica', 'modulo', 'mogano', 'mogio', 'mole', 'molosso', 'monastero', 'monco', 'mondina', 'monetario', 'monile', 'monotono', 'monsone', 'montato', 'monviso', 'mora', 'mordere', 'morsicato', 'mostro', 'motivato', 'motosega', 'motto', 'movenza', 'movimento', 'mozzo', 'mucca', 'mucosa', 'muffa', 'mughetto', 'mugnaio', 'mulatto', 'mulinello', 'multiplo', 'mummia', 'munto', 'muovere', 'murale', 'musa', 'muscolo', 'musica', 'mutevole', 'muto', 'nababbo', 'nafta', 'nanometro', 'narciso', 'narice', 'narrato', 'nascere', 'nastrare', 'naturale', 'nautica', 'naviglio', 'nebulosa', 'necrosi', 'negativo', 'negozio', 'nemmeno', 'neofita', 'neretto', 'nervo', 'nessuno', 'nettuno', 'neutrale', 'neve', 'nevrotico', 'nicchia', 'ninfa', 'nitido', 'nobile', 'nocivo', 'nodo', 'nome', 'nomina', 'nordico', 'normale', 'norvegese', 'nostrano', 'notare', 'notizia', 'notturno', 'novella', 'nucleo', 'nulla', 'numero', 'nuovo', 'nutrire', 'nuvola', 'nuziale', 'oasi', 'obbedire', 'obbligo', 'obelisco', 'oblio', 'obolo', 'obsoleto', 'occasione', 'occhio', 'occidente', 'occorrere', 'occultare', 'ocra', 'oculato', 'odierno', 'odorare', 'offerta', 'offrire', 'offuscato', 'oggetto', 'oggi', 'ognuno', 'olandese', 'olfatto', 'oliato', 'oliva', 'ologramma', 'oltre', 'omaggio', 'ombelico', 'ombra', 'omega', 'omissione', 'ondoso', 'onere', 'onice', 'onnivoro', 'onorevole', 'onta', 'operato', 'opinione', 'opposto', 'oracolo', 'orafo', 'ordine', 'orecchino', 'orefice', 'orfano', 'organico', 'origine', 'orizzonte', 'orma', 'ormeggio', 'ornativo', 'orologio', 'orrendo', 'orribile', 'ortensia', 'ortica', 'orzata', 'orzo', 'osare', 'oscurare', 'osmosi', 'ospedale', 'ospite', 'ossa', 'ossidare', 'ostacolo', 'oste', 'otite', 'otre', 'ottagono', 'ottimo', 'ottobre', 'ovale', 'ovest', 'ovino', 'oviparo', 'ovocito', 'ovunque', 'ovviare', 'ozio', 'pacchetto', 'pace', 'pacifico', 'padella', 'padrone', 'paese', 'paga', 'pagina', 'palazzina', 'palesare', 'pallido', 'palo', 'palude', 'pandoro', 'pannello', 'paolo', 'paonazzo', 'paprica', 'parabola', 'parcella', 'parere', 'pargolo', 'pari', 'parlato', 'parola', 'partire', 'parvenza', 'parziale', 'passivo', 'pasticca', 'patacca', 'patologia', 'pattume', 'pavone', 'peccato', 'pedalare', 'pedonale', 'peggio', 'peloso', 'penare', 'pendice', 'penisola', 'pennuto', 'penombra', 'pensare', 'pentola', 'pepe', 'pepita', 'perbene', 'percorso', 'perdonato', 'perforare', 'pergamena', 'periodo', 'permesso', 'perno', 'perplesso', 'persuaso', 'pertugio', 'pervaso', 'pesatore', 'pesista', 'peso', 'pestifero', 'petalo', 'pettine', 'petulante', 'pezzo', 'piacere', 'pianta', 'piattino', 'piccino', 'picozza', 'piega', 'pietra', 'piffero', 'pigiama', 'pigolio', 'pigro', 'pila', 'pilifero', 'pillola', 'pilota', 'pimpante', 'pineta', 'pinna', 'pinolo', 'pioggia', 'piombo', 'piramide', 'piretico', 'pirite', 'pirolisi', 'pitone', 'pizzico', 'placebo', 'planare', 'plasma', 'platano', 'plenario', 'pochezza', 'poderoso', 'podismo', 'poesia', 'poggiare', 'polenta', 'poligono', 'pollice', 'polmonite', 'polpetta', 'polso', 'poltrona', 'polvere', 'pomice', 'pomodoro', 'ponte', 'popoloso', 'porfido', 'poroso', 'porpora', 'porre', 'portata', 'posa', 'positivo', 'possesso', 'postulato', 'potassio', 'potere', 'pranzo', 'prassi', 'pratica', 'precluso', 'predica', 'prefisso', 'pregiato', 'prelievo', 'premere', 'prenotare', 'preparato', 'presenza', 'pretesto', 'prevalso', 'prima', 'principe', 'privato', 'problema', 'procura', 'produrre', 'profumo', 'progetto', 'prolunga', 'promessa', 'pronome', 'proposta', 'proroga', 'proteso', 'prova', 'prudente', 'prugna', 'prurito', 'psiche', 'pubblico', 'pudica', 'pugilato', 'pugno', 'pulce', 'pulito', 'pulsante', 'puntare', 'pupazzo', 'pupilla', 'puro', 'quadro', 'qualcosa', 'quasi', 'querela', 'quota', 'raccolto', 'raddoppio', 'radicale', 'radunato', 'raffica', 'ragazzo', 'ragione', 'ragno', 'ramarro', 'ramingo', 'ramo', 'randagio', 'rantolare', 'rapato', 'rapina', 'rappreso', 'rasatura', 'raschiato', 'rasente', 'rassegna', 'rastrello', 'rata', 'ravveduto', 'reale', 'recepire', 'recinto', 'recluta', 'recondito', 'recupero', 'reddito', 'redimere', 'regalato', 'registro', 'regola', 'regresso', 'relazione', 'remare', 'remoto', 'renna', 'replica', 'reprimere', 'reputare', 'resa', 'residente', 'responso', 'restauro', 'rete', 'retina', 'retorica', 'rettifica', 'revocato', 'riassunto', 'ribadire', 'ribelle', 'ribrezzo', 'ricarica', 'ricco', 'ricevere', 'riciclato', 'ricordo', 'ricreduto', 'ridicolo', 'ridurre', 'rifasare', 'riflesso', 'riforma', 'rifugio', 'rigare', 'rigettato', 'righello', 'rilassato', 'rilevato', 'rimanere', 'rimbalzo', 'rimedio', 'rimorchio', 'rinascita', 'rincaro', 'rinforzo', 'rinnovo', 'rinomato', 'rinsavito', 'rintocco', 'rinuncia', 'rinvenire', 'riparato', 'ripetuto', 'ripieno', 'riportare', 'ripresa', 'ripulire', 'risata', 'rischio', 'riserva', 'risibile', 'riso', 'rispetto', 'ristoro', 'risultato', 'risvolto', 'ritardo', 'ritegno', 'ritmico', 'ritrovo', 'riunione', 'riva', 'riverso', 'rivincita', 'rivolto', 'rizoma', 'roba', 'robotico', 'robusto', 'roccia', 'roco', 'rodaggio', 'rodere', 'roditore', 'rogito', 'rollio', 'romantico', 'rompere', 'ronzio', 'rosolare', 'rospo', 'rotante', 'rotondo', 'rotula', 'rovescio', 'rubizzo', 'rubrica', 'ruga', 'rullino', 'rumine', 'rumoroso', 'ruolo', 'rupe', 'russare', 'rustico', 'sabato', 'sabbiare', 'sabotato', 'sagoma', 'salasso', 'saldatura', 'salgemma', 'salivare', 'salmone', 'salone', 'saltare', 'saluto', 'salvo', 'sapere', 'sapido', 'saporito', 'saraceno', 'sarcasmo', 'sarto', 'sassoso', 'satellite', 'satira', 'satollo', 'saturno', 'savana', 'savio', 'saziato', 'sbadiglio', 'sbalzo', 'sbancato', 'sbarra', 'sbattere', 'sbavare', 'sbendare', 'sbirciare', 'sbloccato', 'sbocciato', 'sbrinare', 'sbruffone', 'sbuffare', 'scabroso', 'scadenza', 'scala', 'scambiare', 'scandalo', 'scapola', 'scarso', 'scatenare', 'scavato', 'scelto', 'scenico', 'scettro', 'scheda', 'schiena', 'sciarpa', 'scienza', 'scindere', 'scippo', 'sciroppo', 'scivolo', 'sclerare', 'scodella', 'scolpito', 'scomparto', 'sconforto', 'scoprire', 'scorta', 'scossone', 'scozzese', 'scriba', 'scrollare', 'scrutinio', 'scuderia', 'scultore', 'scuola', 'scuro', 'scusare', 'sdebitare', 'sdoganare', 'seccatura', 'secondo', 'sedano', 'seggiola', 'segnalato', 'segregato', 'seguito', 'selciato', 'selettivo', 'sella', 'selvaggio', 'semaforo', 'sembrare', 'seme', 'seminato', 'sempre', 'senso', 'sentire', 'sepolto', 'sequenza', 'serata', 'serbato', 'sereno', 'serio', 'serpente', 'serraglio', 'servire', 'sestina', 'setola', 'settimana', 'sfacelo', 'sfaldare', 'sfamato', 'sfarzoso', 'sfaticato', 'sfera', 'sfida', 'sfilato', 'sfinge', 'sfocato', 'sfoderare', 'sfogo', 'sfoltire', 'sforzato', 'sfratto', 'sfruttato', 'sfuggito', 'sfumare', 'sfuso', 'sgabello', 'sgarbato', 'sgonfiare', 'sgorbio', 'sgrassato', 'sguardo', 'sibilo', 'siccome', 'sierra', 'sigla', 'signore', 'silenzio', 'sillaba', 'simbolo', 'simpatico', 'simulato', 'sinfonia', 'singolo', 'sinistro', 'sino', 'sintesi', 'sinusoide', 'sipario', 'sisma', 'sistole', 'situato', 'slitta', 'slogatura', 'sloveno', 'smarrito', 'smemorato', 'smentito', 'smeraldo', 'smilzo', 'smontare', 'smottato', 'smussato', 'snellire', 'snervato', 'snodo', 'sobbalzo', 'sobrio', 'soccorso', 'sociale', 'sodale', 'soffitto', 'sogno', 'soldato', 'solenne', 'solido', 'sollazzo', 'solo', 'solubile', 'solvente', 'somatico', 'somma', 'sonda', 'sonetto', 'sonnifero', 'sopire', 'soppeso', 'sopra', 'sorgere', 'sorpasso', 'sorriso', 'sorso', 'sorteggio', 'sorvolato', 'sospiro', 'sosta', 'sottile', 'spada', 'spalla', 'spargere', 'spatola', 'spavento', 'spazzola', 'specie', 'spedire', 'spegnere', 'spelatura', 'speranza', 'spessore', 'spettrale', 'spezzato', 'spia', 'spigoloso', 'spillato', 'spinoso', 'spirale', 'splendido', 'sportivo', 'sposo', 'spranga', 'sprecare', 'spronato', 'spruzzo', 'spuntino', 'squillo', 'sradicare', 'srotolato', 'stabile', 'stacco', 'staffa', 'stagnare', 'stampato', 'stantio', 'starnuto', 'stasera', 'statuto', 'stelo', 'steppa', 'sterzo', 'stiletto', 'stima', 'stirpe', 'stivale', 'stizzoso', 'stonato', 'storico', 'strappo', 'stregato', 'stridulo', 'strozzare', 'strutto', 'stuccare', 'stufo', 'stupendo', 'subentro', 'succoso', 'sudore', 'suggerito', 'sugo', 'sultano', 'suonare', 'superbo', 'supporto', 'surgelato', 'surrogato', 'sussurro', 'sutura', 'svagare', 'svedese', 'sveglio', 'svelare', 'svenuto', 'svezia', 'sviluppo', 'svista', 'svizzera', 'svolta', 'svuotare', 'tabacco', 'tabulato', 'tacciare', 'taciturno', 'tale', 'talismano', 'tampone', 'tannino', 'tara', 'tardivo', 'targato', 'tariffa', 'tarpare', 'tartaruga', 'tasto', 'tattico', 'taverna', 'tavolata', 'tazza', 'teca', 'tecnico', 'telefono', 'temerario', 'tempo', 'temuto', 'tendone', 'tenero', 'tensione', 'tentacolo', 'teorema', 'terme', 'terrazzo', 'terzetto', 'tesi', 'tesserato', 'testato', 'tetro', 'tettoia', 'tifare', 'tigella', 'timbro', 'tinto', 'tipico', 'tipografo', 'tiraggio', 'tiro', 'titanio', 'titolo', 'titubante', 'tizio', 'tizzone', 'toccare', 'tollerare', 'tolto', 'tombola', 'tomo', 'tonfo', 'tonsilla', 'topazio', 'topologia', 'toppa', 'torba', 'tornare', 'torrone', 'tortora', 'toscano', 'tossire', 'tostatura', 'totano', 'trabocco', 'trachea', 'trafila', 'tragedia', 'tralcio', 'tramonto', 'transito', 'trapano', 'trarre', 'trasloco', 'trattato', 'trave', 'treccia', 'tremolio', 'trespolo', 'tributo', 'tricheco', 'trifoglio', 'trillo', 'trincea', 'trio', 'tristezza', 'triturato', 'trivella', 'tromba', 'trono', 'troppo', 'trottola', 'trovare', 'truccato', 'tubatura', 'tuffato', 'tulipano', 'tumulto', 'tunisia', 'turbare', 'turchino', 'tuta', 'tutela', 'ubicato', 'uccello', 'uccisore', 'udire', 'uditivo', 'uffa', 'ufficio', 'uguale', 'ulisse', 'ultimato', 'umano', 'umile', 'umorismo', 'uncinetto', 'ungere', 'ungherese', 'unicorno', 'unificato', 'unisono', 'unitario', 'unte', 'uovo', 'upupa', 'uragano', 'urgenza', 'urlo', 'usanza', 'usato', 'uscito', 'usignolo', 'usuraio', 'utensile', 'utilizzo', 'utopia', 'vacante', 'vaccinato', 'vagabondo', 'vagliato', 'valanga', 'valgo', 'valico', 'valletta', 'valoroso', 'valutare', 'valvola', 'vampata', 'vangare', 'vanitoso', 'vano', 'vantaggio', 'vanvera', 'vapore', 'varano', 'varcato', 'variante', 'vasca', 'vedetta', 'vedova', 'veduto', 'vegetale', 'veicolo', 'velcro', 'velina', 'velluto', 'veloce', 'venato', 'vendemmia', 'vento', 'verace', 'verbale', 'vergogna', 'verifica', 'vero', 'verruca', 'verticale', 'vescica', 'vessillo', 'vestale', 'veterano', 'vetrina', 'vetusto', 'viandante', 'vibrante', 'vicenda', 'vichingo', 'vicinanza', 'vidimare', 'vigilia', 'vigneto', 'vigore', 'vile', 'villano', 'vimini', 'vincitore', 'viola', 'vipera', 'virgola', 'virologo', 'virulento', 'viscoso', 'visione', 'vispo', 'vissuto', 'visura', 'vita', 'vitello', 'vittima', 'vivanda', 'vivido', 'viziare', 'voce', 'voga', 'volatile', 'volere', 'volpe', 'voragine', 'vulcano', 'zampogna', 'zanna', 'zappato', 'zattera', 'zavorra', 'zefiro', 'zelante', 'zelo', 'zenzero', 'zerbino', 'zibetto', 'zinco', 'zircone', 'zitto', 'zolla', 'zotico', 'zucchero', 'zufolo', 'zulu', 'zuppa'];\nvar JAPANESE = ['あいこくしん', 'あいさつ', 'あいだ', 'あおぞら', 'あかちゃん', 'あきる', 'あけがた', 'あける', 'あこがれる', 'あさい', 'あさひ', 'あしあと', 'あじわう', 'あずかる', 'あずき', 'あそぶ', 'あたえる', 'あたためる', 'あたりまえ', 'あたる', 'あつい', 'あつかう', 'あっしゅく', 'あつまり', 'あつめる', 'あてな', 'あてはまる', 'あひる', 'あぶら', 'あぶる', 'あふれる', 'あまい', 'あまど', 'あまやかす', 'あまり', 'あみもの', 'あめりか', 'あやまる', 'あゆむ', 'あらいぐま', 'あらし', 'あらすじ', 'あらためる', 'あらゆる', 'あらわす', 'ありがとう', 'あわせる', 'あわてる', 'あんい', 'あんがい', 'あんこ', 'あんぜん', 'あんてい', 'あんない', 'あんまり', 'いいだす', 'いおん', 'いがい', 'いがく', 'いきおい', 'いきなり', 'いきもの', 'いきる', 'いくじ', 'いくぶん', 'いけばな', 'いけん', 'いこう', 'いこく', 'いこつ', 'いさましい', 'いさん', 'いしき', 'いじゅう', 'いじょう', 'いじわる', 'いずみ', 'いずれ', 'いせい', 'いせえび', 'いせかい', 'いせき', 'いぜん', 'いそうろう', 'いそがしい', 'いだい', 'いだく', 'いたずら', 'いたみ', 'いたりあ', 'いちおう', 'いちじ', 'いちど', 'いちば', 'いちぶ', 'いちりゅう', 'いつか', 'いっしゅん', 'いっせい', 'いっそう', 'いったん', 'いっち', 'いってい', 'いっぽう', 'いてざ', 'いてん', 'いどう', 'いとこ', 'いない', 'いなか', 'いねむり', 'いのち', 'いのる', 'いはつ', 'いばる', 'いはん', 'いびき', 'いひん', 'いふく', 'いへん', 'いほう', 'いみん', 'いもうと', 'いもたれ', 'いもり', 'いやがる', 'いやす', 'いよかん', 'いよく', 'いらい', 'いらすと', 'いりぐち', 'いりょう', 'いれい', 'いれもの', 'いれる', 'いろえんぴつ', 'いわい', 'いわう', 'いわかん', 'いわば', 'いわゆる', 'いんげんまめ', 'いんさつ', 'いんしょう', 'いんよう', 'うえき', 'うえる', 'うおざ', 'うがい', 'うかぶ', 'うかべる', 'うきわ', 'うくらいな', 'うくれれ', 'うけたまわる', 'うけつけ', 'うけとる', 'うけもつ', 'うける', 'うごかす', 'うごく', 'うこん', 'うさぎ', 'うしなう', 'うしろがみ', 'うすい', 'うすぎ', 'うすぐらい', 'うすめる', 'うせつ', 'うちあわせ', 'うちがわ', 'うちき', 'うちゅう', 'うっかり', 'うつくしい', 'うったえる', 'うつる', 'うどん', 'うなぎ', 'うなじ', 'うなずく', 'うなる', 'うねる', 'うのう', 'うぶげ', 'うぶごえ', 'うまれる', 'うめる', 'うもう', 'うやまう', 'うよく', 'うらがえす', 'うらぐち', 'うらない', 'うりあげ', 'うりきれ', 'うるさい', 'うれしい', 'うれゆき', 'うれる', 'うろこ', 'うわき', 'うわさ', 'うんこう', 'うんちん', 'うんてん', 'うんどう', 'えいえん', 'えいが', 'えいきょう', 'えいご', 'えいせい', 'えいぶん', 'えいよう', 'えいわ', 'えおり', 'えがお', 'えがく', 'えきたい', 'えくせる', 'えしゃく', 'えすて', 'えつらん', 'えのぐ', 'えほうまき', 'えほん', 'えまき', 'えもじ', 'えもの', 'えらい', 'えらぶ', 'えりあ', 'えんえん', 'えんかい', 'えんぎ', 'えんげき', 'えんしゅう', 'えんぜつ', 'えんそく', 'えんちょう', 'えんとつ', 'おいかける', 'おいこす', 'おいしい', 'おいつく', 'おうえん', 'おうさま', 'おうじ', 'おうせつ', 'おうたい', 'おうふく', 'おうべい', 'おうよう', 'おえる', 'おおい', 'おおう', 'おおどおり', 'おおや', 'おおよそ', 'おかえり', 'おかず', 'おがむ', 'おかわり', 'おぎなう', 'おきる', 'おくさま', 'おくじょう', 'おくりがな', 'おくる', 'おくれる', 'おこす', 'おこなう', 'おこる', 'おさえる', 'おさない', 'おさめる', 'おしいれ', 'おしえる', 'おじぎ', 'おじさん', 'おしゃれ', 'おそらく', 'おそわる', 'おたがい', 'おたく', 'おだやか', 'おちつく', 'おっと', 'おつり', 'おでかけ', 'おとしもの', 'おとなしい', 'おどり', 'おどろかす', 'おばさん', 'おまいり', 'おめでとう', 'おもいで', 'おもう', 'おもたい', 'おもちゃ', 'おやつ', 'おやゆび', 'およぼす', 'おらんだ', 'おろす', 'おんがく', 'おんけい', 'おんしゃ', 'おんせん', 'おんだん', 'おんちゅう', 'おんどけい', 'かあつ', 'かいが', 'がいき', 'がいけん', 'がいこう', 'かいさつ', 'かいしゃ', 'かいすいよく', 'かいぜん', 'かいぞうど', 'かいつう', 'かいてん', 'かいとう', 'かいふく', 'がいへき', 'かいほう', 'かいよう', 'がいらい', 'かいわ', 'かえる', 'かおり', 'かかえる', 'かがく', 'かがし', 'かがみ', 'かくご', 'かくとく', 'かざる', 'がぞう', 'かたい', 'かたち', 'がちょう', 'がっきゅう', 'がっこう', 'がっさん', 'がっしょう', 'かなざわし', 'かのう', 'がはく', 'かぶか', 'かほう', 'かほご', 'かまう', 'かまぼこ', 'かめれおん', 'かゆい', 'かようび', 'からい', 'かるい', 'かろう', 'かわく', 'かわら', 'がんか', 'かんけい', 'かんこう', 'かんしゃ', 'かんそう', 'かんたん', 'かんち', 'がんばる', 'きあい', 'きあつ', 'きいろ', 'ぎいん', 'きうい', 'きうん', 'きえる', 'きおう', 'きおく', 'きおち', 'きおん', 'きかい', 'きかく', 'きかんしゃ', 'ききて', 'きくばり', 'きくらげ', 'きけんせい', 'きこう', 'きこえる', 'きこく', 'きさい', 'きさく', 'きさま', 'きさらぎ', 'ぎじかがく', 'ぎしき', 'ぎじたいけん', 'ぎじにってい', 'ぎじゅつしゃ', 'きすう', 'きせい', 'きせき', 'きせつ', 'きそう', 'きぞく', 'きぞん', 'きたえる', 'きちょう', 'きつえん', 'ぎっちり', 'きつつき', 'きつね', 'きてい', 'きどう', 'きどく', 'きない', 'きなが', 'きなこ', 'きぬごし', 'きねん', 'きのう', 'きのした', 'きはく', 'きびしい', 'きひん', 'きふく', 'きぶん', 'きぼう', 'きほん', 'きまる', 'きみつ', 'きむずかしい', 'きめる', 'きもだめし', 'きもち', 'きもの', 'きゃく', 'きやく', 'ぎゅうにく', 'きよう', 'きょうりゅう', 'きらい', 'きらく', 'きりん', 'きれい', 'きれつ', 'きろく', 'ぎろん', 'きわめる', 'ぎんいろ', 'きんかくじ', 'きんじょ', 'きんようび', 'ぐあい', 'くいず', 'くうかん', 'くうき', 'くうぐん', 'くうこう', 'ぐうせい', 'くうそう', 'ぐうたら', 'くうふく', 'くうぼ', 'くかん', 'くきょう', 'くげん', 'ぐこう', 'くさい', 'くさき', 'くさばな', 'くさる', 'くしゃみ', 'くしょう', 'くすのき', 'くすりゆび', 'くせげ', 'くせん', 'ぐたいてき', 'くださる', 'くたびれる', 'くちこみ', 'くちさき', 'くつした', 'ぐっすり', 'くつろぐ', 'くとうてん', 'くどく', 'くなん', 'くねくね', 'くのう', 'くふう', 'くみあわせ', 'くみたてる', 'くめる', 'くやくしょ', 'くらす', 'くらべる', 'くるま', 'くれる', 'くろう', 'くわしい', 'ぐんかん', 'ぐんしょく', 'ぐんたい', 'ぐんて', 'けあな', 'けいかく', 'けいけん', 'けいこ', 'けいさつ', 'げいじゅつ', 'けいたい', 'げいのうじん', 'けいれき', 'けいろ', 'けおとす', 'けおりもの', 'げきか', 'げきげん', 'げきだん', 'げきちん', 'げきとつ', 'げきは', 'げきやく', 'げこう', 'げこくじょう', 'げざい', 'けさき', 'げざん', 'けしき', 'けしごむ', 'けしょう', 'げすと', 'けたば', 'けちゃっぷ', 'けちらす', 'けつあつ', 'けつい', 'けつえき', 'けっこん', 'けつじょ', 'けっせき', 'けってい', 'けつまつ', 'げつようび', 'げつれい', 'けつろん', 'げどく', 'けとばす', 'けとる', 'けなげ', 'けなす', 'けなみ', 'けぬき', 'げねつ', 'けねん', 'けはい', 'げひん', 'けぶかい', 'げぼく', 'けまり', 'けみかる', 'けむし', 'けむり', 'けもの', 'けらい', 'けろけろ', 'けわしい', 'けんい', 'けんえつ', 'けんお', 'けんか', 'げんき', 'けんげん', 'けんこう', 'けんさく', 'けんしゅう', 'けんすう', 'げんそう', 'けんちく', 'けんてい', 'けんとう', 'けんない', 'けんにん', 'げんぶつ', 'けんま', 'けんみん', 'けんめい', 'けんらん', 'けんり', 'こあくま', 'こいぬ', 'こいびと', 'ごうい', 'こうえん', 'こうおん', 'こうかん', 'ごうきゅう', 'ごうけい', 'こうこう', 'こうさい', 'こうじ', 'こうすい', 'ごうせい', 'こうそく', 'こうたい', 'こうちゃ', 'こうつう', 'こうてい', 'こうどう', 'こうない', 'こうはい', 'ごうほう', 'ごうまん', 'こうもく', 'こうりつ', 'こえる', 'こおり', 'ごかい', 'ごがつ', 'ごかん', 'こくご', 'こくさい', 'こくとう', 'こくない', 'こくはく', 'こぐま', 'こけい', 'こける', 'ここのか', 'こころ', 'こさめ', 'こしつ', 'こすう', 'こせい', 'こせき', 'こぜん', 'こそだて', 'こたい', 'こたえる', 'こたつ', 'こちょう', 'こっか', 'こつこつ', 'こつばん', 'こつぶ', 'こてい', 'こてん', 'ことがら', 'ことし', 'ことば', 'ことり', 'こなごな', 'こねこね', 'このまま', 'このみ', 'このよ', 'ごはん', 'こひつじ', 'こふう', 'こふん', 'こぼれる', 'ごまあぶら', 'こまかい', 'ごますり', 'こまつな', 'こまる', 'こむぎこ', 'こもじ', 'こもち', 'こもの', 'こもん', 'こやく', 'こやま', 'こゆう', 'こゆび', 'こよい', 'こよう', 'こりる', 'これくしょん', 'ころっけ', 'こわもて', 'こわれる', 'こんいん', 'こんかい', 'こんき', 'こんしゅう', 'こんすい', 'こんだて', 'こんとん', 'こんなん', 'こんびに', 'こんぽん', 'こんまけ', 'こんや', 'こんれい', 'こんわく', 'ざいえき', 'さいかい', 'さいきん', 'ざいげん', 'ざいこ', 'さいしょ', 'さいせい', 'ざいたく', 'ざいちゅう', 'さいてき', 'ざいりょう', 'さうな', 'さかいし', 'さがす', 'さかな', 'さかみち', 'さがる', 'さぎょう', 'さくし', 'さくひん', 'さくら', 'さこく', 'さこつ', 'さずかる', 'ざせき', 'さたん', 'さつえい', 'ざつおん', 'ざっか', 'ざつがく', 'さっきょく', 'ざっし', 'さつじん', 'ざっそう', 'さつたば', 'さつまいも', 'さてい', 'さといも', 'さとう', 'さとおや', 'さとし', 'さとる', 'さのう', 'さばく', 'さびしい', 'さべつ', 'さほう', 'さほど', 'さます', 'さみしい', 'さみだれ', 'さむけ', 'さめる', 'さやえんどう', 'さゆう', 'さよう', 'さよく', 'さらだ', 'ざるそば', 'さわやか', 'さわる', 'さんいん', 'さんか', 'さんきゃく', 'さんこう', 'さんさい', 'ざんしょ', 'さんすう', 'さんせい', 'さんそ', 'さんち', 'さんま', 'さんみ', 'さんらん', 'しあい', 'しあげ', 'しあさって', 'しあわせ', 'しいく', 'しいん', 'しうち', 'しえい', 'しおけ', 'しかい', 'しかく', 'じかん', 'しごと', 'しすう', 'じだい', 'したうけ', 'したぎ', 'したて', 'したみ', 'しちょう', 'しちりん', 'しっかり', 'しつじ', 'しつもん', 'してい', 'してき', 'してつ', 'じてん', 'じどう', 'しなぎれ', 'しなもの', 'しなん', 'しねま', 'しねん', 'しのぐ', 'しのぶ', 'しはい', 'しばかり', 'しはつ', 'しはらい', 'しはん', 'しひょう', 'しふく', 'じぶん', 'しへい', 'しほう', 'しほん', 'しまう', 'しまる', 'しみん', 'しむける', 'じむしょ', 'しめい', 'しめる', 'しもん', 'しゃいん', 'しゃうん', 'しゃおん', 'じゃがいも', 'しやくしょ', 'しゃくほう', 'しゃけん', 'しゃこ', 'しゃざい', 'しゃしん', 'しゃせん', 'しゃそう', 'しゃたい', 'しゃちょう', 'しゃっきん', 'じゃま', 'しゃりん', 'しゃれい', 'じゆう', 'じゅうしょ', 'しゅくはく', 'じゅしん', 'しゅっせき', 'しゅみ', 'しゅらば', 'じゅんばん', 'しょうかい', 'しょくたく', 'しょっけん', 'しょどう', 'しょもつ', 'しらせる', 'しらべる', 'しんか', 'しんこう', 'じんじゃ', 'しんせいじ', 'しんちく', 'しんりん', 'すあげ', 'すあし', 'すあな', 'ずあん', 'すいえい', 'すいか', 'すいとう', 'ずいぶん', 'すいようび', 'すうがく', 'すうじつ', 'すうせん', 'すおどり', 'すきま', 'すくう', 'すくない', 'すける', 'すごい', 'すこし', 'ずさん', 'すずしい', 'すすむ', 'すすめる', 'すっかり', 'ずっしり', 'ずっと', 'すてき', 'すてる', 'すねる', 'すのこ', 'すはだ', 'すばらしい', 'ずひょう', 'ずぶぬれ', 'すぶり', 'すふれ', 'すべて', 'すべる', 'ずほう', 'すぼん', 'すまい', 'すめし', 'すもう', 'すやき', 'すらすら', 'するめ', 'すれちがう', 'すろっと', 'すわる', 'すんぜん', 'すんぽう', 'せあぶら', 'せいかつ', 'せいげん', 'せいじ', 'せいよう', 'せおう', 'せかいかん', 'せきにん', 'せきむ', 'せきゆ', 'せきらんうん', 'せけん', 'せこう', 'せすじ', 'せたい', 'せたけ', 'せっかく', 'せっきゃく', 'ぜっく', 'せっけん', 'せっこつ', 'せっさたくま', 'せつぞく', 'せつだん', 'せつでん', 'せっぱん', 'せつび', 'せつぶん', 'せつめい', 'せつりつ', 'せなか', 'せのび', 'せはば', 'せびろ', 'せぼね', 'せまい', 'せまる', 'せめる', 'せもたれ', 'せりふ', 'ぜんあく', 'せんい', 'せんえい', 'せんか', 'せんきょ', 'せんく', 'せんげん', 'ぜんご', 'せんさい', 'せんしゅ', 'せんすい', 'せんせい', 'せんぞ', 'せんたく', 'せんちょう', 'せんてい', 'せんとう', 'せんぬき', 'せんねん', 'せんぱい', 'ぜんぶ', 'ぜんぽう', 'せんむ', 'せんめんじょ', 'せんもん', 'せんやく', 'せんゆう', 'せんよう', 'ぜんら', 'ぜんりゃく', 'せんれい', 'せんろ', 'そあく', 'そいとげる', 'そいね', 'そうがんきょう', 'そうき', 'そうご', 'そうしん', 'そうだん', 'そうなん', 'そうび', 'そうめん', 'そうり', 'そえもの', 'そえん', 'そがい', 'そげき', 'そこう', 'そこそこ', 'そざい', 'そしな', 'そせい', 'そせん', 'そそぐ', 'そだてる', 'そつう', 'そつえん', 'そっかん', 'そつぎょう', 'そっけつ', 'そっこう', 'そっせん', 'そっと', 'そとがわ', 'そとづら', 'そなえる', 'そなた', 'そふぼ', 'そぼく', 'そぼろ', 'そまつ', 'そまる', 'そむく', 'そむりえ', 'そめる', 'そもそも', 'そよかぜ', 'そらまめ', 'そろう', 'そんかい', 'そんけい', 'そんざい', 'そんしつ', 'そんぞく', 'そんちょう', 'ぞんび', 'ぞんぶん', 'そんみん', 'たあい', 'たいいん', 'たいうん', 'たいえき', 'たいおう', 'だいがく', 'たいき', 'たいぐう', 'たいけん', 'たいこ', 'たいざい', 'だいじょうぶ', 'だいすき', 'たいせつ', 'たいそう', 'だいたい', 'たいちょう', 'たいてい', 'だいどころ', 'たいない', 'たいねつ', 'たいのう', 'たいはん', 'だいひょう', 'たいふう', 'たいへん', 'たいほ', 'たいまつばな', 'たいみんぐ', 'たいむ', 'たいめん', 'たいやき', 'たいよう', 'たいら', 'たいりょく', 'たいる', 'たいわん', 'たうえ', 'たえる', 'たおす', 'たおる', 'たおれる', 'たかい', 'たかね', 'たきび', 'たくさん', 'たこく', 'たこやき', 'たさい', 'たしざん', 'だじゃれ', 'たすける', 'たずさわる', 'たそがれ', 'たたかう', 'たたく', 'ただしい', 'たたみ', 'たちばな', 'だっかい', 'だっきゃく', 'だっこ', 'だっしゅつ', 'だったい', 'たてる', 'たとえる', 'たなばた', 'たにん', 'たぬき', 'たのしみ', 'たはつ', 'たぶん', 'たべる', 'たぼう', 'たまご', 'たまる', 'だむる', 'ためいき', 'ためす', 'ためる', 'たもつ', 'たやすい', 'たよる', 'たらす', 'たりきほんがん', 'たりょう', 'たりる', 'たると', 'たれる', 'たれんと', 'たろっと', 'たわむれる', 'だんあつ', 'たんい', 'たんおん', 'たんか', 'たんき', 'たんけん', 'たんご', 'たんさん', 'たんじょうび', 'だんせい', 'たんそく', 'たんたい', 'だんち', 'たんてい', 'たんとう', 'だんな', 'たんにん', 'だんねつ', 'たんのう', 'たんぴん', 'だんぼう', 'たんまつ', 'たんめい', 'だんれつ', 'だんろ', 'だんわ', 'ちあい', 'ちあん', 'ちいき', 'ちいさい', 'ちえん', 'ちかい', 'ちから', 'ちきゅう', 'ちきん', 'ちけいず', 'ちけん', 'ちこく', 'ちさい', 'ちしき', 'ちしりょう', 'ちせい', 'ちそう', 'ちたい', 'ちたん', 'ちちおや', 'ちつじょ', 'ちてき', 'ちてん', 'ちぬき', 'ちぬり', 'ちのう', 'ちひょう', 'ちへいせん', 'ちほう', 'ちまた', 'ちみつ', 'ちみどろ', 'ちめいど', 'ちゃんこなべ', 'ちゅうい', 'ちゆりょく', 'ちょうし', 'ちょさくけん', 'ちらし', 'ちらみ', 'ちりがみ', 'ちりょう', 'ちるど', 'ちわわ', 'ちんたい', 'ちんもく', 'ついか', 'ついたち', 'つうか', 'つうじょう', 'つうはん', 'つうわ', 'つかう', 'つかれる', 'つくね', 'つくる', 'つけね', 'つける', 'つごう', 'つたえる', 'つづく', 'つつじ', 'つつむ', 'つとめる', 'つながる', 'つなみ', 'つねづね', 'つのる', 'つぶす', 'つまらない', 'つまる', 'つみき', 'つめたい', 'つもり', 'つもる', 'つよい', 'つるぼ', 'つるみく', 'つわもの', 'つわり', 'てあし', 'てあて', 'てあみ', 'ていおん', 'ていか', 'ていき', 'ていけい', 'ていこく', 'ていさつ', 'ていし', 'ていせい', 'ていたい', 'ていど', 'ていねい', 'ていひょう', 'ていへん', 'ていぼう', 'てうち', 'ておくれ', 'てきとう', 'てくび', 'でこぼこ', 'てさぎょう', 'てさげ', 'てすり', 'てそう', 'てちがい', 'てちょう', 'てつがく', 'てつづき', 'でっぱ', 'てつぼう', 'てつや', 'でぬかえ', 'てぬき', 'てぬぐい', 'てのひら', 'てはい', 'てぶくろ', 'てふだ', 'てほどき', 'てほん', 'てまえ', 'てまきずし', 'てみじか', 'てみやげ', 'てらす', 'てれび', 'てわけ', 'てわたし', 'でんあつ', 'てんいん', 'てんかい', 'てんき', 'てんぐ', 'てんけん', 'てんごく', 'てんさい', 'てんし', 'てんすう', 'でんち', 'てんてき', 'てんとう', 'てんない', 'てんぷら', 'てんぼうだい', 'てんめつ', 'てんらんかい', 'でんりょく', 'でんわ', 'どあい', 'といれ', 'どうかん', 'とうきゅう', 'どうぐ', 'とうし', 'とうむぎ', 'とおい', 'とおか', 'とおく', 'とおす', 'とおる', 'とかい', 'とかす', 'ときおり', 'ときどき', 'とくい', 'とくしゅう', 'とくてん', 'とくに', 'とくべつ', 'とけい', 'とける', 'とこや', 'とさか', 'としょかん', 'とそう', 'とたん', 'とちゅう', 'とっきゅう', 'とっくん', 'とつぜん', 'とつにゅう', 'とどける', 'ととのえる', 'とない', 'となえる', 'となり', 'とのさま', 'とばす', 'どぶがわ', 'とほう', 'とまる', 'とめる', 'ともだち', 'ともる', 'どようび', 'とらえる', 'とんかつ', 'どんぶり', 'ないかく', 'ないこう', 'ないしょ', 'ないす', 'ないせん', 'ないそう', 'なおす', 'ながい', 'なくす', 'なげる', 'なこうど', 'なさけ', 'なたでここ', 'なっとう', 'なつやすみ', 'ななおし', 'なにごと', 'なにもの', 'なにわ', 'なのか', 'なふだ', 'なまいき', 'なまえ', 'なまみ', 'なみだ', 'なめらか', 'なめる', 'なやむ', 'ならう', 'ならび', 'ならぶ', 'なれる', 'なわとび', 'なわばり', 'にあう', 'にいがた', 'にうけ', 'におい', 'にかい', 'にがて', 'にきび', 'にくしみ', 'にくまん', 'にげる', 'にさんかたんそ', 'にしき', 'にせもの', 'にちじょう', 'にちようび', 'にっか', 'にっき', 'にっけい', 'にっこう', 'にっさん', 'にっしょく', 'にっすう', 'にっせき', 'にってい', 'になう', 'にほん', 'にまめ', 'にもつ', 'にやり', 'にゅういん', 'にりんしゃ', 'にわとり', 'にんい', 'にんか', 'にんき', 'にんげん', 'にんしき', 'にんずう', 'にんそう', 'にんたい', 'にんち', 'にんてい', 'にんにく', 'にんぷ', 'にんまり', 'にんむ', 'にんめい', 'にんよう', 'ぬいくぎ', 'ぬかす', 'ぬぐいとる', 'ぬぐう', 'ぬくもり', 'ぬすむ', 'ぬまえび', 'ぬめり', 'ぬらす', 'ぬんちゃく', 'ねあげ', 'ねいき', 'ねいる', 'ねいろ', 'ねぐせ', 'ねくたい', 'ねくら', 'ねこぜ', 'ねこむ', 'ねさげ', 'ねすごす', 'ねそべる', 'ねだん', 'ねつい', 'ねっしん', 'ねつぞう', 'ねったいぎょ', 'ねぶそく', 'ねふだ', 'ねぼう', 'ねほりはほり', 'ねまき', 'ねまわし', 'ねみみ', 'ねむい', 'ねむたい', 'ねもと', 'ねらう', 'ねわざ', 'ねんいり', 'ねんおし', 'ねんかん', 'ねんきん', 'ねんぐ', 'ねんざ', 'ねんし', 'ねんちゃく', 'ねんど', 'ねんぴ', 'ねんぶつ', 'ねんまつ', 'ねんりょう', 'ねんれい', 'のいず', 'のおづま', 'のがす', 'のきなみ', 'のこぎり', 'のこす', 'のこる', 'のせる', 'のぞく', 'のぞむ', 'のたまう', 'のちほど', 'のっく', 'のばす', 'のはら', 'のべる', 'のぼる', 'のみもの', 'のやま', 'のらいぬ', 'のらねこ', 'のりもの', 'のりゆき', 'のれん', 'のんき', 'ばあい', 'はあく', 'ばあさん', 'ばいか', 'ばいく', 'はいけん', 'はいご', 'はいしん', 'はいすい', 'はいせん', 'はいそう', 'はいち', 'ばいばい', 'はいれつ', 'はえる', 'はおる', 'はかい', 'ばかり', 'はかる', 'はくしゅ', 'はけん', 'はこぶ', 'はさみ', 'はさん', 'はしご', 'ばしょ', 'はしる', 'はせる', 'ぱそこん', 'はそん', 'はたん', 'はちみつ', 'はつおん', 'はっかく', 'はづき', 'はっきり', 'はっくつ', 'はっけん', 'はっこう', 'はっさん', 'はっしん', 'はったつ', 'はっちゅう', 'はってん', 'はっぴょう', 'はっぽう', 'はなす', 'はなび', 'はにかむ', 'はぶらし', 'はみがき', 'はむかう', 'はめつ', 'はやい', 'はやし', 'はらう', 'はろうぃん', 'はわい', 'はんい', 'はんえい', 'はんおん', 'はんかく', 'はんきょう', 'ばんぐみ', 'はんこ', 'はんしゃ', 'はんすう', 'はんだん', 'ぱんち', 'ぱんつ', 'はんてい', 'はんとし', 'はんのう', 'はんぱ', 'はんぶん', 'はんぺん', 'はんぼうき', 'はんめい', 'はんらん', 'はんろん', 'ひいき', 'ひうん', 'ひえる', 'ひかく', 'ひかり', 'ひかる', 'ひかん', 'ひくい', 'ひけつ', 'ひこうき', 'ひこく', 'ひさい', 'ひさしぶり', 'ひさん', 'びじゅつかん', 'ひしょ', 'ひそか', 'ひそむ', 'ひたむき', 'ひだり', 'ひたる', 'ひつぎ', 'ひっこし', 'ひっし', 'ひつじゅひん', 'ひっす', 'ひつぜん', 'ぴったり', 'ぴっちり', 'ひつよう', 'ひてい', 'ひとごみ', 'ひなまつり', 'ひなん', 'ひねる', 'ひはん', 'ひびく', 'ひひょう', 'ひほう', 'ひまわり', 'ひまん', 'ひみつ', 'ひめい', 'ひめじし', 'ひやけ', 'ひやす', 'ひよう', 'びょうき', 'ひらがな', 'ひらく', 'ひりつ', 'ひりょう', 'ひるま', 'ひるやすみ', 'ひれい', 'ひろい', 'ひろう', 'ひろき', 'ひろゆき', 'ひんかく', 'ひんけつ', 'ひんこん', 'ひんしゅ', 'ひんそう', 'ぴんち', 'ひんぱん', 'びんぼう', 'ふあん', 'ふいうち', 'ふうけい', 'ふうせん', 'ぷうたろう', 'ふうとう', 'ふうふ', 'ふえる', 'ふおん', 'ふかい', 'ふきん', 'ふくざつ', 'ふくぶくろ', 'ふこう', 'ふさい', 'ふしぎ', 'ふじみ', 'ふすま', 'ふせい', 'ふせぐ', 'ふそく', 'ぶたにく', 'ふたん', 'ふちょう', 'ふつう', 'ふつか', 'ふっかつ', 'ふっき', 'ふっこく', 'ぶどう', 'ふとる', 'ふとん', 'ふのう', 'ふはい', 'ふひょう', 'ふへん', 'ふまん', 'ふみん', 'ふめつ', 'ふめん', 'ふよう', 'ふりこ', 'ふりる', 'ふるい', 'ふんいき', 'ぶんがく', 'ぶんぐ', 'ふんしつ', 'ぶんせき', 'ふんそう', 'ぶんぽう', 'へいあん', 'へいおん', 'へいがい', 'へいき', 'へいげん', 'へいこう', 'へいさ', 'へいしゃ', 'へいせつ', 'へいそ', 'へいたく', 'へいてん', 'へいねつ', 'へいわ', 'へきが', 'へこむ', 'べにいろ', 'べにしょうが', 'へらす', 'へんかん', 'べんきょう', 'べんごし', 'へんさい', 'へんたい', 'べんり', 'ほあん', 'ほいく', 'ぼうぎょ', 'ほうこく', 'ほうそう', 'ほうほう', 'ほうもん', 'ほうりつ', 'ほえる', 'ほおん', 'ほかん', 'ほきょう', 'ぼきん', 'ほくろ', 'ほけつ', 'ほけん', 'ほこう', 'ほこる', 'ほしい', 'ほしつ', 'ほしゅ', 'ほしょう', 'ほせい', 'ほそい', 'ほそく', 'ほたて', 'ほたる', 'ぽちぶくろ', 'ほっきょく', 'ほっさ', 'ほったん', 'ほとんど', 'ほめる', 'ほんい', 'ほんき', 'ほんけ', 'ほんしつ', 'ほんやく', 'まいにち', 'まかい', 'まかせる', 'まがる', 'まける', 'まこと', 'まさつ', 'まじめ', 'ますく', 'まぜる', 'まつり', 'まとめ', 'まなぶ', 'まぬけ', 'まねく', 'まほう', 'まもる', 'まゆげ', 'まよう', 'まろやか', 'まわす', 'まわり', 'まわる', 'まんが', 'まんきつ', 'まんぞく', 'まんなか', 'みいら', 'みうち', 'みえる', 'みがく', 'みかた', 'みかん', 'みけん', 'みこん', 'みじかい', 'みすい', 'みすえる', 'みせる', 'みっか', 'みつかる', 'みつける', 'みてい', 'みとめる', 'みなと', 'みなみかさい', 'みねらる', 'みのう', 'みのがす', 'みほん', 'みもと', 'みやげ', 'みらい', 'みりょく', 'みわく', 'みんか', 'みんぞく', 'むいか', 'むえき', 'むえん', 'むかい', 'むかう', 'むかえ', 'むかし', 'むぎちゃ', 'むける', 'むげん', 'むさぼる', 'むしあつい', 'むしば', 'むじゅん', 'むしろ', 'むすう', 'むすこ', 'むすぶ', 'むすめ', 'むせる', 'むせん', 'むちゅう', 'むなしい', 'むのう', 'むやみ', 'むよう', 'むらさき', 'むりょう', 'むろん', 'めいあん', 'めいうん', 'めいえん', 'めいかく', 'めいきょく', 'めいさい', 'めいし', 'めいそう', 'めいぶつ', 'めいれい', 'めいわく', 'めぐまれる', 'めざす', 'めした', 'めずらしい', 'めだつ', 'めまい', 'めやす', 'めんきょ', 'めんせき', 'めんどう', 'もうしあげる', 'もうどうけん', 'もえる', 'もくし', 'もくてき', 'もくようび', 'もちろん', 'もどる', 'もらう', 'もんく', 'もんだい', 'やおや', 'やける', 'やさい', 'やさしい', 'やすい', 'やすたろう', 'やすみ', 'やせる', 'やそう', 'やたい', 'やちん', 'やっと', 'やっぱり', 'やぶる', 'やめる', 'ややこしい', 'やよい', 'やわらかい', 'ゆうき', 'ゆうびんきょく', 'ゆうべ', 'ゆうめい', 'ゆけつ', 'ゆしゅつ', 'ゆせん', 'ゆそう', 'ゆたか', 'ゆちゃく', 'ゆでる', 'ゆにゅう', 'ゆびわ', 'ゆらい', 'ゆれる', 'ようい', 'ようか', 'ようきゅう', 'ようじ', 'ようす', 'ようちえん', 'よかぜ', 'よかん', 'よきん', 'よくせい', 'よくぼう', 'よけい', 'よごれる', 'よさん', 'よしゅう', 'よそう', 'よそく', 'よっか', 'よてい', 'よどがわく', 'よねつ', 'よやく', 'よゆう', 'よろこぶ', 'よろしい', 'らいう', 'らくがき', 'らくご', 'らくさつ', 'らくだ', 'らしんばん', 'らせん', 'らぞく', 'らたい', 'らっか', 'られつ', 'りえき', 'りかい', 'りきさく', 'りきせつ', 'りくぐん', 'りくつ', 'りけん', 'りこう', 'りせい', 'りそう', 'りそく', 'りてん', 'りねん', 'りゆう', 'りゅうがく', 'りよう', 'りょうり', 'りょかん', 'りょくちゃ', 'りょこう', 'りりく', 'りれき', 'りろん', 'りんご', 'るいけい', 'るいさい', 'るいじ', 'るいせき', 'るすばん', 'るりがわら', 'れいかん', 'れいぎ', 'れいせい', 'れいぞうこ', 'れいとう', 'れいぼう', 'れきし', 'れきだい', 'れんあい', 'れんけい', 'れんこん', 'れんさい', 'れんしゅう', 'れんぞく', 'れんらく', 'ろうか', 'ろうご', 'ろうじん', 'ろうそく', 'ろくが', 'ろこつ', 'ろじうら', 'ろしゅつ', 'ろせん', 'ろてん', 'ろめん', 'ろれつ', 'ろんぎ', 'ろんぱ', 'ろんぶん', 'ろんり', 'わかす', 'わかめ', 'わかやま', 'わかれる', 'わしつ', 'わじまし', 'わすれもの', 'わらう', 'われる'];\nvar SPANISH = ['ábaco', 'abdomen', 'abeja', 'abierto', 'abogado', 'abono', 'aborto', 'abrazo', 'abrir', 'abuelo', 'abuso', 'acabar', 'academia', 'acceso', 'acción', 'aceite', 'acelga', 'acento', 'aceptar', 'ácido', 'aclarar', 'acné', 'acoger', 'acoso', 'activo', 'acto', 'actriz', 'actuar', 'acudir', 'acuerdo', 'acusar', 'adicto', 'admitir', 'adoptar', 'adorno', 'aduana', 'adulto', 'aéreo', 'afectar', 'afición', 'afinar', 'afirmar', 'ágil', 'agitar', 'agonía', 'agosto', 'agotar', 'agregar', 'agrio', 'agua', 'agudo', 'águila', 'aguja', 'ahogo', 'ahorro', 'aire', 'aislar', 'ajedrez', 'ajeno', 'ajuste', 'alacrán', 'alambre', 'alarma', 'alba', 'álbum', 'alcalde', 'aldea', 'alegre', 'alejar', 'alerta', 'aleta', 'alfiler', 'alga', 'algodón', 'aliado', 'aliento', 'alivio', 'alma', 'almeja', 'almíbar', 'altar', 'alteza', 'altivo', 'alto', 'altura', 'alumno', 'alzar', 'amable', 'amante', 'amapola', 'amargo', 'amasar', 'ámbar', 'ámbito', 'ameno', 'amigo', 'amistad', 'amor', 'amparo', 'amplio', 'ancho', 'anciano', 'ancla', 'andar', 'andén', 'anemia', 'ángulo', 'anillo', 'ánimo', 'anís', 'anotar', 'antena', 'antiguo', 'antojo', 'anual', 'anular', 'anuncio', 'añadir', 'añejo', 'año', 'apagar', 'aparato', 'apetito', 'apio', 'aplicar', 'apodo', 'aporte', 'apoyo', 'aprender', 'aprobar', 'apuesta', 'apuro', 'arado', 'araña', 'arar', 'árbitro', 'árbol', 'arbusto', 'archivo', 'arco', 'arder', 'ardilla', 'arduo', 'área', 'árido', 'aries', 'armonía', 'arnés', 'aroma', 'arpa', 'arpón', 'arreglo', 'arroz', 'arruga', 'arte', 'artista', 'asa', 'asado', 'asalto', 'ascenso', 'asegurar', 'aseo', 'asesor', 'asiento', 'asilo', 'asistir', 'asno', 'asombro', 'áspero', 'astilla', 'astro', 'astuto', 'asumir', 'asunto', 'atajo', 'ataque', 'atar', 'atento', 'ateo', 'ático', 'atleta', 'átomo', 'atraer', 'atroz', 'atún', 'audaz', 'audio', 'auge', 'aula', 'aumento', 'ausente', 'autor', 'aval', 'avance', 'avaro', 'ave', 'avellana', 'avena', 'avestruz', 'avión', 'aviso', 'ayer', 'ayuda', 'ayuno', 'azafrán', 'azar', 'azote', 'azúcar', 'azufre', 'azul', 'baba', 'babor', 'bache', 'bahía', 'baile', 'bajar', 'balanza', 'balcón', 'balde', 'bambú', 'banco', 'banda', 'baño', 'barba', 'barco', 'barniz', 'barro', 'báscula', 'bastón', 'basura', 'batalla', 'batería', 'batir', 'batuta', 'baúl', 'bazar', 'bebé', 'bebida', 'bello', 'besar', 'beso', 'bestia', 'bicho', 'bien', 'bingo', 'blanco', 'bloque', 'blusa', 'boa', 'bobina', 'bobo', 'boca', 'bocina', 'boda', 'bodega', 'boina', 'bola', 'bolero', 'bolsa', 'bomba', 'bondad', 'bonito', 'bono', 'bonsái', 'borde', 'borrar', 'bosque', 'bote', 'botín', 'bóveda', 'bozal', 'bravo', 'brazo', 'brecha', 'breve', 'brillo', 'brinco', 'brisa', 'broca', 'broma', 'bronce', 'brote', 'bruja', 'brusco', 'bruto', 'buceo', 'bucle', 'bueno', 'buey', 'bufanda', 'bufón', 'búho', 'buitre', 'bulto', 'burbuja', 'burla', 'burro', 'buscar', 'butaca', 'buzón', 'caballo', 'cabeza', 'cabina', 'cabra', 'cacao', 'cadáver', 'cadena', 'caer', 'café', 'caída', 'caimán', 'caja', 'cajón', 'cal', 'calamar', 'calcio', 'caldo', 'calidad', 'calle', 'calma', 'calor', 'calvo', 'cama', 'cambio', 'camello', 'camino', 'campo', 'cáncer', 'candil', 'canela', 'canguro', 'canica', 'canto', 'caña', 'cañón', 'caoba', 'caos', 'capaz', 'capitán', 'capote', 'captar', 'capucha', 'cara', 'carbón', 'cárcel', 'careta', 'carga', 'cariño', 'carne', 'carpeta', 'carro', 'carta', 'casa', 'casco', 'casero', 'caspa', 'castor', 'catorce', 'catre', 'caudal', 'causa', 'cazo', 'cebolla', 'ceder', 'cedro', 'celda', 'célebre', 'celoso', 'célula', 'cemento', 'ceniza', 'centro', 'cerca', 'cerdo', 'cereza', 'cero', 'cerrar', 'certeza', 'césped', 'cetro', 'chacal', 'chaleco', 'champú', 'chancla', 'chapa', 'charla', 'chico', 'chiste', 'chivo', 'choque', 'choza', 'chuleta', 'chupar', 'ciclón', 'ciego', 'cielo', 'cien', 'cierto', 'cifra', 'cigarro', 'cima', 'cinco', 'cine', 'cinta', 'ciprés', 'circo', 'ciruela', 'cisne', 'cita', 'ciudad', 'clamor', 'clan', 'claro', 'clase', 'clave', 'cliente', 'clima', 'clínica', 'cobre', 'cocción', 'cochino', 'cocina', 'coco', 'código', 'codo', 'cofre', 'coger', 'cohete', 'cojín', 'cojo', 'cola', 'colcha', 'colegio', 'colgar', 'colina', 'collar', 'colmo', 'columna', 'combate', 'comer', 'comida', 'cómodo', 'compra', 'conde', 'conejo', 'conga', 'conocer', 'consejo', 'contar', 'copa', 'copia', 'corazón', 'corbata', 'corcho', 'cordón', 'corona', 'correr', 'coser', 'cosmos', 'costa', 'cráneo', 'cráter', 'crear', 'crecer', 'creído', 'crema', 'cría', 'crimen', 'cripta', 'crisis', 'cromo', 'crónica', 'croqueta', 'crudo', 'cruz', 'cuadro', 'cuarto', 'cuatro', 'cubo', 'cubrir', 'cuchara', 'cuello', 'cuento', 'cuerda', 'cuesta', 'cueva', 'cuidar', 'culebra', 'culpa', 'culto', 'cumbre', 'cumplir', 'cuna', 'cuneta', 'cuota', 'cupón', 'cúpula', 'curar', 'curioso', 'curso', 'curva', 'cutis', 'dama', 'danza', 'dar', 'dardo', 'dátil', 'deber', 'débil', 'década', 'decir', 'dedo', 'defensa', 'definir', 'dejar', 'delfín', 'delgado', 'delito', 'demora', 'denso', 'dental', 'deporte', 'derecho', 'derrota', 'desayuno', 'deseo', 'desfile', 'desnudo', 'destino', 'desvío', 'detalle', 'detener', 'deuda', 'día', 'diablo', 'diadema', 'diamante', 'diana', 'diario', 'dibujo', 'dictar', 'diente', 'dieta', 'diez', 'difícil', 'digno', 'dilema', 'diluir', 'dinero', 'directo', 'dirigir', 'disco', 'diseño', 'disfraz', 'diva', 'divino', 'doble', 'doce', 'dolor', 'domingo', 'don', 'donar', 'dorado', 'dormir', 'dorso', 'dos', 'dosis', 'dragón', 'droga', 'ducha', 'duda', 'duelo', 'dueño', 'dulce', 'dúo', 'duque', 'durar', 'dureza', 'duro', 'ébano', 'ebrio', 'echar', 'eco', 'ecuador', 'edad', 'edición', 'edificio', 'editor', 'educar', 'efecto', 'eficaz', 'eje', 'ejemplo', 'elefante', 'elegir', 'elemento', 'elevar', 'elipse', 'élite', 'elixir', 'elogio', 'eludir', 'embudo', 'emitir', 'emoción', 'empate', 'empeño', 'empleo', 'empresa', 'enano', 'encargo', 'enchufe', 'encía', 'enemigo', 'enero', 'enfado', 'enfermo', 'engaño', 'enigma', 'enlace', 'enorme', 'enredo', 'ensayo', 'enseñar', 'entero', 'entrar', 'envase', 'envío', 'época', 'equipo', 'erizo', 'escala', 'escena', 'escolar', 'escribir', 'escudo', 'esencia', 'esfera', 'esfuerzo', 'espada', 'espejo', 'espía', 'esposa', 'espuma', 'esquí', 'estar', 'este', 'estilo', 'estufa', 'etapa', 'eterno', 'ética', 'etnia', 'evadir', 'evaluar', 'evento', 'evitar', 'exacto', 'examen', 'exceso', 'excusa', 'exento', 'exigir', 'exilio', 'existir', 'éxito', 'experto', 'explicar', 'exponer', 'extremo', 'fábrica', 'fábula', 'fachada', 'fácil', 'factor', 'faena', 'faja', 'falda', 'fallo', 'falso', 'faltar', 'fama', 'familia', 'famoso', 'faraón', 'farmacia', 'farol', 'farsa', 'fase', 'fatiga', 'fauna', 'favor', 'fax', 'febrero', 'fecha', 'feliz', 'feo', 'feria', 'feroz', 'fértil', 'fervor', 'festín', 'fiable', 'fianza', 'fiar', 'fibra', 'ficción', 'ficha', 'fideo', 'fiebre', 'fiel', 'fiera', 'fiesta', 'figura', 'fijar', 'fijo', 'fila', 'filete', 'filial', 'filtro', 'fin', 'finca', 'fingir', 'finito', 'firma', 'flaco', 'flauta', 'flecha', 'flor', 'flota', 'fluir', 'flujo', 'flúor', 'fobia', 'foca', 'fogata', 'fogón', 'folio', 'folleto', 'fondo', 'forma', 'forro', 'fortuna', 'forzar', 'fosa', 'foto', 'fracaso', 'frágil', 'franja', 'frase', 'fraude', 'freír', 'freno', 'fresa', 'frío', 'frito', 'fruta', 'fuego', 'fuente', 'fuerza', 'fuga', 'fumar', 'función', 'funda', 'furgón', 'furia', 'fusil', 'fútbol', 'futuro', 'gacela', 'gafas', 'gaita', 'gajo', 'gala', 'galería', 'gallo', 'gamba', 'ganar', 'gancho', 'ganga', 'ganso', 'garaje', 'garza', 'gasolina', 'gastar', 'gato', 'gavilán', 'gemelo', 'gemir', 'gen', 'género', 'genio', 'gente', 'geranio', 'gerente', 'germen', 'gesto', 'gigante', 'gimnasio', 'girar', 'giro', 'glaciar', 'globo', 'gloria', 'gol', 'golfo', 'goloso', 'golpe', 'goma', 'gordo', 'gorila', 'gorra', 'gota', 'goteo', 'gozar', 'grada', 'gráfico', 'grano', 'grasa', 'gratis', 'grave', 'grieta', 'grillo', 'gripe', 'gris', 'grito', 'grosor', 'grúa', 'grueso', 'grumo', 'grupo', 'guante', 'guapo', 'guardia', 'guerra', 'guía', 'guiño', 'guion', 'guiso', 'guitarra', 'gusano', 'gustar', 'haber', 'hábil', 'hablar', 'hacer', 'hacha', 'hada', 'hallar', 'hamaca', 'harina', 'haz', 'hazaña', 'hebilla', 'hebra', 'hecho', 'helado', 'helio', 'hembra', 'herir', 'hermano', 'héroe', 'hervir', 'hielo', 'hierro', 'hígado', 'higiene', 'hijo', 'himno', 'historia', 'hocico', 'hogar', 'hoguera', 'hoja', 'hombre', 'hongo', 'honor', 'honra', 'hora', 'hormiga', 'horno', 'hostil', 'hoyo', 'hueco', 'huelga', 'huerta', 'hueso', 'huevo', 'huida', 'huir', 'humano', 'húmedo', 'humilde', 'humo', 'hundir', 'huracán', 'hurto', 'icono', 'ideal', 'idioma', 'ídolo', 'iglesia', 'iglú', 'igual', 'ilegal', 'ilusión', 'imagen', 'imán', 'imitar', 'impar', 'imperio', 'imponer', 'impulso', 'incapaz', 'índice', 'inerte', 'infiel', 'informe', 'ingenio', 'inicio', 'inmenso', 'inmune', 'innato', 'insecto', 'instante', 'interés', 'íntimo', 'intuir', 'inútil', 'invierno', 'ira', 'iris', 'ironía', 'isla', 'islote', 'jabalí', 'jabón', 'jamón', 'jarabe', 'jardín', 'jarra', 'jaula', 'jazmín', 'jefe', 'jeringa', 'jinete', 'jornada', 'joroba', 'joven', 'joya', 'juerga', 'jueves', 'juez', 'jugador', 'jugo', 'juguete', 'juicio', 'junco', 'jungla', 'junio', 'juntar', 'júpiter', 'jurar', 'justo', 'juvenil', 'juzgar', 'kilo', 'koala', 'labio', 'lacio', 'lacra', 'lado', 'ladrón', 'lagarto', 'lágrima', 'laguna', 'laico', 'lamer', 'lámina', 'lámpara', 'lana', 'lancha', 'langosta', 'lanza', 'lápiz', 'largo', 'larva', 'lástima', 'lata', 'látex', 'latir', 'laurel', 'lavar', 'lazo', 'leal', 'lección', 'leche', 'lector', 'leer', 'legión', 'legumbre', 'lejano', 'lengua', 'lento', 'leña', 'león', 'leopardo', 'lesión', 'letal', 'letra', 'leve', 'leyenda', 'libertad', 'libro', 'licor', 'líder', 'lidiar', 'lienzo', 'liga', 'ligero', 'lima', 'límite', 'limón', 'limpio', 'lince', 'lindo', 'línea', 'lingote', 'lino', 'linterna', 'líquido', 'liso', 'lista', 'litera', 'litio', 'litro', 'llaga', 'llama', 'llanto', 'llave', 'llegar', 'llenar', 'llevar', 'llorar', 'llover', 'lluvia', 'lobo', 'loción', 'loco', 'locura', 'lógica', 'logro', 'lombriz', 'lomo', 'lonja', 'lote', 'lucha', 'lucir', 'lugar', 'lujo', 'luna', 'lunes', 'lupa', 'lustro', 'luto', 'luz', 'maceta', 'macho', 'madera', 'madre', 'maduro', 'maestro', 'mafia', 'magia', 'mago', 'maíz', 'maldad', 'maleta', 'malla', 'malo', 'mamá', 'mambo', 'mamut', 'manco', 'mando', 'manejar', 'manga', 'maniquí', 'manjar', 'mano', 'manso', 'manta', 'mañana', 'mapa', 'máquina', 'mar', 'marco', 'marea', 'marfil', 'margen', 'marido', 'mármol', 'marrón', 'martes', 'marzo', 'masa', 'máscara', 'masivo', 'matar', 'materia', 'matiz', 'matriz', 'máximo', 'mayor', 'mazorca', 'mecha', 'medalla', 'medio', 'médula', 'mejilla', 'mejor', 'melena', 'melón', 'memoria', 'menor', 'mensaje', 'mente', 'menú', 'mercado', 'merengue', 'mérito', 'mes', 'mesón', 'meta', 'meter', 'método', 'metro', 'mezcla', 'miedo', 'miel', 'miembro', 'miga', 'mil', 'milagro', 'militar', 'millón', 'mimo', 'mina', 'minero', 'mínimo', 'minuto', 'miope', 'mirar', 'misa', 'miseria', 'misil', 'mismo', 'mitad', 'mito', 'mochila', 'moción', 'moda', 'modelo', 'moho', 'mojar', 'molde', 'moler', 'molino', 'momento', 'momia', 'monarca', 'moneda', 'monja', 'monto', 'moño', 'morada', 'morder', 'moreno', 'morir', 'morro', 'morsa', 'mortal', 'mosca', 'mostrar', 'motivo', 'mover', 'móvil', 'mozo', 'mucho', 'mudar', 'mueble', 'muela', 'muerte', 'muestra', 'mugre', 'mujer', 'mula', 'muleta', 'multa', 'mundo', 'muñeca', 'mural', 'muro', 'músculo', 'museo', 'musgo', 'música', 'muslo', 'nácar', 'nación', 'nadar', 'naipe', 'naranja', 'nariz', 'narrar', 'nasal', 'natal', 'nativo', 'natural', 'náusea', 'naval', 'nave', 'navidad', 'necio', 'néctar', 'negar', 'negocio', 'negro', 'neón', 'nervio', 'neto', 'neutro', 'nevar', 'nevera', 'nicho', 'nido', 'niebla', 'nieto', 'niñez', 'niño', 'nítido', 'nivel', 'nobleza', 'noche', 'nómina', 'noria', 'norma', 'norte', 'nota', 'noticia', 'novato', 'novela', 'novio', 'nube', 'nuca', 'núcleo', 'nudillo', 'nudo', 'nuera', 'nueve', 'nuez', 'nulo', 'número', 'nutria', 'oasis', 'obeso', 'obispo', 'objeto', 'obra', 'obrero', 'observar', 'obtener', 'obvio', 'oca', 'ocaso', 'océano', 'ochenta', 'ocho', 'ocio', 'ocre', 'octavo', 'octubre', 'oculto', 'ocupar', 'ocurrir', 'odiar', 'odio', 'odisea', 'oeste', 'ofensa', 'oferta', 'oficio', 'ofrecer', 'ogro', 'oído', 'oír', 'ojo', 'ola', 'oleada', 'olfato', 'olivo', 'olla', 'olmo', 'olor', 'olvido', 'ombligo', 'onda', 'onza', 'opaco', 'opción', 'ópera', 'opinar', 'oponer', 'optar', 'óptica', 'opuesto', 'oración', 'orador', 'oral', 'órbita', 'orca', 'orden', 'oreja', 'órgano', 'orgía', 'orgullo', 'oriente', 'origen', 'orilla', 'oro', 'orquesta', 'oruga', 'osadía', 'oscuro', 'osezno', 'oso', 'ostra', 'otoño', 'otro', 'oveja', 'óvulo', 'óxido', 'oxígeno', 'oyente', 'ozono', 'pacto', 'padre', 'paella', 'página', 'pago', 'país', 'pájaro', 'palabra', 'palco', 'paleta', 'pálido', 'palma', 'paloma', 'palpar', 'pan', 'panal', 'pánico', 'pantera', 'pañuelo', 'papá', 'papel', 'papilla', 'paquete', 'parar', 'parcela', 'pared', 'parir', 'paro', 'párpado', 'parque', 'párrafo', 'parte', 'pasar', 'paseo', 'pasión', 'paso', 'pasta', 'pata', 'patio', 'patria', 'pausa', 'pauta', 'pavo', 'payaso', 'peatón', 'pecado', 'pecera', 'pecho', 'pedal', 'pedir', 'pegar', 'peine', 'pelar', 'peldaño', 'pelea', 'peligro', 'pellejo', 'pelo', 'peluca', 'pena', 'pensar', 'peñón', 'peón', 'peor', 'pepino', 'pequeño', 'pera', 'percha', 'perder', 'pereza', 'perfil', 'perico', 'perla', 'permiso', 'perro', 'persona', 'pesa', 'pesca', 'pésimo', 'pestaña', 'pétalo', 'petróleo', 'pez', 'pezuña', 'picar', 'pichón', 'pie', 'piedra', 'pierna', 'pieza', 'pijama', 'pilar', 'piloto', 'pimienta', 'pino', 'pintor', 'pinza', 'piña', 'piojo', 'pipa', 'pirata', 'pisar', 'piscina', 'piso', 'pista', 'pitón', 'pizca', 'placa', 'plan', 'plata', 'playa', 'plaza', 'pleito', 'pleno', 'plomo', 'pluma', 'plural', 'pobre', 'poco', 'poder', 'podio', 'poema', 'poesía', 'poeta', 'polen', 'policía', 'pollo', 'polvo', 'pomada', 'pomelo', 'pomo', 'pompa', 'poner', 'porción', 'portal', 'posada', 'poseer', 'posible', 'poste', 'potencia', 'potro', 'pozo', 'prado', 'precoz', 'pregunta', 'premio', 'prensa', 'preso', 'previo', 'primo', 'príncipe', 'prisión', 'privar', 'proa', 'probar', 'proceso', 'producto', 'proeza', 'profesor', 'programa', 'prole', 'promesa', 'pronto', 'propio', 'próximo', 'prueba', 'público', 'puchero', 'pudor', 'pueblo', 'puerta', 'puesto', 'pulga', 'pulir', 'pulmón', 'pulpo', 'pulso', 'puma', 'punto', 'puñal', 'puño', 'pupa', 'pupila', 'puré', 'quedar', 'queja', 'quemar', 'querer', 'queso', 'quieto', 'química', 'quince', 'quitar', 'rábano', 'rabia', 'rabo', 'ración', 'radical', 'raíz', 'rama', 'rampa', 'rancho', 'rango', 'rapaz', 'rápido', 'rapto', 'rasgo', 'raspa', 'rato', 'rayo', 'raza', 'razón', 'reacción', 'realidad', 'rebaño', 'rebote', 'recaer', 'receta', 'rechazo', 'recoger', 'recreo', 'recto', 'recurso', 'red', 'redondo', 'reducir', 'reflejo', 'reforma', 'refrán', 'refugio', 'regalo', 'regir', 'regla', 'regreso', 'rehén', 'reino', 'reír', 'reja', 'relato', 'relevo', 'relieve', 'relleno', 'reloj', 'remar', 'remedio', 'remo', 'rencor', 'rendir', 'renta', 'reparto', 'repetir', 'reposo', 'reptil', 'res', 'rescate', 'resina', 'respeto', 'resto', 'resumen', 'retiro', 'retorno', 'retrato', 'reunir', 'revés', 'revista', 'rey', 'rezar', 'rico', 'riego', 'rienda', 'riesgo', 'rifa', 'rígido', 'rigor', 'rincón', 'riñón', 'río', 'riqueza', 'risa', 'ritmo', 'rito', 'rizo', 'roble', 'roce', 'rociar', 'rodar', 'rodeo', 'rodilla', 'roer', 'rojizo', 'rojo', 'romero', 'romper', 'ron', 'ronco', 'ronda', 'ropa', 'ropero', 'rosa', 'rosca', 'rostro', 'rotar', 'rubí', 'rubor', 'rudo', 'rueda', 'rugir', 'ruido', 'ruina', 'ruleta', 'rulo', 'rumbo', 'rumor', 'ruptura', 'ruta', 'rutina', 'sábado', 'saber', 'sabio', 'sable', 'sacar', 'sagaz', 'sagrado', 'sala', 'saldo', 'salero', 'salir', 'salmón', 'salón', 'salsa', 'salto', 'salud', 'salvar', 'samba', 'sanción', 'sandía', 'sanear', 'sangre', 'sanidad', 'sano', 'santo', 'sapo', 'saque', 'sardina', 'sartén', 'sastre', 'satán', 'sauna', 'saxofón', 'sección', 'seco', 'secreto', 'secta', 'sed', 'seguir', 'seis', 'sello', 'selva', 'semana', 'semilla', 'senda', 'sensor', 'señal', 'señor', 'separar', 'sepia', 'sequía', 'ser', 'serie', 'sermón', 'servir', 'sesenta', 'sesión', 'seta', 'setenta', 'severo', 'sexo', 'sexto', 'sidra', 'siesta', 'siete', 'siglo', 'signo', 'sílaba', 'silbar', 'silencio', 'silla', 'símbolo', 'simio', 'sirena', 'sistema', 'sitio', 'situar', 'sobre', 'socio', 'sodio', 'sol', 'solapa', 'soldado', 'soledad', 'sólido', 'soltar', 'solución', 'sombra', 'sondeo', 'sonido', 'sonoro', 'sonrisa', 'sopa', 'soplar', 'soporte', 'sordo', 'sorpresa', 'sorteo', 'sostén', 'sótano', 'suave', 'subir', 'suceso', 'sudor', 'suegra', 'suelo', 'sueño', 'suerte', 'sufrir', 'sujeto', 'sultán', 'sumar', 'superar', 'suplir', 'suponer', 'supremo', 'sur', 'surco', 'sureño', 'surgir', 'susto', 'sutil', 'tabaco', 'tabique', 'tabla', 'tabú', 'taco', 'tacto', 'tajo', 'talar', 'talco', 'talento', 'talla', 'talón', 'tamaño', 'tambor', 'tango', 'tanque', 'tapa', 'tapete', 'tapia', 'tapón', 'taquilla', 'tarde', 'tarea', 'tarifa', 'tarjeta', 'tarot', 'tarro', 'tarta', 'tatuaje', 'tauro', 'taza', 'tazón', 'teatro', 'techo', 'tecla', 'técnica', 'tejado', 'tejer', 'tejido', 'tela', 'teléfono', 'tema', 'temor', 'templo', 'tenaz', 'tender', 'tener', 'tenis', 'tenso', 'teoría', 'terapia', 'terco', 'término', 'ternura', 'terror', 'tesis', 'tesoro', 'testigo', 'tetera', 'texto', 'tez', 'tibio', 'tiburón', 'tiempo', 'tienda', 'tierra', 'tieso', 'tigre', 'tijera', 'tilde', 'timbre', 'tímido', 'timo', 'tinta', 'tío', 'típico', 'tipo', 'tira', 'tirón', 'titán', 'títere', 'título', 'tiza', 'toalla', 'tobillo', 'tocar', 'tocino', 'todo', 'toga', 'toldo', 'tomar', 'tono', 'tonto', 'topar', 'tope', 'toque', 'tórax', 'torero', 'tormenta', 'torneo', 'toro', 'torpedo', 'torre', 'torso', 'tortuga', 'tos', 'tosco', 'toser', 'tóxico', 'trabajo', 'tractor', 'traer', 'tráfico', 'trago', 'traje', 'tramo', 'trance', 'trato', 'trauma', 'trazar', 'trébol', 'tregua', 'treinta', 'tren', 'trepar', 'tres', 'tribu', 'trigo', 'tripa', 'triste', 'triunfo', 'trofeo', 'trompa', 'tronco', 'tropa', 'trote', 'trozo', 'truco', 'trueno', 'trufa', 'tubería', 'tubo', 'tuerto', 'tumba', 'tumor', 'túnel', 'túnica', 'turbina', 'turismo', 'turno', 'tutor', 'ubicar', 'úlcera', 'umbral', 'unidad', 'unir', 'universo', 'uno', 'untar', 'uña', 'urbano', 'urbe', 'urgente', 'urna', 'usar', 'usuario', 'útil', 'utopía', 'uva', 'vaca', 'vacío', 'vacuna', 'vagar', 'vago', 'vaina', 'vajilla', 'vale', 'válido', 'valle', 'valor', 'válvula', 'vampiro', 'vara', 'variar', 'varón', 'vaso', 'vecino', 'vector', 'vehículo', 'veinte', 'vejez', 'vela', 'velero', 'veloz', 'vena', 'vencer', 'venda', 'veneno', 'vengar', 'venir', 'venta', 'venus', 'ver', 'verano', 'verbo', 'verde', 'vereda', 'verja', 'verso', 'verter', 'vía', 'viaje', 'vibrar', 'vicio', 'víctima', 'vida', 'vídeo', 'vidrio', 'viejo', 'viernes', 'vigor', 'vil', 'villa', 'vinagre', 'vino', 'viñedo', 'violín', 'viral', 'virgo', 'virtud', 'visor', 'víspera', 'vista', 'vitamina', 'viudo', 'vivaz', 'vivero', 'vivir', 'vivo', 'volcán', 'volumen', 'volver', 'voraz', 'votar', 'voto', 'voz', 'vuelo', 'vulgar', 'yacer', 'yate', 'yegua', 'yema', 'yerno', 'yeso', 'yodo', 'yoga', 'yogur', 'zafiro', 'zanja', 'zapato', 'zarza', 'zona', 'zorro', 'zumo', 'zurdo'];\nvar Words = {\n  CHINESE,\n  ENGLISH,\n  FRENCH,\n  ITALIAN,\n  JAPANESE,\n  SPANISH\n};\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\n// eslint-disable-next-line consistent-return\n\nvar Mnemonic = function Mnemonic(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  } // handle data overloading\n\n\n  var ent;\n  var phrase;\n  var seed;\n\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n\n  ent = ent || 128; // check and detect wordlist\n\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  } // validate phrase and ent\n\n\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = Words;\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * const valid = Mnemonic.isValid(\n *   'lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband',\n * );\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\n\nMnemonic.isValid = function (mnemonic, wordlist) {\n  var i;\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n\n  for (i = 0; i < words.length; i += 1) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin += \"00000000000\".concat(ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hashBits = bin.slice(-cs);\n  var nonhashBits = bin.slice(0, bin.length - cs);\n  var buf = Buffer.alloc(nonhashBits.length / 8);\n\n  for (i = 0; i < nonhashBits.length / 8; i += 1) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n\n  var expectedHashBits = Mnemonic._entropyChecksum(buf);\n\n  return expectedHashBits === hashBits;\n};\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\n\n\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n\n  for (var i = 0; i < words.length; i += 1) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n\n  return true;\n};\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\n\n\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n\n  for (var i = 0; i < dicts.length; i += 1) {\n    var key = dicts[i];\n\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n\n  return null;\n};\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\n\n\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return Mnemonic.pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd(\"mnemonic\".concat(passphrase)), 2048, 64);\n};\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\n\n\nMnemonic.fromSeed = function (seed, wordlist) {\n  preconditions.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  preconditions.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\n\n\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return HDPrivateKey.fromSeed(seed, network);\n};\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.inspect = function () {\n  return \"<Mnemonic: \".concat(this.toString(), \" >\");\n};\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n  var i;\n\n  for (i = 0; i < entropy.length; i += 1) {\n    bin += \"00000000\".concat(entropy[i].toString(2)).slice(-8);\n  }\n\n  bin += Mnemonic._entropyChecksum(entropy);\n\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n\n  var mnemonic = [];\n\n  for (i = 0; i < bin.length / 11; i += 1) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n\n  var ret;\n\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n\n  return ret;\n};\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\n\n\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2); // zero pad the hash bits\n\n  while (hashbits.length % 256 !== 0) {\n    hashbits = \"0\".concat(hashbits);\n  }\n\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\n\nMnemonic.pbkdf2 = pbkdf2;\nvar name = \"bitcoinsource\";\nvar version = \"0.1.19\";\nvar description = \"A simple, safe, and powerful JavaScript Bitcoin Cash library.\";\nvar author = \"Clemens Ley <ley.clemens@gmail.com>\";\nvar license = \"MIT\";\nvar main = \"dist/bitcoinsource.common.js\";\nvar module = \"dist/bitcoinsource.esm.js\";\nvar files = [\"dist\"];\nvar scripts = {\n  build: \"rollup -c\",\n  test: \"mocha --recursive --timeout 7000 --require @babel/register\",\n  \"test:cover\": \"nyc mocha\",\n  lint: \"eslint src test\",\n  \"lint:fix\": \"eslint src test --fix\",\n  flow: \"flow check\",\n  clean: \"rm -rf dist\",\n  docs: \"mustache package.json README.tpl.md > README.md\",\n  preversion: \"npm run clean && npm run lint && npm run flow && npm run test\",\n  version: \"npm run build && npm run docs && git add README.md\",\n  postversion: \"git push && git push --tags && npm publish\",\n  bump: \"npm version patch -m 'Bump version to %s.'\"\n};\nvar keywords = [\"bitcoin\", \"source\", \"transaction\", \"address\", \"p2p\", \"cryptocurrency\", \"blockchain\", \"payment\", \"multisig\"];\nvar repository = {\n  type: \"git\",\n  url: \"https://github.com/bitcoin-computer/bitcoin-source\"\n};\nvar prettier = {\n  printWidth: 100,\n  proseWrap: \"preserve\",\n  semi: false,\n  singleQuote: true\n};\nvar dependencies = {\n  \"big-integer\": \"^1.6.48\",\n  \"bn.js\": \"^4.11.9\",\n  bs58: \"=4.0.1\",\n  \"buffer-compare\": \"=1.1.1\",\n  cashaddrjs: \"^0.3.11\",\n  elliptic: \"^6.5.2\",\n  \"hash.js\": \"^1.1.7\",\n  lodash: \"^4.17.15\",\n  randombytes: \"^2.1.0\",\n  unorm: \"^1.6.0\"\n};\nvar devDependencies = {\n  \"@babel/core\": \"^7.9.6\",\n  \"@babel/preset-env\": \"^7.9.6\",\n  \"@babel/preset-flow\": \"^7.9.0\",\n  \"@babel/register\": \"^7.9.0\",\n  \"babel-eslint\": \"^10.1.0\",\n  \"babel-preset-minify\": \"^0.5.1\",\n  chai: \"^4.2.0\",\n  eslint: \"^7.0.0\",\n  \"eslint-config-airbnb-base\": \"^14.1.0\",\n  \"eslint-config-prettier\": \"^6.11.0\",\n  \"eslint-plugin-flowtype\": \"^5.1.0\",\n  \"eslint-plugin-flowtype-errors\": \"^4.3.0\",\n  \"eslint-plugin-import\": \"^2.20.2\",\n  \"eslint-plugin-prettier\": \"^3.1.3\",\n  \"flow-bin\": \"^0.125.1\",\n  \"flow-typed\": \"^3.1.0\",\n  jsdoc: \"^3.6.4\",\n  mocha: \"^7.1.2\",\n  mustache: \"^4.0.1\",\n  nyc: \"^15.0.1\",\n  prettier: \"^2.0.5\",\n  rollup: \"^2.10.5\",\n  \"rollup-plugin-babel\": \"^4.4.0\",\n  \"rollup-plugin-commonjs\": \"^10.1.0\",\n  \"rollup-plugin-flow\": \"^1.1.1\",\n  \"rollup-plugin-json\": \"^4.0.0\",\n  \"rollup-plugin-node-builtins\": \"^2.1.2\",\n  \"rollup-plugin-node-globals\": \"^1.4.0\",\n  \"rollup-plugin-node-resolve\": \"^5.2.0\",\n  \"rollup-plugin-terser\": \"^5.3.0\",\n  sinon: \"^9.0.2\"\n};\nvar PackageInfo = {\n  name: name,\n  version: version,\n  description: description,\n  author: author,\n  license: license,\n  main: main,\n  module: module,\n  files: files,\n  scripts: scripts,\n  keywords: keywords,\n  repository: repository,\n  prettier: prettier,\n  dependencies: dependencies,\n  devDependencies: devDependencies\n};\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags) {\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx,\n    nin,\n    flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack,\n    tx,\n    nin,\n    flags\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx,\n      nin,\n      flags\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n\n    return true;\n  }\n\n  return true;\n};\n\nInterpreter.prototype.initialize = function () {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altstack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes\n// script failure. Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to\n// checksig causes that pubkey to be skipped (not softfork safe: this flag can widen the validity\n// of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe,\n// BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script\n// failure (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7)\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible,\n// direct pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger).\n// Evaluating any other push causes the script to fail (BIP62 rule 3). In addition, whenever a\n// stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // CLTV See BIP65 for details.\n\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i += 1) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkSignatureEncoding = function (buf) {\n  var sig;\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = \"SCRIPT_ERR_UNKNOWN_ERROR: \".concat(e);\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; // bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf;\n  var buf1;\n  var buf2;\n  var spliced;\n  var n;\n  var x1;\n  var x2;\n  var bn;\n  var bn1;\n  var bn2;\n  var bufSig;\n  var bufPubkey;\n  var subscript;\n  var sig;\n  var pubkey;\n  var fValue;\n  var fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc += 1;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16) {\n    this.nOpCount += 1;\n\n    if (this.nOpCount > 201) {\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\n      return false;\n    }\n  }\n\n  if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && opcodenum >= 0 && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        // ( -- value)\n        // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n        n = opcodenum - (Opcode.OP_1 - 1);\n        buf = new BN(n).toScriptNumBuffer();\n        this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n        // they push, so no need for a CheckMinimalPush here.\n\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        {\n          if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n            // not enabled; treat as a NOP2\n            if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n              this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n              return false;\n            }\n\n            break;\n          }\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Note that elsewhere numeric opcodes are limited to\n          // operands in the range -2**31+1 to 2**31-1, however it is\n          // legal for opcodes to produce results exceeding that\n          // range. This limitation is implemented by CScriptNum's\n          // default 4-byte limit.\n          //\n          // If we kept to that limit we'd have a year 2038 problem,\n          // even though the nLockTime field in transactions\n          // themselves is uint32 which only becomes meaningless\n          // after the year 2106.\n          //\n          // Thus as a special case we tell CScriptNum to accept up\n          // to 5-byte bignums, which are good until 2**39-1, well\n          // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n          var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n          // some arithmetic being done first, you can always use\n          // 0 MAX CHECKLOCKTIMEVERIFY.\n\n          if (nLockTime.lt(new BN(0))) {\n            this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n            return false;\n          } // Actually compare the specified lock time with the transaction.\n\n\n          if (!this.checkLockTime(nLockTime)) {\n            this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n            return false;\n          }\n\n          break;\n        }\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        // <expression> if [statements] [else [statements]] endif\n        // bool fValue = false;\n        fValue = false;\n\n        if (fExec) {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          buf = this.stack.pop();\n          fValue = Interpreter.castToBool(buf);\n\n          if (opcodenum === Opcode.OP_NOTIF) {\n            fValue = !fValue;\n          }\n        }\n\n        this.vfExec.push(fValue);\n        break;\n\n      case Opcode.OP_ELSE:\n        if (this.vfExec.length === 0) {\n          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n          return false;\n        }\n\n        this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        break;\n\n      case Opcode.OP_ENDIF:\n        if (this.vfExec.length === 0) {\n          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n          return false;\n        }\n\n        this.vfExec.pop();\n        break;\n\n      case Opcode.OP_VERIFY:\n        // (true -- ) or\n        // (false -- false) and return\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        fValue = Interpreter.castToBool(buf);\n\n        if (fValue) {\n          this.stack.pop();\n        } else {\n          this.errstr = 'SCRIPT_ERR_VERIFY';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_RETURN:\n        this.errstr = 'SCRIPT_ERR_OP_RETURN';\n        return false;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.altstack.push(this.stack.pop());\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        if (this.altstack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.altstack.pop());\n        break;\n\n      case Opcode.OP_2DROP:\n        // (x1 x2 -- )\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.pop();\n        this.stack.pop();\n        break;\n\n      case Opcode.OP_2DUP:\n        // (x1 x2 -- x1 x2 x1 x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf1 = this.stack[this.stack.length - 2];\n        buf2 = this.stack[this.stack.length - 1];\n        this.stack.push(buf1);\n        this.stack.push(buf2);\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n        if (this.stack.length < 4) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf1 = this.stack[this.stack.length - 4];\n        buf2 = this.stack[this.stack.length - 3];\n        this.stack.push(buf1);\n        this.stack.push(buf2);\n        break;\n\n      case Opcode.OP_2ROT:\n        // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n        if (this.stack.length < 6) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        spliced = this.stack.splice(this.stack.length - 6, 2);\n        this.stack.push(spliced[0]);\n        this.stack.push(spliced[1]);\n        break;\n\n      case Opcode.OP_2SWAP:\n        // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n        if (this.stack.length < 4) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        spliced = this.stack.splice(this.stack.length - 4, 2);\n        this.stack.push(spliced[0]);\n        this.stack.push(spliced[1]);\n        break;\n\n      case Opcode.OP_IFDUP:\n        // (x - 0 | x x)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        fValue = Interpreter.castToBool(buf);\n\n        if (fValue) {\n          this.stack.push(buf);\n        }\n\n        break;\n\n      case Opcode.OP_DEPTH:\n        // -- stacksize\n        buf = new BN(this.stack.length).toScriptNumBuffer();\n        this.stack.push(buf);\n        break;\n\n      case Opcode.OP_DROP:\n        // (x -- )\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.pop();\n        break;\n\n      case Opcode.OP_DUP:\n        // (x -- x x)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.stack[this.stack.length - 1]);\n        break;\n\n      case Opcode.OP_NIP:\n        // (x1 x2 -- x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.splice(this.stack.length - 2, 1);\n        break;\n\n      case Opcode.OP_OVER:\n        // (x1 x2 -- x1 x2 x1)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.stack[this.stack.length - 2]);\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n        // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n        n = bn.toNumber();\n        this.stack.pop();\n\n        if (n < 0 || n >= this.stack.length) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - n - 1];\n\n        if (opcodenum === Opcode.OP_ROLL) {\n          this.stack.splice(this.stack.length - n - 1, 1);\n        }\n\n        this.stack.push(buf);\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        // (x1 x2 -- x2 x1)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        x1 = this.stack[this.stack.length - 2];\n        x2 = this.stack[this.stack.length - 1];\n        this.stack[this.stack.length - 2] = x2;\n        this.stack[this.stack.length - 1] = x1;\n        break;\n\n      case Opcode.OP_TUCK:\n        // (x1 x2 -- x2 x1 x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        break;\n\n      case Opcode.OP_SIZE:\n        // (in -- in size)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        bn = new BN(this.stack[this.stack.length - 1].length);\n        this.stack.push(bn.toScriptNumBuffer());\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        // case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        // (in -- out)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n        switch (opcodenum) {\n          case Opcode.OP_1ADD:\n            bn = bn.add(BN.One);\n            break;\n\n          case Opcode.OP_1SUB:\n            bn = bn.sub(BN.One);\n            break;\n\n          case Opcode.OP_NEGATE:\n            bn = bn.neg();\n            break;\n\n          case Opcode.OP_ABS:\n            if (bn.cmp(BN.Zero) < 0) {\n              bn = bn.neg();\n            }\n\n            break;\n\n          case Opcode.OP_NOT:\n            bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n            break;\n\n          case Opcode.OP_0NOTEQUAL:\n            bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n            break;\n\n          default:\n            // We should really not end up in here.\n            throw new Error('Ended up in a default switch statement that should never be executed.');\n        }\n\n        this.stack.pop();\n        this.stack.push(bn.toScriptNumBuffer());\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        // (x1 x2 -- out)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n        bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n        bn = new BN(0);\n\n        switch (opcodenum) {\n          case Opcode.OP_ADD:\n            bn = bn1.add(bn2);\n            break;\n\n          case Opcode.OP_SUB:\n            bn = bn1.sub(bn2);\n            break;\n          // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n\n          case Opcode.OP_BOOLAND:\n            bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n            break;\n          // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n          case Opcode.OP_BOOLOR:\n            bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n            break;\n          // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n          case Opcode.OP_NUMEQUAL:\n            bn = new BN((bn1.cmp(bn2) === 0) + 0);\n            break;\n          // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n          case Opcode.OP_NUMEQUALVERIFY:\n            bn = new BN((bn1.cmp(bn2) === 0) + 0);\n            break;\n          // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n          case Opcode.OP_NUMNOTEQUAL:\n            bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n            break;\n          // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n          case Opcode.OP_LESSTHAN:\n            bn = new BN((bn1.cmp(bn2) < 0) + 0);\n            break;\n          // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n          case Opcode.OP_GREATERTHAN:\n            bn = new BN((bn1.cmp(bn2) > 0) + 0);\n            break;\n          // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n          case Opcode.OP_LESSTHANOREQUAL:\n            bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n            break;\n          // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n          case Opcode.OP_GREATERTHANOREQUAL:\n            bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n            break;\n\n          case Opcode.OP_MIN:\n            bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n            break;\n\n          case Opcode.OP_MAX:\n            bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n            break;\n\n          default:\n            // We should really not end up in here.\n            throw new Error('Ended up in a default switch statement that should never be executed.');\n        }\n\n        this.stack.pop();\n        this.stack.pop();\n        this.stack.push(bn.toScriptNumBuffer());\n\n        if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n          // if (CastToBool(stacktop(-1)))\n          if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n            return false;\n          }\n        }\n\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); // bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1]; // valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        // Hash starts after the code separator\n        this.pbegincodehash = this.pc;\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1]; // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            // invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // int ikey = ++i;\n\n\n          i += 1;\n          var ikey = i;\n          i += nKeysCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          i += 1;\n          var isig = i;\n          i += nSigsCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signatures, since there's no way for a signature to sign itself\n\n          for (var k = 0; k < nSigsCount; k += 1) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig]; // valtype& vchPubKey = stacktop(-ikey);\n\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk = void 0;\n\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              // invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig += 1;\n              nSigsCount -= 1;\n            }\n\n            ikey += 1;\n            nKeysCount -= 1; // If there are more signatures left than keys left,\n            // then too many signatures have failed\n\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i > 1) {\n            i -= 1;\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\nclass ScriptHashInput extends Input {\n  constructor(input, pubkeys, redeemScript) {\n    super(input, pubkeys, redeemScript);\n    var self = this;\n    this.publicKeys = pubkeys || input.publicKeys;\n    this.threshold = 1;\n    this.redeemScript = redeemScript;\n    preconditions.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script), \"Provided redeemScript doesn't hash to the provided output\");\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      self.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  }\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature));\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n      cachedMultisig: this.redeemScript\n    }));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    var self = this;\n    return this.publicKeys.filter(publicKey => !self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript, this.output.satoshisBN);\n  }\n\n  _estimateSize() {\n    return ScriptHashInput.OPCODES_SIZE + this.threshold * ScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * ScriptHashInput.PUBKEY_SIZE;\n  }\n\n}\n\nScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\n\nScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\n\nScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\n\nvar TXID_REGEX = /[0-9A-Fa-f]{64}/;\n/**\n * Output identifier for a Bitcoin transaction\n */\n\nclass OutputId {\n  /**\n      Creates an output id from a transaction id and output index\n     * @param {string} txId Transaction id in hex format\n     * @param {number} outputIndex Output index\n     */\n  constructor(txId, outputIndex) {\n    if (!TXID_REGEX.test(txId)) throw new Error(\"txId not in a valid hex format: \".concat(txId));\n    if (outputIndex < 0 || outputIndex > 4294967295 || Number.isNaN(outputIndex)) throw new Error(\"outputIndex out of range: \".concat(outputIndex));\n    this.txId = txId;\n    this.outputIndex = outputIndex;\n  }\n  /**\n   * Serializes the output id into a compressed string form\n   */\n\n\n  toString() {\n    return \"\".concat(this.txId, \":\").concat(this.outputIndex);\n  }\n  /**\n   * Parses the output id form its compressed string form\n   * @param {string} s String to parse\n   */\n\n\n  static fromString(s) {\n    var parts = s.split(':');\n    if (parts.length !== 2) throw new Error('Invalid string format');\n    return new OutputId(parts[0], parseInt(parts[1], 10));\n  }\n  /**\n   * Get the transaction id in hex format\n   */\n\n\n  get txid() {\n    return this.txId;\n  }\n  /**\n   * Get the output index\n   */\n\n\n  get vout() {\n    return this.outputIndex;\n  }\n  /**\n   * Returns whether two OutputIds refer to the same output\n   * @param {OutputId} other Other object to compare\n   * @returns {bool} True if the objects refer to the same output, false if not\n   */\n\n\n  equals(other) {\n    return this.outputIndex === other.outputIndex && this.txId.toLowerCase() === other.txId.toLowerCase();\n  }\n\n}\n/**\n * Bitcore URI\n *\n * Instantiate an URI from a bitcoin cash URI String or an Object. An URI instance\n * can be created with a bitcoin cash uri string or an object. All instances of\n * URI are valid, the static method isValid allows checking before instantiation.\n *\n * All standard parameters can be found as members of the class, the address\n * is represented using an {Address} instance and the amount is represented in\n * satoshis. Any other non-standard parameters can be found under the extra member.\n *\n * @example\n * ```javascript\n *\n * var uri = new URI('bitcoincash:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\n * console.log(uri.address, uri.amount);\n * ```\n *\n * @param {string|Object} data - A bitcoin cash URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n * @returns {URI} A new valid and frozen instance of URI\n * @constructor\n */\n// eslint-disable-next-line consistent-return\n\n\nvar URI = function URI(data, knownParams) {\n  // #weirdstuff refactor\n  if (!(this instanceof URI)) {\n    return new URI(data, knownParams);\n  }\n\n  this.extras = {};\n  this.knownParams = knownParams || [];\n  this.address = null;\n  this.network = null;\n  this.amount = null;\n  this.message = null;\n\n  if (typeof data === 'string') {\n    var params = URI.parse(data);\n\n    if (params.amount) {\n      params.amount = this._parseAmount(params.amount);\n    }\n\n    this._fromObject(params);\n  } else if (typeof data === 'object') {\n    this._fromObject(data);\n  } else {\n    throw new TypeError('Unrecognized data format.');\n  }\n};\n/**\n * Instantiate a URI from a String\n *\n * @param {string} str - JSON string or object of the URI\n * @returns {URI} A new instance of a URI\n */\n\n\nURI.fromString = function fromString(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  return new URI(str);\n};\n/**\n * Instantiate a URI from an Object\n *\n * @param {Object} data - object of the URI\n * @returns {URI} A new instance of a URI\n */\n\n\nURI.fromObject = function fromObject(json) {\n  return new URI(json);\n};\n/**\n * Check if an bitcoin cash URI string is valid\n *\n * @example\n * ```javascript\n *\n * var valid = URI.isValid('bitcoincash:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n * // true\n * ```\n *\n * @param {string|Object} data - A bitcoin cash URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @returns {boolean} Result of uri validation\n */\n\n\nURI.isValid = function (arg, knownParams) {\n  try {\n    // #weirdstuff refactor\n    // eslint-disable-next-line no-new\n    new URI(arg, knownParams);\n  } catch (err) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Convert a bitcoin cash URI string into a simple object.\n *\n * @param {string} uri - A bitcoin cash URI string\n * @throws {TypeError} Invalid bitcoin cash URI\n * @returns {Object} An object with the parsed params\n */\n\n\nURI.parse = function (uri) {\n  var info = URL.parse(uri, true);\n\n  if (info.protocol !== 'bitcoincash:') {\n    throw new TypeError('Invalid bitcoin cash URI');\n  } // workaround to host insensitiveness\n\n\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\n  info.query.address = group && group[1] || undefined;\n  return info.query;\n};\n\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\n/**\n * Internal function to load the URI instance with an object.\n *\n * @param {Object} obj - Object with the information\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n */\n\nURI.prototype._fromObject = function (obj) {\n  if (!Address.isValid(obj.address)) {\n    throw new TypeError('Invalid bitcoin address');\n  }\n\n  this.address = new Address(obj.address);\n  this.network = this.address.network;\n  this.amount = obj.amount;\n  Object.keys(obj).forEach(key => {\n    if (key !== 'address' && key !== 'amount') {\n      if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\n        throw Error(\"Unknown required argument \".concat(key));\n      }\n\n      var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\n      destination[key] = obj[key];\n    }\n  });\n};\n/**\n * Internal function to transform a BTC string amount into satoshis\n *\n * @param {string} amount - Amount BTC string\n * @throws {TypeError} Invalid amount\n * @returns {Object} Amount represented in satoshis\n */\n\n\nURI.prototype._parseAmount = function (amount) {\n  amount = Number(amount);\n\n  if (Number.isNaN(amount)) {\n    throw new TypeError('Invalid amount');\n  }\n\n  return Unit.fromBTC(amount).toSatoshis();\n};\n\nURI.prototype.toJSON = function toObject() {\n  var _this = this;\n\n  var json = {};\n\n  var _loop = function _loop(i) {\n    var m = URI.Members[i];\n\n    if (Object.keys(_this).findIndex(key => key === m) !== 1 && typeof _this[m] !== 'undefined') {\n      json[m] = _this[m].toString();\n    }\n  };\n\n  for (var i = 0; i < URI.Members.length; i += 1) {\n    _loop(i);\n  }\n\n  _.extend(json, this.extras);\n\n  return json;\n};\n\nURI.prototype.toObject = URI.prototype.toJSON;\n/**\n * Will return a the string representation of the URI\n *\n * @returns {string} Bitcoin cash URI string\n */\n\nURI.prototype.toString = function () {\n  var query = {};\n\n  if (this.amount) {\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\n  }\n\n  if (this.message) {\n    query.message = this.message;\n  }\n\n  if (this.label) {\n    query.label = this.label;\n  }\n\n  if (this.r) {\n    query.r = this.r;\n  }\n\n  _.extend(query, this.extras);\n\n  return URL.format({\n    protocol: 'bitcoincash:',\n    host: this.address,\n    query\n  });\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin cash URI\n */\n\n\nURI.prototype.inspect = function () {\n  return \"<URI: \".concat(this.toString(), \">\");\n};\n\nvar Varint = function Varint(buf) {\n  if (!(this instanceof Varint)) return new Varint(buf);\n\n  if (Buffer.isBuffer(buf)) {\n    this.buf = buf;\n  } else if (typeof buf === 'number') {\n    var num = buf;\n    this.fromNumber(num);\n  } else if (buf instanceof BN) {\n    var bn = buf;\n    this.fromBN(bn);\n  } else if (buf) {\n    var obj = buf;\n    this.set(obj);\n  }\n};\n\nVarint.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf;\n  return this;\n};\n\nVarint.prototype.fromString = function (str) {\n  this.set({\n    buf: Buffer.from(str, 'hex')\n  });\n  return this;\n};\n\nVarint.prototype.toString = function () {\n  return this.buf.toString('hex');\n};\n\nVarint.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nVarint.prototype.fromBufferReader = function (br) {\n  this.buf = br.readVarintBuf();\n  return this;\n};\n\nVarint.prototype.fromBN = function (bn) {\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\n  return this;\n};\n\nVarint.prototype.fromNumber = function (num) {\n  this.buf = BufferWriter().writeVarintNum(num).concat();\n  return this;\n};\n\nVarint.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nVarint.prototype.toBN = function () {\n  return BufferReader(this.buf).readVarintBN();\n};\n\nVarint.prototype.toNumber = function () {\n  return BufferReader(this.buf).readVarintNum();\n};\n\nvar Bitcoin = {}; // module information\n\nBitcoin.version = \"v\".concat(PackageInfo.version); // eslint-disable-next-line no-unused-vars\n\nBitcoin.versionGuard = function (version) {// if (version !== undefined) {\n  //   var message = 'More than one instance of bitcoincashjs found. ' +\n  //     'Please make sure to require bitcoincashjs and check that submodules do' +\n  //     ' not also include their own bitcoincashjs dependency.';\n  //   throw new Error(message);\n  // }\n};\n\nBitcoin.versionGuard(global._bitcoin);\nglobal._bitcoin = Bitcoin.version; // crypto\n\nBitcoin.crypto = {};\nBitcoin.crypto.BN = BN;\nBitcoin.crypto.ECDSA = ECDSA;\nBitcoin.crypto.Hash = Hash;\nBitcoin.crypto.Random = Random;\nBitcoin.crypto.Point = Point;\nBitcoin.crypto.Signature = Signature; // encoding\n\nBitcoin.encoding = {};\nBitcoin.encoding.Base58 = Base58;\nBitcoin.encoding.Base58Check = Base58Check;\nBitcoin.encoding.BufferReader = BufferReader;\nBitcoin.encoding.BufferWriter = BufferWriter;\nBitcoin.encoding.Varint = Varint; // utilities\n\nBitcoin.util = {};\nBitcoin.util.buffer = BufferUtil;\nBitcoin.util.js = JSUtil;\nBitcoin.util.preconditions = preconditions; // errors thrown by the library\n\nBitcoin.errors = errors; // main bitcoin library\n\nBitcoin.Address = Address;\nBitcoin.Block = Block;\nBitcoin.Block.BlockHeader = BlockHeader;\nBitcoin.Block.MerkleBlock = MerkleBlock;\nBitcoin.BlockHeader = BlockHeader;\nBitcoin.HDPrivateKey = HDPrivateKey;\nBitcoin.HDPublicKey = HDPublicKey;\nBitcoin.MerkleBlock = MerkleBlock;\nBitcoin.Message = Message;\nBitcoin.Mnemonic = Mnemonic;\nBitcoin.Networks = Networks;\nBitcoin.Opcode = Opcode;\nBitcoin.PrivateKey = PrivateKey;\nBitcoin.PublicKey = PublicKey;\nBitcoin.Script = Script;\nBitcoin.Script.Interpreter = Interpreter;\nBitcoin.Transaction = Transaction;\nBitcoin.Transaction.Input = Input;\nBitcoin.Transaction.Input.MultiSig = MultiSigInput;\nBitcoin.Transaction.Input.MultiSigScriptHash = MultiSigScriptHashInput;\nBitcoin.Transaction.Input.PublicKey = PublicKeyInput;\nBitcoin.Transaction.Input.PublicKeyHash = PublicKeyHashInput;\nBitcoin.Transaction.Input.ScriptHash = ScriptHashInput;\nBitcoin.Transaction.Output = Output;\nBitcoin.Transaction.OutputId = OutputId;\nBitcoin.Transaction.Sighash = Sighash;\nBitcoin.Transaction.Signature = TransactionSignature;\nBitcoin.Transaction.UnspentOutput = UnspentOutput;\nBitcoin.Unit = Unit;\nBitcoin.URI = URI; // dependencies, subject to change\n\nBitcoin.deps = {};\nBitcoin.deps.bnjs = BN;\nBitcoin.deps.bs58 = bs58;\nBitcoin.deps.Buffer = Buffer;\nBitcoin.deps.elliptic = elliptic;\nBitcoin.deps._ = _;\nexport default Bitcoin;","map":null,"metadata":{},"sourceType":"module"}