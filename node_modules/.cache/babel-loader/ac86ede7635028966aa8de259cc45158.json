{"ast":null,"code":"/**\n * https://github.com/the-bitcoin-token/bitcoin-source\n * Copyright (c) 2019 Bitcoin Computer\n * Copyright (c) 2019 Brenton Gunning\n * Copyright (c) 2018 Janez Urevc\n * Copyright (c) 2018-2019 Clemens Ley\n * Copyright (c) 2017-2018 Emilio Almansi\n * Copyright (c) 2013-2017 BitPay, Inc.\n * Copyright (c) 2009-2015 The Bitcoin Core developers\n * Copyright (c) 2014 Ryan X. Charles\n * Copyright (c) 2014 reddit, Inc.\n * Copyright (c) 2011 Stefan Thomas <justmoon@members.fsf.org>\n * Copyright (c) 2011 Google Inc.\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nimport _ from 'lodash';\nimport elliptic from 'elliptic';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport cashaddr from 'cashaddrjs';\nimport hash from 'hash.js';\nimport assert from 'assert';\nimport randomBytes from 'randombytes';\nimport bufferCompare from 'buffer-compare';\nimport unorm from 'unorm';\nimport URL from 'url';\nvar docsURL = 'http://bitcore.io/';\nvar data = [{\n  name: 'InvalidB58Char',\n  message: 'Invalid Base58 character: {0} in {1}'\n}, {\n  name: 'InvalidB58Checksum',\n  message: 'Invalid Base58 checksum for {0}'\n}, {\n  name: 'InvalidNetwork',\n  message: 'Invalid version for network: got {0}'\n}, {\n  name: 'InvalidState',\n  message: 'Invalid state: {0}'\n}, {\n  name: 'NotImplemented',\n  message: 'Function {0} was not implemented yet'\n}, {\n  name: 'InvalidNetworkArgument',\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\n}, {\n  name: 'InvalidArgument',\n\n  message() {\n    return \"Invalid Argument\".concat((arguments.length <= 0 ? undefined : arguments[0]) ? \": \".concat(arguments.length <= 0 ? undefined : arguments[0]) : '').concat((arguments.length <= 1 ? undefined : arguments[1]) ? \" Documentation: \".concat(docsURL).concat(arguments.length <= 1 ? undefined : arguments[1]) : '');\n  }\n\n}, {\n  name: 'AbstractMethodInvoked',\n  message: 'Abstract Method Invocation: {0}'\n}, {\n  name: 'InvalidArgumentType',\n\n  message() {\n    return \"Invalid Argument for \".concat(arguments.length <= 2 ? undefined : arguments[2], \", expected \").concat(arguments.length <= 1 ? undefined : arguments[1], \" but got \").concat(typeof (arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n}, {\n  name: 'Unit',\n  message: 'Internal Error on Unit {0}',\n  errors: [{\n    name: 'UnknownCode',\n    message: 'Unrecognized unit code: {0}'\n  }, {\n    name: 'InvalidRate',\n    message: 'Invalid exchange rate: {0}'\n  }]\n}, {\n  name: 'Transaction',\n  message: 'Internal Error on Transaction {0}',\n  errors: [{\n    name: 'Input',\n    message: 'Internal Error on Input {0}',\n    errors: [{\n      name: 'MissingScript',\n      message: 'Need a script to create an input'\n    }, {\n      name: 'UnsupportedScript',\n      message: 'Unsupported input script type: {0}'\n    }, {\n      name: 'MissingPreviousOutput',\n      message: 'No previous output information.'\n    }]\n  }, {\n    name: 'NeedMoreInfo',\n    message: '{0}'\n  }, {\n    name: 'InvalidSorting',\n    message: 'The sorting function provided did not return the change output as one of the array elements'\n  }, {\n    name: 'InvalidOutputAmountSum',\n    message: '{0}'\n  }, {\n    name: 'MissingSignatures',\n    message: 'Some inputs have not been fully signed'\n  }, {\n    name: 'InvalidIndex',\n    message: 'Invalid index: {0} is not between 0, {1}'\n  }, {\n    name: 'UnableToVerifySignature',\n    message: 'Unable to verify signature: {0}'\n  }, {\n    name: 'DustOutputs',\n    message: 'Dust amount detected in one output'\n  }, {\n    name: 'InvalidSatoshis',\n    message: 'Output satoshis are invalid'\n  }, {\n    name: 'FeeError',\n    message: 'Internal Error on Fee {0}',\n    errors: [{\n      name: 'TooSmall',\n      message: 'Fee is too small: {0}'\n    }, {\n      name: 'TooLarge',\n      message: 'Fee is too large: {0}'\n    }, {\n      name: 'Different',\n      message: 'Unspent value is different from specified fee: {0}'\n    }]\n  }, {\n    name: 'ChangeAddressMissing',\n    message: 'Change address is missing'\n  }, {\n    name: 'BlockHeightTooHigh',\n    message: 'Block Height can be at most 2^32 -1'\n  }, {\n    name: 'NLockTimeOutOfRange',\n    message: 'Block Height can only be between 0 and 499 999 999'\n  }, {\n    name: 'LockTimeTooEarly',\n    message: \"Lock Time can't be earlier than UNIX date 500 000 000\"\n  }]\n}, {\n  name: 'Script',\n  message: 'Internal Error on Script {0}',\n  errors: [{\n    name: 'UnrecognizedAddress',\n    message: 'Expected argument {0} to be an address'\n  }, {\n    name: 'CantDeriveAddress',\n    message: \"Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.\"\n  }, {\n    name: 'InvalidBuffer',\n    message: \"Invalid script buffer: can't parse valid script from given buffer {0}\"\n  }]\n}, {\n  name: 'HDPrivateKey',\n  message: 'Internal Error on HDPrivateKey {0}',\n  errors: [{\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\n  }, {\n    name: 'InvalidEntropyArgument',\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\n    errors: [{\n      name: 'TooMuchEntropy',\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\n    }, {\n      name: 'NotEnoughEntropy',\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\n    }]\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xprivkey string in {0}'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path: {0}'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\n  }]\n}, {\n  name: 'HDPublicKey',\n  message: 'Internal Error on HDPublicKey {0}',\n  errors: [{\n    name: 'ArgumentIsPrivateExtended',\n    message: 'Argument is an extended private key: {0}'\n  }, {\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument: got {0}'\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xpubkey: got \"{0}\"'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\n  }, {\n    name: 'InvalidIndexCantDeriveHardened',\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\n  }, {\n    name: 'MustSupplyArgument',\n    message: 'Must supply an argument to create a HDPublicKey'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\n  }]\n}, {\n  name: 'Mnemonic',\n  message: 'Internal Error on bitcore-mnemonic module {0}',\n  errors: [{\n    name: 'InvalidEntropy',\n    message: 'Entropy length must be an even multiple of 11 bits: {0}'\n  }, {\n    name: 'UnknownWordlist',\n    message: 'Could not detect the used word list: {0}'\n  }, {\n    name: 'InvalidMnemonic',\n    message: 'Mnemonic string is invalid: {0}'\n  }]\n}];\n\nfunction format(message, args) {\n  return message.replace('{0}', args[0]).replace('{1}', args[1]).replace('{2}', args[2]);\n}\n\nvar traverseNode = function traverseNode(parent, errorDefinition) {\n  var NodeError = function NodeError() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (_.isString(errorDefinition.message)) {\n      this.message = format(errorDefinition.message, args);\n    } else if (_.isFunction(errorDefinition.message)) {\n      this.message = errorDefinition.message.apply(null, args);\n    } else {\n      throw new Error(\"Invalid error definition for \".concat(errorDefinition.name));\n    }\n\n    this.stack = \"\".concat(this.message, \"\\n\").concat(new Error().stack);\n  };\n\n  NodeError.prototype = Object.create(parent.prototype);\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\n  parent[errorDefinition.name] = NodeError;\n\n  if (errorDefinition.errors) {\n    // eslint-disable-next-line no-use-before-define\n    childDefinitions(NodeError, errorDefinition.errors);\n  }\n\n  return NodeError;\n}; // TODO Try to get rid of this and copy the body into the callers.\n\n\nvar childDefinitions = function childDefinitions(parent, children) {\n  _.each(children, child => traverseNode(parent, child));\n};\n\nvar traverseRoot = function traverseRoot(parent, errorsDefinition) {\n  childDefinitions(parent, errorsDefinition);\n  return parent;\n};\n\nvar bitcore = {};\n\nbitcore.Error = function () {\n  this.message = 'Internal error';\n  this.stack = \"\".concat(this.message, \"\\n\").concat(new Error().stack);\n};\n\nbitcore.Error.prototype = Object.create(Error.prototype);\nbitcore.Error.prototype.name = 'bitcore.Error';\ntraverseRoot(bitcore.Error, data);\n\nbitcore.Error.extend = function (spec) {\n  return traverseNode(bitcore.Error, spec);\n};\n\nvar errors = bitcore.Error;\nvar preconditions = {\n  checkState(condition, message) {\n    if (!condition) {\n      throw new errors.InvalidState(message);\n    }\n  },\n\n  checkArgument(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\n    }\n  },\n\n  checkArgumentType(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        if (!Buffer.isBuffer(argument)) {\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\n        } // eslint-disable-next-line valid-typeof\n\n      } else if (typeof argument !== type) {\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\n      }\n    } else if (!(argument instanceof type)) {\n      throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n    }\n  }\n\n};\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\n\nvar Base58 = function Base58(obj) {\n  if (!(this instanceof Base58)) {\n    return new Base58(obj);\n  }\n\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58.validCharacters = function validCharacters(chars) {\n  if (Buffer.isBuffer(chars)) {\n    chars = chars.toString();\n  }\n\n  return _.every(_.map(chars, char => _.includes(ALPHABET, char)));\n};\n\nBase58.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58.encode = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Input should be a buffer');\n  }\n\n  return bs58.encode(buf);\n};\n\nBase58.decode = function (str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n\n  return Buffer.from(bs58.decode(str));\n};\n\nBase58.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.fromString = function (str) {\n  var buf = Base58.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nBase58.prototype.toString = function () {\n  return Base58.encode(this.buf);\n};\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\n\n\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n/**\n * @namespace JSUtil\n */\n\n\nvar JSUtil = {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON: function isValidJSON(arg) {\n    var parsed;\n\n    if (!_.isString(arg)) {\n      return false;\n    }\n\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n\n    if (typeof parsed === 'object') {\n      return true;\n    }\n\n    return false;\n  },\n  isHexa,\n  isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray(array) {\n    return [].concat(array);\n  },\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable: function defineImmutable(target, values) {\n    Object.keys(values).forEach(key => {\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  },\n\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber: function isNaturalNumber(value) {\n    return typeof value === 'number' && Number.isFinite(value) && Math.floor(value) === value && value >= 0;\n  }\n};\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var length = a.length;\n\n  for (var i = 0; i < length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar BufferUtil = {\n  /**\n   * Fill a buffer with a value.\n   *\n   * @param {Buffer} buff\n   * @param {number} value\n   * @return {Buffer}\n   */\n  fill: function fill(buff, value) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    preconditions.checkArgumentType(value, 'number', 'value');\n    var length = buff.length;\n\n    for (var i = 0; i < length; i += 1) {\n      buff[i] = value;\n    }\n\n    return buff;\n  },\n\n  /**\n   * Return a copy of a buffer\n   *\n   * @param {Buffer} original\n   * @return {Buffer}\n   */\n  copy(original) {\n    var buff = Buffer.alloc(original.length);\n    original.copy(buff);\n    return buff;\n  },\n\n  /**\n   * Returns true if the given argument is an instance of a buffer. Tests for\n   * both node's Buffer and Uint8Array\n   *\n   * @param {*} arg\n   * @return {boolean}\n   */\n  isBuffer: function isBuffer(arg) {\n    return Buffer.isBuffer(arg) || arg instanceof Uint8Array;\n  },\n\n  /**\n   * Returns a zero-filled byte array\n   *\n   * @param {number} bytes\n   * @return {Buffer}\n   */\n  emptyBuffer: function emptyBuffer(bytes) {\n    preconditions.checkArgumentType(bytes, 'number', 'bytes');\n    var result = Buffer.alloc(bytes);\n\n    for (var i = 0; i < bytes; i += 1) {\n      result.write('\\0', i);\n    }\n\n    return result;\n  },\n\n  /**\n   * Concatenates a buffer\n   *\n   * Shortcut for <tt>Buffer.concat</tt>\n   */\n  concat: Buffer.concat,\n  equals,\n  equal: equals,\n\n  /**\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\n    preconditions.checkArgumentType(integer, 'number', 'integer');\n    return Buffer.from([integer & 0xff]);\n  },\n\n  /**\n   * Transform a 4-byte integer into a Buffer of length 4.\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsBuffer: function integerAsBuffer(integer) {\n    preconditions.checkArgumentType(integer, 'number', 'integer');\n    var bytes = [];\n    bytes.push(integer >> 24 & 0xff);\n    bytes.push(integer >> 16 & 0xff);\n    bytes.push(integer >> 8 & 0xff);\n    bytes.push(integer & 0xff);\n    return Buffer.from(bytes);\n  },\n\n  /**\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\n   *\n   * @param {Buffer} buff\n   * @return {number}\n   */\n  integerFromBuffer: function integerFromBuffer(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff[0] << 24 | buff[1] << 16 | buff[2] << 8 | buff[3];\n  },\n\n  /**\n   * Transforms the first byte of an array into a number ranging from -128 to 127\n   * @param {Buffer} buff\n   * @return {number}\n   */\n  integerFromSingleByteBuffer: function integerFromBuffer(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff[0];\n  },\n\n  /**\n   * Transforms a buffer into a string with a number in hexa representation\n   *\n   * Shorthand for <tt>buffer.toString('hex')</tt>\n   *\n   * @param {Buffer} buff\n   * @return {string}\n   */\n  bufferToHex: function bufferToHex(buff) {\n    preconditions.checkArgumentType(buff, 'Buffer', 'buffer');\n    return buff.toString('hex');\n  },\n\n  /**\n   * Reverse a buffer\n   * @param {Buffer} param\n   * @return {Buffer}\n   */\n  reverse: function reverse(param) {\n    var ret = Buffer.alloc(param.length);\n\n    for (var i = 0; i < param.length; i += 1) {\n      ret[i] = param[param.length - i - 1];\n    }\n\n    return ret;\n  },\n\n  /**\n   * Transforms an hexa encoded string into a Buffer with binary values\n   *\n   * Shorthand for <tt>Buffer(string, 'hex')</tt>\n   *\n   * @param {string} string\n   * @return {Buffer}\n   */\n  hexToBuffer: function hexToBuffer(string) {\n    assert(JSUtil.isHexa(string));\n    return Buffer.from(string, 'hex');\n  }\n};\nBufferUtil.NULL_HASH = BufferUtil.fill(Buffer.alloc(32), 0);\nBufferUtil.EMPTY_BUFFER = Buffer.alloc(0);\nvar Hash = {};\n\nHash.sha1 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha1().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha256().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.ripemd160().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha256ripemd160 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  var digest = hash.sha512().update(buf).digest('hex');\n  return Buffer.from(digest, 'hex');\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function (hashf, data, key) {\n  // http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  // http://tools.ietf.org/html/rfc4868#section-2\n  preconditions.checkArgument(BufferUtil.isBuffer(data));\n  preconditions.checkArgument(BufferUtil.isBuffer(key));\n  preconditions.checkArgument(hashf.blocksize);\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var oKey = Buffer.alloc(blocksize);\n  oKey.fill(0x5c);\n  var iKey = Buffer.alloc(blocksize);\n  iKey.fill(0x36);\n  var oKeyPad = Buffer.alloc(blocksize);\n  var iKeyPad = Buffer.alloc(blocksize);\n\n  for (var i = 0; i < blocksize; i += 1) {\n    oKeyPad[i] = oKey[i] ^ key[i];\n    iKeyPad[i] = iKey[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([oKeyPad, hashf(Buffer.concat([iKeyPad, data]))]));\n};\n\nHash.sha256hmac = function (data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function (data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n\nvar Base58Check = function Base58Check(obj) {\n  if (!(this instanceof Base58Check)) return new Base58Check(obj);\n\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58Check.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58Check.validChecksum = function validChecksum(data, checksum) {\n  if (_.isString(data)) {\n    data = Buffer.from(Base58.decode(data));\n  }\n\n  if (_.isString(checksum)) {\n    checksum = Buffer.from(Base58.decode(checksum));\n  }\n\n  if (!checksum) {\n    checksum = data.slice(-4);\n    data = data.slice(0, -4);\n  }\n\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\n};\n\nBase58Check.decode = function (s) {\n  if (typeof s !== 'string') throw new Error('Input must be a string');\n  var buf = Buffer.from(Base58.decode(s));\n  if (buf.length < 4) throw new Error('Input string too short');\n  var data = buf.slice(0, -4);\n  var csum = buf.slice(-4);\n  var hash = Hash.sha256sha256(data);\n  var hash4 = hash.slice(0, 4);\n  if (csum.toString('hex') !== hash4.toString('hex')) throw new Error('Checksum mismatch');\n  return data;\n};\n\nBase58Check.checksum = function (buff) {\n  return Hash.sha256sha256(buff).slice(0, 4);\n};\n\nBase58Check.encode = function (buf) {\n  if (!Buffer.isBuffer(buf)) throw new Error('Input must be a buffer');\n  var checkedBuf = Buffer.alloc(buf.length + 4);\n  var hash = Base58Check.checksum(buf);\n  buf.copy(checkedBuf);\n  hash.copy(checkedBuf, buf.length);\n  return Base58.encode(checkedBuf);\n};\n\nBase58Check.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.fromString = function (str) {\n  var buf = Base58Check.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nBase58Check.prototype.toString = function () {\n  return Base58Check.encode(this.buf);\n};\n\nvar networks = [];\nvar networkMaps = {};\n/**\n * A network is merely a map containing values that correspond to version\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\n * (a.k.a. \"mainnet\") and \"testnet\".\n * @constructor\n */\n\nfunction Network() {}\n\nNetwork.prototype.toString = function toString() {\n  return this.name;\n};\n/**\n * @function\n * @member Networks#get\n * Retrieves the network associated with a magic number or string.\n * @param {string|number|Network} arg\n * @param {string|Array} keys - if set, only check if the magic number associated with this name\n *   matches\n * @return Network\n */\n\n\nfunction get(arg, keys) {\n  if (~networks.indexOf(arg)) {\n    return arg;\n  }\n\n  if (keys) {\n    if (!_.isArray(keys)) {\n      keys = [keys];\n    }\n\n    var index = networks.findIndex(network => _.some(keys, key => network[key] === arg));\n\n    if (index !== -1) {\n      return networks[index];\n    }\n\n    return undefined;\n  }\n\n  return networkMaps[arg];\n}\n/**\n * @function\n * @member Networks#add\n * Will add a custom Network\n * @param {Object} data\n * @param {string} data.name - The name of the network\n * @param {string} data.alias - The aliased name of the network\n * @param {Number} data.pubkeyhash - The publickey hash prefix\n * @param {Number} data.privatekey - The privatekey prefix\n * @param {Number} data.scripthash - The scripthash prefix\n * @param {Number} data.xpubkey - The extended public key magic\n * @param {Number} data.xprivkey - The extended private key magic\n * @param {Number} data.networkMagic - The network magic number\n * @param {Number} data.port - The network port\n * @param {Array}  data.dnsSeeds - An array of dns seeds\n * @return Network\n */\n\n\nfunction addNetwork(data) {\n  var network = new Network();\n  JSUtil.defineImmutable(network, {\n    name: data.name,\n    alias: data.alias,\n    pubkeyhash: data.pubkeyhash,\n    privatekey: data.privatekey,\n    scripthash: data.scripthash,\n    xpubkey: data.xpubkey,\n    xprivkey: data.xprivkey\n  });\n\n  if (data.networkMagic) {\n    JSUtil.defineImmutable(network, {\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\n    });\n  }\n\n  if (data.port) {\n    JSUtil.defineImmutable(network, {\n      port: data.port\n    });\n  }\n\n  if (data.dnsSeeds) {\n    JSUtil.defineImmutable(network, {\n      dnsSeeds: data.dnsSeeds\n    });\n  }\n\n  _.each(network, value => {\n    if (!_.isUndefined(value) && !_.isObject(value)) {\n      networkMaps[value] = network;\n    }\n  });\n\n  networks.push(network);\n  return network;\n}\n/**\n * @function\n * @member Networks#remove\n * Will remove a custom network\n * @param {Network} network\n */\n\n\nfunction removeNetwork(network) {\n  for (var i = 0; i < networks.length; i += 1) {\n    if (networks[i] === network) {\n      networks.splice(i, 1);\n    }\n  }\n\n  Object.keys(networkMaps).forEach(objectKey => {\n    if (networkMaps[objectKey] === network) {\n      delete networkMaps[objectKey];\n    }\n  });\n}\n\naddNetwork({\n  name: 'livenet',\n  alias: 'mainnet',\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  xpubkey: 0x0488b21e,\n  xprivkey: 0x0488ade4,\n  networkMagic: 0xf9beb4d9,\n  port: 8333,\n  dnsSeeds: ['seed.bitcoin.sipa.be', 'dnsseed.bluematt.me', 'dnsseed.bitcoin.dashjr.org', 'seed.bitcoinstats.com', 'seed.bitnodes.io', 'bitseed.xf2.org']\n});\n/**\n * @instance\n * @member Networks#livenet\n */\n\nvar livenet = get('livenet');\naddNetwork({\n  name: 'testnet',\n  alias: 'regtest',\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394\n});\n/**\n * @instance\n * @member Networks#testnet\n */\n\nvar testnet = get('testnet'); // Add configurable values for testnet/regtest\n\nvar TESTNET = {\n  PORT: 18333,\n  NETWORK_MAGIC: BufferUtil.integerAsBuffer(0x0b110907),\n  DNS_SEEDS: ['testnet-seed.bitcoin.petertodd.org', 'testnet-seed.bluematt.me', 'testnet-seed.alexykot.me', 'testnet-seed.bitcoin.schildbach.de']\n};\nObject.keys(TESTNET).forEach(objectKey => {\n  if (!_.isObject(TESTNET[objectKey])) {\n    networkMaps[TESTNET[objectKey]] = testnet;\n  }\n});\nvar REGTEST = {\n  PORT: 18444,\n  NETWORK_MAGIC: BufferUtil.integerAsBuffer(0xfabfb5da),\n  DNS_SEEDS: []\n};\nObject.keys(REGTEST).forEach(objectKey => {\n  if (!_.isObject(REGTEST[objectKey])) {\n    networkMaps[REGTEST[objectKey]] = testnet;\n  }\n});\nObject.defineProperty(testnet, 'port', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.PORT;\n    }\n\n    return TESTNET.PORT;\n  }\n\n});\nObject.defineProperty(testnet, 'networkMagic', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.NETWORK_MAGIC;\n    }\n\n    return TESTNET.NETWORK_MAGIC;\n  }\n\n});\nObject.defineProperty(testnet, 'dnsSeeds', {\n  enumerable: true,\n  configurable: false,\n\n  get() {\n    if (this.regtestEnabled) {\n      return REGTEST.DNS_SEEDS;\n    }\n\n    return TESTNET.DNS_SEEDS;\n  }\n\n});\n/**\n * @function\n * @member Networks#enableRegtest\n * Will enable regtest features for testnet\n */\n\nfunction enableRegtest() {\n  testnet.regtestEnabled = true;\n}\n/**\n * @function\n * @member Networks#disableRegtest\n * Will disable regtest features for testnet\n */\n\n\nfunction disableRegtest() {\n  testnet.regtestEnabled = false;\n}\n/**\n * @namespace Networks\n */\n\n\nvar Networks = {\n  add: addNetwork,\n  remove: removeNetwork,\n  defaultNetwork: livenet,\n  livenet,\n  mainnet: livenet,\n  testnet,\n  get,\n  enableRegtest,\n  disableRegtest\n};\n\nvar reversebuf = function reversebuf(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function (n) {\n  preconditions.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function (str, base) {\n  preconditions.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\n\n\nBN.fromSM = function (buf, opts) {\n  var ret;\n\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n\n  if (opts) {\n    endian = opts.endian;\n  }\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] &= 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n\n  return ret;\n};\n\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function (opts) {\n  var buf;\n  var hex;\n\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] |= 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\n\n\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  preconditions.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\n\n\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function (buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n\n  for (var _i = 0; _i < size - natlen; _i += 1) {\n    rbuf[_i] = 0;\n  }\n\n  return rbuf;\n};\n\nvar ec = elliptic.curves.secp256k1;\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\n\nvar Point = function Point(x, y, isRed) {\n  var point;\n\n  try {\n    point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid point on curve');\n  }\n\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\n\nPoint.fromX = function fromX(odd, x) {\n  var point;\n\n  try {\n    point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid x value for curve.');\n  }\n\n  point.validate();\n  return point;\n};\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\n\n\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\n\n\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\n\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\n\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\n\n\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve.');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  } // todo: needs test case\n\n\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return BufferUtil.concat([prefix, xbuf]);\n}; //      \n\n\nvar Random = {};\n\nRandom.getRandomBufferNode = function (size) {\n  return randomBytes(size);\n};\n\nRandom.getRandomBufferBrowser = function (size) {\n  var windowCrypto;\n\n  if (window.crypto && window.crypto.getRandomValues) {\n    windowCrypto = window.crypto;\n  } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n    // internet explorer\n    windowCrypto = window.msCrypto;\n  } else {\n    throw new Error('window crypto.getRandomValues not available');\n  }\n\n  var bbuf = new Uint8Array(size);\n  windowCrypto.getRandomValues(bbuf);\n  var buf = Buffer.from(bbuf);\n  return buf;\n};\n/* secure random bytes that sometimes throws an error due to lack of entropy */\n\n\nRandom.getRandomBuffer = function (size) {\n  if (typeof window !== 'undefined' && (typeof window.crypto !== 'undefined' || typeof window.msCrypto !== 'undefined')) {\n    return Random.getRandomBufferBrowser(size);\n  }\n\n  return Random.getRandomBufferNode(size);\n};\n/* insecure random bytes, but it never fails */\n\n\nRandom.getPseudoRandomBuffer = function (size) {\n  var b32 = 0x100000000;\n  var b = Buffer.alloc(size);\n  var r = 0;\n\n  for (var i = 0; i <= size; i += 1) {\n    var j = Math.floor(i / 4);\n    var k = i - j * 4;\n\n    if (k === 0) {\n      r = Math.random() * b32;\n      b[i] = r & 0xff;\n    } else {\n      b[i] = (r >>>= 8) & 0xff;\n    }\n  }\n\n  return b;\n};\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\n\n\nfunction PrivateKey(data, network) {\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network); // validation\n\n\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n\n  if (typeof info.network === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n  return this;\n}\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\n\n\nPrivateKey.prototype._classifyArguments = function (data, network) {\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  }; // detect type of data\n\n  if (_.isUndefined(data) || _.isNull(data)) {\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network) {\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof data === 'string') {\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n\n  return info;\n};\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\n\n\nPrivateKey._getRandomBN = function () {\n  var condition;\n  var bn;\n\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n\n  return bn;\n};\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformBuffer = function (buf, network) {\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n  return info;\n};\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\n\n\nPrivateKey._transformBNBuffer = function (buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformWIF = function (str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\n\n\nPrivateKey.fromBuffer = function (arg, network) {\n  return new PrivateKey(arg, network);\n};\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformObject = function (json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn,\n    network,\n    compressed: json.compressed\n  };\n};\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromWIF = function (str) {\n  preconditions.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\nPrivateKey.fromString = PrivateKey.fromWIF;\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\n\nPrivateKey.fromObject = function (obj) {\n  preconditions.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromRandom = function (network) {\n  var bn = PrivateKey._getRandomBN();\n\n  return new PrivateKey(bn, network);\n};\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\n\nPrivateKey.getValidationError = function (data, network) {\n  var error;\n\n  try {\n    // #weirdstuff Refactor.\n    // eslint-disable-next-line no-new\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\n\n\nPrivateKey.isValid = function (data, network) {\n  if (!data) {\n    return false;\n  }\n\n  return !PrivateKey.getValidationError(data, network);\n};\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\n\n\nPrivateKey.prototype.toString = function () {\n  return this.toBuffer().toString('hex');\n};\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\n\n\nPrivateKey.prototype.toWIF = function () {\n  var buf;\n\n  if (this.compressed) {\n    buf = Buffer.concat([Buffer.from([this.network.privatekey]), this.bn.toBuffer({\n      size: 32\n    }), Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([this.network.privatekey]), this.bn.toBuffer({\n      size: 32\n    })]);\n  }\n\n  return Base58Check.encode(buf);\n};\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\n\n\nPrivateKey.prototype.toBigNumber = function () {\n  return this.bn;\n};\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBuffer = function () {\n  // TODO: use `return this.bn.toBuffer({ size: 32 })` in v1.0.0\n  return this.bn.toBuffer();\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBufferNoPadding = function () {\n  return this.bn.toBuffer();\n};\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\n\n\nPrivateKey.prototype.toPublicKey = function () {\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n\n  return this._pubkey;\n};\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\n\n\nPrivateKey.prototype.toAddress = function (network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n/**\n * @returns {Object} A plain object representation\n */\n\n\nPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON;\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\n\nPrivateKey.prototype.inspect = function () {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return \"<PrivateKey: \".concat(this.toString(), \", network: \").concat(this.network).concat(uncompressed, \">\");\n};\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\n\n\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  preconditions.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra); // validation\n\n\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Networks.defaultNetwork\n  });\n  return this;\n}\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\n\n\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  }; // detect type of data\n\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Networks.get(extra.network);\n  }\n\n  return info;\n};\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isPrivateKey = function (param) {\n  return param instanceof PrivateKey;\n};\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformPrivateKey = function (privkey) {\n  preconditions.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformDER = function (buf, strict) {\n  preconditions.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n\n  return info;\n};\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformX = function (odd, x) {\n  preconditions.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPrivateKey = function (privkey) {\n  preconditions.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n\n  var info = PublicKey._transformPrivateKey(privkey);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromBuffer = function (buf, strict) {\n  preconditions.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n\n  var info = PublicKey._transformDER(buf, strict);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\nPublicKey.fromDER = PublicKey.fromBuffer;\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\nPublicKey.fromPoint = function (point, compressed) {\n  preconditions.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromString = function (str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n\n  var info = PublicKey._transformDER(buf);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\n\n\nPublicKey.getValidationError = function (data) {\n  var error;\n\n  try {\n    // #weirdstuff Refactor.\n    // eslint-disable-next-line no-new\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\n\n\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n/**\n * @returns {Object} A plain object of the PublicKey\n */\n\n\nPublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON;\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\n\nPublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  }\n\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return Buffer.concat([prefix, xbuf]);\n};\n\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER;\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\n\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\n\n\nPublicKey.prototype.toAddress = function (network) {\n  return Address.fromPublicKey(this, network || this.network);\n};\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\n\n\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\n\n\nPublicKey.prototype.inspect = function () {\n  return \"<PublicKey: \".concat(this.toString()).concat(this.compressed ? '' : ', uncompressed', \">\");\n};\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n\n  if (_.isUndefined(buf)) {\n    return undefined;\n  }\n\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf\n    });\n  } else if (_.isString(buf)) {\n    var b = Buffer.from(buf, 'hex');\n\n    if (b.length * 2 !== buf.length) {\n      throw new TypeError('Invalid hex string');\n    }\n\n    this.set({\n      buf: b\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function () {\n  return this.pos >= this.buf.length;\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function (len) {\n  preconditions.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos += len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function () {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function () {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos += 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function () {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos += 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function () {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos += 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function () {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function () {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readInt32LE = function () {\n  var val = this.buf.readInt32LE(this.pos);\n  this.pos += 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function () {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos += 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function () {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = first * 0x100000000 + second; // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n\n  var bn;\n\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n\n  this.pos += 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xfd:\n      return this.readUInt16LE();\n\n    case 0xfe:\n      return this.readUInt32LE();\n\n    case 0xff:\n      {\n        var n = this.readUInt64LEBN().toNumber();\n\n        if (n <= 2 ** 53) {\n          return n;\n        }\n\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n\n    default:\n      return first;\n  }\n};\n/**\n * reads a length prepended buffer\n */\n\n\nBufferReader.prototype.readVarLengthBuffer = function () {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  preconditions.checkState(buf.length === len, \"Invalid length while reading varlength buffer. Expected: \".concat(len, \", Received: \").concat(buf.length));\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function () {\n  var first = this.buf.readUInt8(this.pos);\n\n  switch (first) {\n    case 0xfd:\n      return this.read(1 + 2);\n\n    case 0xfe:\n      return this.read(1 + 4);\n\n    case 0xff:\n      return this.read(1 + 8);\n\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xfd:\n      return new BN(this.readUInt16LE());\n\n    case 0xfe:\n      return new BN(this.readUInt32LE());\n\n    case 0xff:\n      return this.readUInt64LEBN();\n\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function () {\n  var buf = Buffer.alloc(this.buf.length);\n\n  for (var i = 0; i < buf.length; i += 1) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function (len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos += len;\n  return BufferUtil.reverse(buf);\n};\n\nvar BufferWriter = function BufferWriter(obj) {\n  if (!(this instanceof BufferWriter)) return new BufferWriter(obj);\n  if (obj) this.set(obj);else this.bufs = [];\n};\n\nBufferWriter.prototype.set = function (obj) {\n  this.bufs = obj.bufs || this.bufs || [];\n  return this;\n};\n\nBufferWriter.prototype.toBuffer = function () {\n  return this.concat();\n};\n\nBufferWriter.prototype.concat = function () {\n  return Buffer.concat(this.bufs);\n};\n\nBufferWriter.prototype.write = function (buf) {\n  assert(BufferUtil.isBuffer(buf));\n  this.bufs.push(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeReverse = function (buf) {\n  assert(BufferUtil.isBuffer(buf));\n  this.bufs.push(BufferUtil.reverse(buf));\n  return this;\n};\n\nBufferWriter.prototype.writeUInt8 = function (n) {\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16BE = function (n) {\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16LE = function (n) {\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32BE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeInt32LE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32LE = function (n) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64BEBN = function (bn) {\n  var buf = bn.toBuffer({\n    size: 8\n  });\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64LEBN = function (bn) {\n  var buf = bn.toBuffer({\n    size: 8\n  });\n  this.writeReverse(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintNum = function (n) {\n  var buf = BufferWriter.varintBufNum(n);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintBN = function (bn) {\n  var buf = BufferWriter.varintBufBN(bn);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.varintBufNum = function (n) {\n  var buf;\n\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    buf = Buffer.alloc(1 + 8);\n    buf.writeUInt8(255, 0);\n    buf.writeInt32LE(n & -1, 1);\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n  }\n\n  return buf;\n};\n\nBufferWriter.varintBufBN = function (bn) {\n  var buf;\n  var n = bn.toNumber();\n\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    var bw = new BufferWriter();\n    bw.writeUInt8(255);\n    bw.writeUInt64LEBN(bn);\n    buf = bw.concat();\n  }\n\n  return buf;\n};\n\nfunction Opcode(num) {\n  if (!(this instanceof Opcode)) {\n    return new Opcode(num);\n  }\n\n  var value;\n\n  if (_.isNumber(num)) {\n    value = num;\n  } else if (_.isString(num)) {\n    value = Opcode.map[num];\n  } else {\n    throw new TypeError(\"Unrecognized num type: \\\"\".concat(typeof num, \"\\\" for Opcode\"));\n  }\n\n  JSUtil.defineImmutable(this, {\n    num: value\n  });\n  return this;\n}\n\nOpcode.fromBuffer = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf));\n  return new Opcode(Number(\"0x\".concat(buf.toString('hex'))));\n};\n\nOpcode.fromNumber = function (num) {\n  preconditions.checkArgument(_.isNumber(num));\n  return new Opcode(num);\n};\n\nOpcode.fromString = function (str) {\n  preconditions.checkArgument(_.isString(str));\n  var value = Opcode.map[str];\n\n  if (typeof value === 'undefined') {\n    throw new TypeError('Invalid opcodestr');\n  }\n\n  return new Opcode(value);\n};\n\nOpcode.prototype.toHex = function () {\n  return this.num.toString(16);\n};\n\nOpcode.prototype.toBuffer = function () {\n  return Buffer.from(this.toHex(), 'hex');\n};\n\nOpcode.prototype.toNumber = function () {\n  return this.num;\n};\n\nOpcode.prototype.toString = function () {\n  var str = Opcode.reverseMap[this.num];\n\n  if (typeof str === 'undefined') {\n    throw new Error('Opcode does not have a string representation');\n  }\n\n  return str;\n};\n\nOpcode.smallInt = function (n) {\n  preconditions.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\n  preconditions.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\n\n  if (n === 0) {\n    return Opcode('OP_0');\n  }\n\n  return new Opcode(Opcode.map.OP_1 + n - 1);\n};\n\nOpcode.map = {\n  // push value\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  // control\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  // stack ops\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  // splice ops\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  // bit logic\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  // numeric\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  // crypto\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  // expansion\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_NOP3: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  // template matching params\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255\n};\nOpcode.reverseMap = [];\nObject.keys(Opcode.map).forEach(k => {\n  Opcode.reverseMap[Opcode.map[k]] = k;\n}); // Easier access to opcodes\n\n_.extend(Opcode, Opcode.map);\n/**\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\n */\n\n\nOpcode.isSmallIntOp = function (opcode) {\n  if (opcode instanceof Opcode) {\n    opcode = opcode.toNumber();\n  }\n\n  return opcode === Opcode.map.OP_0 || opcode >= Opcode.map.OP_1 && opcode <= Opcode.map.OP_16;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Script opcode\n */\n\n\nOpcode.prototype.inspect = function () {\n  return \"<Opcode: \".concat(this.toString(), \", hex: \").concat(this.toHex(), \", decimal: \").concat(this.num, \">\");\n};\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r,\n      s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; // public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; // whether the recovered pubkey is compressed\n\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i += 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  preconditions.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  preconditions.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  preconditions.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = function (buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n};\n\nSignature.fromBuffer = Signature.fromDER; // The format used in a tx\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  preconditions.checkArgument(BufferUtil.isBuffer(buf), 'DER formatted signature should be a buffer');\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  preconditions.checkArgument(header === 0x30, 'Header byte should be 0x30');\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  preconditions.checkArgument(!strict || length === buflength, 'Length byte should length of what follows');\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  preconditions.checkArgument(rheader === 0x02, 'Integer byte for r should be 0x02');\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00;\n  preconditions.checkArgument(rlength === rbuf.length, 'Length of r incorrect');\n  var sheader = buf[2 + 2 + rlength + 0];\n  preconditions.checkArgument(sheader === 0x02, 'Integer byte for s should be 0x02');\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00;\n  preconditions.checkArgument(slength === sbuf.length, 'Length of s incorrect');\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  preconditions.checkArgument(length === sumlength - 2, 'Length of signature incorrect');\n  var obj = {\n    header,\n    length,\n    rheader,\n    rlength,\n    rneg,\n    rbuf,\n    r,\n    sheader,\n    slength,\n    sneg,\n    sbuf,\n    s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val -= 4;\n  }\n\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = function () {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = !!(rnbuf[0] & 0x80);\n  var sneg = !!(snbuf[0] & 0x80);\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toDER = Signature.prototype.toBuffer;\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isTxDER = function (buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n\n  var nLenR = buf[3];\n\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n\n  var nLenS = buf[5 + nLenR];\n\n  if (nLenR + nLenS + 7 !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n\n  if (nLenR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n\n  if (nLenS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options\n * or combinations thereof. Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n\n\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function () {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_FORKID = 0x40;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\n\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  }\n\n  if (from instanceof Address) {\n    return Script.fromAddress(from);\n  }\n\n  if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  }\n\n  if (typeof from === 'string') {\n    return Script.fromString(from);\n  }\n\n  if (typeof from !== 'undefined') {\n    this.set(from);\n  }\n};\n\nScript.prototype.set = function (obj) {\n  this.chunks = obj.chunks || this.chunks;\n  return this;\n};\n\nScript.fromBuffer = function (origBuffer) {\n  var script = new Script();\n  script.chunks = [];\n  var br = new BufferReader(origBuffer);\n\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n      var len = void 0;\n      var buf = void 0;\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf,\n          len,\n          opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(origBuffer.toString('hex'));\n      }\n\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function () {\n  return this.chunks.reduce((bw, chunk) => {\n    bw.writeUInt8(chunk.opcodenum);\n\n    if (chunk.buf) {\n      if (chunk.opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (chunk.opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n\n    return bw;\n  }, new BufferWriter()).concat();\n};\n\nScript.fromASM = function (str) {\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum === undefined) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i += 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1], 16),\n        opcodenum\n      });\n      i += 3;\n    } else {\n      script.chunks.push({\n        opcodenum\n      });\n      i += 1;\n    }\n  }\n\n  return script;\n};\n\nScript.fromHex = function (str) {\n  return new this(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function (str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new this(Buffer.from(str, 'hex'));\n  }\n\n  var script = new this();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      // #weirdstuff\n      if (token.startsWith('0x')) {\n        opcodenum = parseInt(token, 16);\n      } else {\n        opcodenum = parseInt(token, 10);\n      }\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum\n        });\n        i += 2;\n      } else {\n        throw new Error(\"Invalid script: \".concat(JSON.stringify(str)));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1], 10),\n        opcodenum\n      });\n      i += 3;\n    } else {\n      script.chunks.push({\n        opcodenum\n      });\n      i += 1;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype._chunkToString = function (chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = type === 'asm';\n  var str = '';\n\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      str = \"\".concat(str, \" \").concat(Opcode(opcodenum).toString());\n    } else {\n      var numstr = opcodenum.toString(16);\n\n      if (numstr.length % 2 !== 0) {\n        numstr = \"0\".concat(numstr);\n      }\n\n      if (asm) {\n        str = \"\".concat(str, \" \").concat(numstr);\n      } else {\n        str = \"\".concat(str, \" 0x\").concat(numstr);\n      }\n    }\n  } else {\n    // data chunk\n    if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      str = \"\".concat(str, \" \").concat(Opcode(opcodenum).toString());\n    }\n\n    if (chunk.len > 0) {\n      if (asm) {\n        str = \"\".concat(str, \" \").concat(chunk.buf.toString('hex'));\n      } else {\n        str = \"\".concat(str, \" \").concat(chunk.len, \" 0x\").concat(chunk.buf.toString('hex'));\n      }\n    }\n  }\n\n  return str;\n};\n\nScript.prototype.toASM = function () {\n  return this.chunks.reduce((acc, chunk) => acc + this._chunkToString(chunk, 'asm'), '').substr(1);\n};\n\nScript.prototype.toString = function () {\n  return this.chunks.reduce((acc, chunk) => acc + this._chunkToString(chunk), '').substr(1);\n};\n\nScript.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function () {\n  return \"<Script: \".concat(this.toString(), \">\");\n}; // script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\n\n\nScript.prototype.isPublicKeyHashOut = function () {\n  return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\n\n\nScript.prototype.isPublicKeyHashIn = function () {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30 && pubkeyBuf && pubkeyBuf.length) {\n      var version = pubkeyBuf[0];\n\n      if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      }\n\n      if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nScript.prototype.getPublicKey = function () {\n  preconditions.checkState(this.isPublicKeyOut(), \"Can't retrieve PublicKey from a non-PublicKey output\");\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function () {\n  preconditions.checkState(this.isPublicKeyHashOut(), \"Can't retrieve PublicKeyHash from a non-PublicKeyHash output\");\n  return this.chunks[2].buf;\n};\n/**\n * @returns {boolean} if this is a public key output script\n */\n\n\nScript.prototype.isPublicKeyOut = function () {\n  if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n\n    if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\n\n\nScript.prototype.isPublicKeyIn = function () {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a p2sh output script\n */\n\n\nScript.prototype.isScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 0x14 && buf[buf.length - 1] === Opcode.OP_EQUAL;\n};\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\n\n\nScript.prototype.isScriptHashIn = function () {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n\n    throw e;\n  }\n\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\n\n\nScript.prototype.isMultisigOut = function () {\n  return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(obj => obj.buf && BufferUtil.isBuffer(obj.buf)) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;\n};\n/**\n * @returns {boolean} if this is a multisig input script\n */\n\n\nScript.prototype.isMultisigIn = function () {\n  return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(obj => obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf));\n};\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\n\n\nScript.prototype.isDataOut = function () {\n  return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);\n};\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash or P2SH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\n\n\nScript.prototype.getData = function () {\n  if (this.isDataOut() || this.isScriptHashOut()) {\n    // #weirdstuff\n    if (this.chunks[1] === undefined) {\n      return Buffer.alloc(0);\n    }\n\n    return Buffer.from(this.chunks[1].buf);\n  }\n\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n\n  throw new Error('Unrecognized script type to get data from');\n};\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\n\n\nScript.prototype.isPushOnly = function () {\n  return this.chunks.every(chunk => chunk.opcodenum <= Opcode.OP_16);\n};\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\nScript.OP_RETURN_STANDARD_SIZE = 80;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classify = function () {\n  if (this._isInput) {\n    return this.classifyInput();\n  }\n\n  if (this._isOutput) {\n    return this.classifyOutput();\n  }\n\n  var outputType = this.classifyOutput();\n  return outputType !== Script.types.UNKNOWN ? outputType : this.classifyInput();\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyOutput = function () {\n  var keys = Object.keys(Script.outputIdentifiers);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    if (Script.outputIdentifiers[keys[i]].bind(this)()) {\n      return Script.types[keys[i]];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyInput = function () {\n  var keys = Object.keys(Script.inputIdentifiers);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    if (Script.inputIdentifiers[keys[i]].bind(this)()) {\n      return Script.types[keys[i]];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if script is one of the known types\n */\n\n\nScript.prototype.isStandard = function () {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n}; // Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\n\n\nScript.prototype.prepend = function (obj) {\n  this._addByType(obj, true);\n\n  return this;\n};\n/**\n * Compares a script with another script\n */\n\n\nScript.prototype.equals = function (script) {\n  preconditions.checkState(script instanceof Script, 'Must provide another script');\n\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n\n  var i;\n\n  for (i = 0; i < this.chunks.length; i += 1) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    }\n\n    if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\n\n\nScript.prototype.add = function (obj) {\n  this._addByType(obj, false);\n\n  return this;\n};\n\nScript.prototype._addByType = function (obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function (op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function (opcode, prepend) {\n  var op;\n\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype._addBuffer = function (buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < 2 ** 8) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < 2 ** 16) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < 2 ** 32) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error(\"You can't push that much data\");\n  }\n\n  this._insertAtPosition({\n    buf,\n    len,\n    opcodenum\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype.removeCodeseparators = function () {\n  this.chunks = this.chunks.filter(chunk => chunk.opcodenum !== Opcode.OP_CODESEPARATOR);\n  return this;\n}; // high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\n\n\nScript.buildMultisigOut = function (publicKeys, threshold, opts) {\n  preconditions.checkArgument(threshold <= publicKeys.length, 'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new this();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = publicKeys.map(PublicKey);\n  var sorted = publicKeys;\n\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, publicKey => publicKey.toString('hex'));\n  }\n\n  sorted.forEach(pKey => script.add(pKey.toBuffer()));\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script\n *   (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n// #weirdstuff - \"opts\" is never used in the function, but if we remove it tests go red. We should\n// look into this in more detail and try to figure out what is happening.\n// eslint-disable-next-line no-unused-vars\n\n\nScript.buildMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  preconditions.checkArgument(_.isArray(pubkeys));\n  preconditions.checkArgument(_.isNumber(threshold));\n  preconditions.checkArgument(_.isArray(signatures));\n  var s = new this();\n  s.add(Opcode.OP_0);\n  signatures.forEach(signature => {\n    preconditions.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n  return s;\n};\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to\n * spend.\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script\n *   (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n\n\nScript.buildP2SHMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  preconditions.checkArgument(_.isArray(pubkeys));\n  preconditions.checkArgument(_.isNumber(threshold));\n  preconditions.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new this();\n  s.add(Opcode.OP_0);\n  signatures.forEach(signature => {\n    preconditions.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\n\n\nScript.buildPublicKeyHashOut = function (to) {\n  preconditions.checkArgument(!_.isUndefined(to));\n  preconditions.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n\n  var s = new this();\n  s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\n\n\nScript.buildPublicKeyOut = function (pubkey) {\n  preconditions.checkArgument(pubkey instanceof PublicKey);\n  var s = new this();\n  s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);\n  return s;\n};\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\n\n\nScript.buildDataOut = function (data, encoding) {\n  preconditions.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n\n  var s = new this();\n  s.add(Opcode.OP_RETURN);\n\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n\n  return s;\n};\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\n\n\nScript.buildScriptHashOut = function (script) {\n  preconditions.checkArgument(script instanceof Script || script instanceof Address && script.isPayToScriptHash());\n  var s = new this().add(Opcode.OP_HASH160).add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);\n  s._network = script._network || script.network;\n  return s;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical\n *   encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyIn = function (signature, sigtype) {\n  preconditions.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  preconditions.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new this();\n  script.add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)]));\n  return script;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical\n *   encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyHashIn = function (publicKey, signature, sigtype) {\n  preconditions.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  preconditions.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new this().add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)])).add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n/**\n * @returns {Script} an empty script\n */\n\n\nScript.empty = function () {\n  return new this();\n};\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\n\n\nScript.prototype.toScriptHashOut = function () {\n  return Script.buildScriptHashOut(this);\n};\n/**\n * @return {Script} an output script built from the address\n */\n\n\nScript.fromAddress = function (address) {\n  address = new Address(address);\n\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  }\n\n  if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  }\n\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\n\n\nScript.prototype.getAddressInfo = function () {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  }\n\n  if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  }\n\n  var info = this._getOutputAddressInfo();\n\n  if (!info) {\n    return this._getInputAddressInfo();\n  }\n\n  return info;\n};\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getOutputAddressInfo = function () {\n  var info = {};\n\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getInputAddressInfo = function () {\n  var info = {};\n\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\n\n\nScript.prototype.toAddress = function (network) {\n  var info = this.getAddressInfo();\n\n  if (!info) {\n    return false;\n  }\n\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\n\n\nScript.prototype.findAndDelete = function (script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n\n  for (var i = 0; i < this.chunks.length; i += 1) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n\n  return this;\n};\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\n\n\nScript.prototype.checkMinimalPush = function (i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n\n  if (!buf) {\n    return true;\n  }\n\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  }\n\n  if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  }\n\n  if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  }\n\n  if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  }\n\n  if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  }\n\n  if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n\n  return true;\n};\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\n\n\nScript.prototype._decodeOP_N = function (opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  }\n\n  if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  }\n\n  throw new Error(\"Invalid opcode: \".concat(JSON.stringify(opcode)));\n};\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\n\n\nScript.prototype.getSignatureOperationsCount = function (accurate) {\n  accurate = _.isUndefined(accurate) ? true : accurate;\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  self.chunks.forEach(chunk => {\n    var opcode = chunk.opcodenum;\n\n    if (opcode === Opcode.OP_CHECKSIG || opcode === Opcode.OP_CHECKSIGVERIFY) {\n      n += 1;\n    } else if (opcode === Opcode.OP_CHECKMULTISIG || opcode === Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n\n    lastOpcode = opcode;\n  });\n  return n;\n};\n\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n/**\n * Instantiate an address from an address String or Buffer, a public key or\n * script hash Buffer, or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this\n * constructor is an `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string) or\n * `Address.PayToScriptHash` (the string `'scripthash'`). The network is an\n * instance of {@link Network}. You can quickly check whether an address is of a\n * given kind by using the methods `isPayToPublicKeyHash` and\n * `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\n\nclass Address {\n  constructor(data, network, type) {\n    if (!(this instanceof Address)) {\n      return new Address(data, network, type);\n    }\n\n    if (_.isArray(data) && _.isNumber(network)) {\n      return Address.createMultisig(data, network, type);\n    }\n\n    if (data instanceof Address) {\n      // Immutable instance\n      return data;\n    }\n\n    preconditions.checkArgument(data, 'Address data required in first argument.', 'guide/address.html');\n\n    if (network && !Networks.get(network)) {\n      throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n    }\n\n    if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash) {\n      throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n    }\n\n    var info = Address._classifyArguments(data, network, type); // set defaults if not set\n\n\n    info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n    info.type = info.type || type || Address.PayToPublicKeyHash;\n    JSUtil.defineImmutable(this, {\n      hashBuffer: info.hashBuffer,\n      network: info.network,\n      type: info.type\n    });\n  }\n  /**\n   * Internal function used to split different kinds of arguments of the constructor\n   * @param {*} data - The encoded data in various formats\n   * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n   */\n\n\n  static _classifyArguments(data, network, type) {\n    // transform and validate input data\n    if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n      return Address._transformHash(data);\n    }\n\n    if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n      return Address._transformBuffer(data, network, type);\n    }\n\n    if (data instanceof PublicKey) {\n      return Address._transformPublicKey(data);\n    } // eslint-disable-next-line no-use-before-define\n\n\n    if (data instanceof Script) {\n      return Address._transformScript(data, network);\n    }\n\n    if (typeof data === 'string') {\n      return Address._transformString(data, network, type, Address.DefaultFormat);\n    }\n\n    if (_.isObject(data)) {\n      return Address._transformObject(data);\n    }\n\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  /**\n   * @param {Buffer} hash - An instance of a hash Buffer\n   * @returns {Object} An object with keys: hashBuffer\n   * @private\n   */\n\n\n  static _transformHash(hash) {\n    var info = {};\n\n    if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n      throw new TypeError('Address supplied is not a buffer.');\n    }\n\n    if (hash.length !== 20) {\n      throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n    }\n\n    info.hashBuffer = hash;\n    return info;\n  }\n  /**\n   * Deserializes an address serialized through `Address#toObject()`\n   * @param {Object} data\n   * @param {string} data.hash - the hash that this address encodes\n   * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n   * @param {Network=} data.network - the name of the network associated\n   * @return {Address}\n   */\n\n\n  static _transformObject(data) {\n    preconditions.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n    preconditions.checkArgument(data.type, 'Must provide a `type` property');\n    return {\n      hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n      network: Networks.get(data.network) || Networks.defaultNetwork,\n      type: data.type\n    };\n  }\n  /**\n   * Internal function to discover the network and type based on the first data byte\n   *\n   * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n   * @returns {Object} An object with keys: network and type\n   * @private\n   */\n\n\n  static _classifyFromVersion(buffer) {\n    var version = {};\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = this.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = this.PayToScriptHash;\n    }\n\n    return version;\n  }\n  /**\n   * Internal function to transform a bitcoin address buffer\n   *\n   * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n   * @param {string=} network - The network: 'livenet' or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformBuffer(buffer, network, type) {\n    var info = {};\n\n    if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n      throw new TypeError('Address supplied is not a buffer.');\n    }\n\n    if (buffer.length !== 1 + 20) {\n      throw new TypeError('Address buffers must be exactly 21 bytes.');\n    }\n\n    network = Networks.get(network);\n\n    var bufferVersion = Address._classifyFromVersion(buffer);\n\n    if (!bufferVersion.network || network && network !== bufferVersion.network) {\n      throw new TypeError('Address has mismatched network type.');\n    }\n\n    if (!bufferVersion.type || type && type !== bufferVersion.type) {\n      throw new TypeError('Address has mismatched type.');\n    }\n\n    info.hashBuffer = buffer.slice(1);\n    info.network = bufferVersion.network;\n    info.type = bufferVersion.type;\n    return info;\n  }\n  /**\n   * Internal function to transform a {@link PublicKey}\n   *\n   * @param {PublicKey} pubkey - An instance of PublicKey\n   * @returns {Object} An object with keys: hashBuffer, type\n   * @private\n   */\n\n\n  static _transformPublicKey(pubkey) {\n    var info = {};\n\n    if (!(pubkey instanceof PublicKey)) {\n      throw new TypeError('Address must be an instance of PublicKey.');\n    }\n\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n    info.type = this.PayToPublicKeyHash;\n    return info;\n  }\n  /**\n   * Internal function to transform a {@link Script} into a `info` object.\n   *\n   * @param {Script} script - An instance of Script\n   * @returns {Object} An object with keys: hashBuffer, type\n   * @private\n   */\n\n\n  static _transformScript(script, network) {\n    // eslint-disable-next-line no-use-before-define\n    preconditions.checkArgument(script instanceof Script, 'script must be a Script instance');\n    var info = script.getAddressInfo(network);\n\n    if (!info) {\n      throw new errors.Script.CantDeriveAddress(script);\n    }\n\n    return info;\n  }\n  /**\n   * Creates a P2SH address from a set of public keys and a threshold.\n   *\n   * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n   * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n   * interface.\n   *\n   * @param {Array} publicKeys - a set of public keys to create an address\n   * @param {number} threshold - the number of signatures needed to release the funds\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @return {Address}\n   */\n\n\n  static createMultisig(publicKeys, threshold, network) {\n    network = network || publicKeys[0].network || Networks.defaultNetwork; // eslint-disable-next-line no-use-before-define\n\n    return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n  }\n  /**\n   * Internal function to transform a bitcoin address string\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformString(data, network, type, format) {\n    if (typeof data !== 'string') {\n      throw new TypeError('data parameter supplied is not a string.');\n    }\n\n    data = data.trim();\n\n    if (format === this.LegacyFormat) {\n      return this._transformStringLegacy(data, network, type);\n    }\n\n    if (format === this.BitpayFormat) {\n      return this._transformStringBitpay(data, network, type);\n    }\n\n    if (format === this.CashAddrFormat) {\n      return this._transformStringCashAddr(data, network, type);\n    }\n\n    throw new TypeError('Unrecognized address format.');\n  }\n  /**\n   * Internal function to transform a bitcoin address string in legacy format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringLegacy(data, network, type) {\n    var addressBuffer = Base58Check.decode(data);\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Internal function to transform a bitcoin address string in Bitpay format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringBitpay(data, network, type) {\n    var addressBuffer = Base58Check.decode(data);\n\n    if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n      addressBuffer[0] = 0;\n    } else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n      addressBuffer[0] = 5;\n    }\n\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Internal function to transform a bitcoin address string in CashAddr format\n   *\n   * @param {string} data\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n   * @returns {Object} An object with keys: hashBuffer, network and type\n   * @private\n   */\n\n\n  static _transformStringCashAddr(data, network, type) {\n    if (!(typeof network === 'string')) {\n      network = network.toString();\n    }\n\n    var decoded = cashaddr.decode(data);\n    preconditions.checkArgument(!network || network === 'livenet' && decoded.prefix === 'bitcoincash' || network === 'testnet' && decoded.prefix === 'bchtest', 'Invalid network.');\n    preconditions.checkArgument(!type || type === this.PayToPublicKeyHash && decoded.type === 'P2PKH' || type === this.PayToScriptHash && decoded.type === 'P2SH', 'Invalid type.');\n    network = Networks.get(network || (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet'));\n    type = type || (decoded.type === 'P2PKH' ? this.PayToPublicKeyHash : this.PayToScriptHash);\n    var version = Buffer.from([network[type]]);\n    var hashBuffer = Buffer.from(decoded.hash);\n    var addressBuffer = Buffer.concat([version, hashBuffer]);\n    return this._transformBuffer(addressBuffer, network, type);\n  }\n  /**\n   * Instantiate an address from a PublicKey instance\n   *\n   * @param {PublicKey} data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromPublicKey(data, network) {\n    var info = this._transformPublicKey(data);\n\n    network = network || Networks.defaultNetwork;\n    return new Address(info.hashBuffer, network, info.type);\n  }\n  /**\n   * Instantiate an address from a ripemd160 public key hash\n   *\n   * @param {Buffer} hash - An instance of buffer of the hash\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromPublicKeyHash(hash, network) {\n    var info = this._transformHash(hash);\n\n    return new Address(info.hashBuffer, network, this.PayToPublicKeyHash);\n  }\n  /**\n   * Instantiate an address from a ripemd160 script hash\n   *\n   * @param {Buffer} hash - An instance of buffer of the hash\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromScriptHash(hash, network) {\n    preconditions.checkArgument(hash, 'hash parameter is required');\n\n    var info = this._transformHash(hash);\n\n    return new Address(info.hashBuffer, network, this.PayToScriptHash);\n  }\n  /**\n   * Builds a p2sh address paying to script. This will hash the script and\n   * use that to create the address.\n   * If you want to extract an address associated with a script instead,\n   * see {{Address#fromScript}}\n   *\n   * @param {Script} script - An instance of Script\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static payingTo(script, network) {\n    preconditions.checkArgument(script, 'script is required'); // eslint-disable-next-line no-use-before-define\n\n    preconditions.checkArgument(script instanceof Script, 'script must be instance of Script');\n    return this.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n  }\n  /**\n   * Extract address from a Script. The script must be of one\n   * of the following types: p2pkh input, p2pkh output, p2sh input\n   * or p2sh output.\n   * This will analyze the script and extract address information from it.\n   * If you want to transform any script to a p2sh Address paying\n   * to that script's hash instead, use {{Address#payingTo}}\n   *\n   * @param {Script} script - An instance of Script\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromScript(script, network) {\n    // eslint-disable-next-line no-use-before-define\n    preconditions.checkArgument(script instanceof Script, 'script must be a Script instance');\n\n    var info = this._transformScript(script, network);\n\n    return new Address(info.hashBuffer, network, info.type);\n  }\n  /**\n   * Instantiate an address from a buffer of the address\n   *\n   * @param {Buffer} buffer - An instance of buffer of the address\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromBuffer(buffer, network, type) {\n    var info = this._transformBuffer(buffer, network, type);\n\n    return new Address(info.hashBuffer, info.network, info.type);\n  }\n  /**\n   * Instantiate an address from an address string\n   *\n   * @param {string} str - An string of the bitcoin address\n   * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string=} type - The type of address: 'script' or 'pubkey'\n   * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {Address} A new valid and frozen instance of an Address\n   */\n\n\n  static fromString(str, network, type, format) {\n    format = format || this.DefaultFormat;\n\n    var info = this._transformString(str, network, type, format);\n\n    return new Address(info.hashBuffer, info.network, info.type);\n  }\n  /**\n   * Instantiate an address from an Object\n   *\n   * @param {string} json - An JSON string or Object with keys: hash, network and type\n   * @returns {Address} A new valid instance of an Address\n   */\n\n\n  static fromObject(obj) {\n    preconditions.checkState(JSUtil.isHexa(obj.hash), \"Unexpected hash, \\\"\".concat(obj.hash, \"\\\", expected to be hex.\"));\n    var hashBuffer = Buffer.from(obj.hash, 'hex');\n    return new Address(hashBuffer, obj.network, obj.type);\n  }\n  /**\n   * Will return a validation error if exists\n   *\n   * @example\n   * ```javascript\n   * // a network mismatch error\n   * var error = this.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n   * ```\n   *\n   * @param {string} data - The encoded data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string} type - The type of address: 'script' or 'pubkey'\n   * @returns {null|Error} The corresponding error message\n   */\n\n\n  static getValidationError(data, network, type) {\n    var error;\n\n    try {\n      // eslint-disable-next-line no-new\n      new Address(data, network, type);\n    } catch (e) {\n      error = e;\n    }\n\n    return error;\n  }\n  /**\n   * Will return a boolean if an address is valid\n   *\n   * @example\n   * ```javascript\n   * assert(this.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n   * ```\n   *\n   * @param {string} data - The encoded data\n   * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n   * @param {string} type - The type of address: 'script' or 'pubkey'\n   * @returns {boolean} The corresponding error message\n   */\n\n\n  static isValid(data, network, type) {\n    return !this.getValidationError(data, network, type);\n  }\n  /**\n   * Returns true if an address is of pay to public key hash type\n   * @return boolean\n   */\n\n\n  isPayToPublicKeyHash() {\n    return this.type === Address.PayToPublicKeyHash;\n  }\n  /**\n   * Returns true if an address is of pay to script hash type\n   * @return boolean\n   */\n\n\n  isPayToScriptHash() {\n    return this.type === Address.PayToScriptHash;\n  }\n  /**\n   * Will return a buffer representation of the address\n   *\n   * @returns {Buffer} Bitcoin address buffer\n   */\n\n\n  toBuffer() {\n    var version = Buffer.from([this.network[this.type]]);\n    var buf = Buffer.concat([version, this.hashBuffer]);\n    return buf;\n  }\n  /**\n   * @returns {Object} A plain object with the address information\n   */\n\n\n  toObject() {\n    return {\n      hash: this.hashBuffer.toString('hex'),\n      type: this.type,\n      network: this.network.toString()\n    };\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n  /**\n   * Will return a the string representation of the address\n   *\n   * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n   * @returns {string} Bitcoin address\n   */\n\n\n  toString(format) {\n    format = format || Address.DefaultFormat;\n\n    if (format === Address.LegacyFormat) {\n      return this._toStringLegacy();\n    }\n\n    if (format === Address.BitpayFormat) {\n      return this._toStringBitpay();\n    }\n\n    if (format === Address.CashAddrFormat) {\n      return this._toStringCashAddr();\n    }\n\n    throw new TypeError('Unrecognized address format.');\n  }\n  /**\n   * Will return a the string representation of the address in legacy format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringLegacy() {\n    return Base58Check.encode(this.toBuffer());\n  }\n  /**\n   * Will return a the string representation of the address in Bitpay format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringBitpay() {\n    var buffer = this.toBuffer();\n\n    if (this.network.toString() === 'livenet') {\n      if (this.type === Address.PayToPublicKeyHash) {\n        buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n      } else if (this.type === Address.PayToScriptHash) {\n        buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n      }\n    }\n\n    return Base58Check.encode(buffer);\n  }\n  /**\n   * Will return a the string representation of the address in CashAddr format\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  _toStringCashAddr() {\n    var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n    var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n    return cashaddr.encode(prefix, type, this.hashBuffer);\n  }\n  /**\n   * Will return a string formatted for the console\n   *\n   * @returns {string} Bitcoin address\n   */\n\n\n  inspect() {\n    return \"<Address: \".concat(this.toString(), \", type: \").concat(this.type, \", network: \").concat(this.network, \">\");\n  }\n\n}\n\nAddress.LegacyFormat = 'legacy';\nAddress.BitpayFormat = 'bitpay';\nAddress.CashAddrFormat = 'cashaddr';\nAddress.DefaultFormat = Address.LegacyFormat;\nAddress.PayToPublicKeyHash = 'pubkeyhash';\nAddress.PayToScriptHash = 'scripthash';\nvar GENESIS_BITS = 0x1d00ffff;\n/**\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\n * the properties of the BlockHeader\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {BlockHeader} - An instance of block header\n * @constructor\n */\n\nclass BlockHeader {\n  constructor(arg) {\n    if (!(this instanceof BlockHeader)) {\n      return new BlockHeader(arg);\n    }\n\n    var info = BlockHeader._from(arg);\n\n    this.version = info.version;\n    this.prevHash = info.prevHash;\n    this.merkleRoot = info.merkleRoot;\n    this.time = info.time;\n    this.timestamp = info.time;\n    this.bits = info.bits;\n    this.nonce = info.nonce;\n\n    if (info.hash) {\n      preconditions.checkState(this.hash === info.hash, 'Argument object hash does not match block hash.');\n    }\n\n    return this;\n  }\n  /**\n   * @param {*} - A Buffer, JSON string or Object\n   * @returns {Object} - An object representing block header data\n   * @throws {TypeError} - If the argument was not recognized\n   * @private\n   */\n\n\n  static _from(arg) {\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = BlockHeader._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      info = BlockHeader._fromObject(arg);\n    } else {\n      throw new TypeError('Unrecognized argument for BlockHeader');\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A JSON string\n   * @returns {Object} - An object representing block header data\n   * @private\n   */\n\n\n  static _fromObject(data) {\n    preconditions.checkArgument(data, 'data is required');\n    var prevHash = data.prevHash;\n    var merkleRoot = data.merkleRoot;\n\n    if (_.isString(data.prevHash)) {\n      prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\n    }\n\n    if (_.isString(data.merkleRoot)) {\n      merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\n    }\n\n    var info = {\n      hash: data.hash,\n      version: data.version,\n      prevHash,\n      merkleRoot,\n      time: data.time,\n      timestamp: data.time,\n      bits: data.bits,\n      nonce: data.nonce\n    };\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromObject(obj) {\n    var info = this._fromObject(obj);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {Binary} - Raw block binary data or buffer\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromRawBlock(data) {\n    if (!BufferUtil.isBuffer(data)) {\n      data = Buffer.from(data, 'binary');\n    }\n\n    var br = BufferReader(data);\n    br.pos = BlockHeader.Constants.START_OF_HEADER;\n\n    var info = this._fromBufferReader(br);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {Buffer} - A buffer of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromBuffer(buf) {\n    var info = this._fromBufferReader(BufferReader(buf));\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @param {string} - A hex encoded buffer of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromString(str) {\n    var buf = Buffer.from(str, 'hex');\n    return this.fromBuffer(buf);\n  }\n  /**\n   * @param {BufferReader} - A BufferReader of the block header\n   * @returns {Object} - An object representing block header data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var info = {};\n    info.version = br.readInt32LE();\n    info.prevHash = br.read(32);\n    info.merkleRoot = br.read(32);\n    info.time = br.readUInt32LE();\n    info.bits = br.readUInt32LE();\n    info.nonce = br.readUInt32LE();\n    return info;\n  }\n  /**\n   * @param {BufferReader} - A BufferReader of the block header\n   * @returns {BlockHeader} - An instance of block header\n   */\n\n\n  static fromBufferReader(br) {\n    var info = this._fromBufferReader(br);\n\n    return new BlockHeader(info);\n  }\n  /**\n   * @returns {Object} - A plain object of the BlockHeader\n   */\n\n\n  toJSON() {\n    return {\n      hash: this.hash,\n      version: this.version,\n      prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\n      merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\n      time: this.time,\n      bits: this.bits,\n      nonce: this.nonce\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * @returns {Buffer} - A Buffer of the BlockHeader\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @returns {string} - A hex encoded string of the BlockHeader\n   */\n\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n  /**\n   * @param {BufferWriter} - An existing instance BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\n   */\n\n\n  toBufferWriter(bw) {\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.writeInt32LE(this.version);\n    bw.write(this.prevHash);\n    bw.write(this.merkleRoot);\n    bw.writeUInt32LE(this.time);\n    bw.writeUInt32LE(this.bits);\n    bw.writeUInt32LE(this.nonce);\n    return bw;\n  }\n  /**\n   * Returns the target difficulty for this block\n   * @param {Number} bits\n   * @returns {BN} An instance of BN with the decoded difficulty bits\n   */\n\n\n  getTargetDifficulty(bits) {\n    bits = bits || this.bits;\n    var target = new BN(bits & 0xffffff);\n    var mov = 8 * ((bits >>> 24) - 3);\n\n    while (mov > 0) {\n      target = target.mul(new BN(2));\n      mov -= 1;\n    }\n\n    return target;\n  }\n  /**\n   * @link https://en.bitcoin.it/wiki/Difficulty\n   * @return {Number}\n   */\n\n\n  getDifficulty() {\n    var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(10 ** 8));\n    var currentTargetBN = this.getTargetDifficulty();\n    var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\n    var decimalPos = difficultyString.length - 8;\n    var leftOfDecimal = \"\".concat(difficultyString.slice(0, decimalPos));\n    var rightOfDecimal = \"\".concat(difficultyString.slice(decimalPos));\n    difficultyString = \"\".concat(leftOfDecimal, \".\").concat(rightOfDecimal);\n    return parseFloat(difficultyString);\n  }\n  /**\n   * @returns {Buffer} - The little endian hash buffer of the header\n   */\n\n\n  _getHash() {\n    var buf = this.toBuffer();\n    return Hash.sha256sha256(buf);\n  }\n  /**\n   * @returns {Boolean} - If timestamp is not too far in the future\n   */\n\n\n  validTimestamp() {\n    var currentTime = Math.round(new Date().getTime() / 1000);\n\n    if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\n   */\n\n\n  validProofOfWork() {\n    var pow = new BN(this.id, 'hex');\n    var target = this.getTargetDifficulty();\n\n    if (pow.cmp(target) > 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {string} - A string formatted for the console\n   */\n\n\n  inspect() {\n    return \"<BlockHeader \".concat(this.id, \">\");\n  }\n\n}\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get() {\n    if (!this._id) {\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\n    }\n\n    return this._id;\n  },\n\n  set: _.noop\n};\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\nBlockHeader.Constants = {\n  START_OF_HEADER: 8,\n  // Start buffer position in raw block data\n  MAX_TIME_OFFSET: 2 * 60 * 60,\n  // The max a timestamp can be in the future\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nclass Output {\n  constructor(args) {\n    if (_.isObject(args)) {\n      this.satoshis = args.satoshis;\n\n      if (BufferUtil.isBuffer(args.script)) {\n        this._scriptBuffer = args.script;\n      } else {\n        var script;\n\n        if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\n          script = Buffer.from(args.script, 'hex');\n        } else {\n          script = args.script;\n        }\n\n        this.setScript(script);\n      }\n    } else {\n      throw new TypeError('Unrecognized argument for Output');\n    }\n  }\n\n  get script() {\n    if (this._script) {\n      return this._script;\n    }\n\n    this.setScriptFromBuffer(this._scriptBuffer);\n    return this._script;\n  }\n\n  get satoshis() {\n    return this._satoshis;\n  }\n\n  set satoshis(num) {\n    if (num instanceof BN) {\n      this._satoshisBN = num;\n      this._satoshis = num.toNumber();\n    } else if (_.isString(num)) {\n      this._satoshis = parseInt(num, 10);\n      this._satoshisBN = BN.fromNumber(this._satoshis);\n    } else {\n      preconditions.checkArgument(JSUtil.isNaturalNumber(num), 'Output satoshis is not a natural number');\n      this._satoshisBN = BN.fromNumber(num);\n      this._satoshis = num;\n    }\n\n    preconditions.checkState(JSUtil.isNaturalNumber(this._satoshis), 'Output satoshis is not a natural number');\n  }\n\n  get satoshisBN() {\n    return this._satoshisBN;\n  }\n\n  set satoshisBN(num) {\n    this._satoshisBN = num;\n    this._satoshis = num.toNumber();\n    preconditions.checkState(JSUtil.isNaturalNumber(this._satoshis), 'Output satoshis is not a natural number');\n  }\n\n  static fromObject(data) {\n    return new Output(data);\n  }\n\n  static fromBufferReader(br) {\n    var obj = {};\n    obj.satoshis = br.readUInt64LEBN();\n    var size = br.readVarintNum();\n\n    if (size !== 0) {\n      obj.script = br.read(size);\n    } else {\n      obj.script = Buffer.from([]);\n    }\n\n    return new Output(obj);\n  }\n\n  invalidSatoshis() {\n    if (this._satoshis > MAX_SAFE_INTEGER) {\n      return 'transaction txout satoshis greater than max safe integer';\n    }\n\n    if (this._satoshis !== this._satoshisBN.toNumber()) {\n      return 'transaction txout satoshis has corrupted value';\n    }\n\n    if (this._satoshis < 0) {\n      return 'transaction txout negative';\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    var obj = {\n      satoshis: this.satoshis\n    };\n    obj.script = this._scriptBuffer.toString('hex');\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  setScriptFromBuffer(buff) {\n    this._scriptBuffer = buff;\n\n    try {\n      this._script = Script.fromBuffer(this._scriptBuffer);\n      this._script._isOutput = true;\n    } catch (e) {\n      if (e instanceof errors.Script.InvalidBuffer) {\n        this._script = null;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  setScript(script) {\n    if (script instanceof Script) {\n      this._scriptBuffer = script.toBuffer();\n      this._script = script;\n      this._script._isOutput = true;\n    } else if (_.isString(script)) {\n      this._script = Script.fromString(script);\n      this._scriptBuffer = this._script.toBuffer();\n      this._script._isOutput = true;\n    } else if (BufferUtil.isBuffer(script)) {\n      this.setScriptFromBuffer(script);\n    } else {\n      throw new TypeError('Invalid argument type: script');\n    }\n\n    return this;\n  }\n\n  inspect() {\n    var scriptStr;\n\n    if (this.script) {\n      scriptStr = this.script.inspect();\n    } else {\n      scriptStr = this._scriptBuffer.toString('hex');\n    }\n\n    return \"<Output (\".concat(this.satoshis, \" sats) \").concat(scriptStr, \">\");\n  }\n\n  toBufferWriter(writer) {\n    if (!writer) {\n      writer = new BufferWriter();\n    }\n\n    writer.writeUInt64LEBN(this._satoshisBN);\n    var script = this._scriptBuffer;\n    writer.writeVarintNum(script.length);\n    writer.write(script);\n    return writer;\n  }\n\n}\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n\n  if (obj) {\n    this.set(obj);\n  }\n};\n\nECDSA.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; // the endianness of hashbuf\n\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function () {\n  for (var i = 0; i < 4; i += 1) {\n    this.sig.i = i;\n    var Qprime = void 0;\n\n    try {\n      Qprime = this.toPublicKey();\n\n      if (Qprime.point.eq(this.pubkey.point)) {\n        this.sig.compressed = this.pubkey.compressed;\n        return this;\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function (str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function () {\n  var N = Point.getN();\n  var k;\n\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n\n  this.k = k;\n  return this;\n}; // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nECDSA.prototype.deterministicK = function (badrs) {\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN(); // also explained in 3.2, we must ensure T is in the proper range (0, N)\n\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i += 1) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n}; // Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\n\n\nECDSA.prototype.toPublicKey = function () {\n  var i = this.sig.i;\n  preconditions.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, 'i must be equal to 0, 1, 2, or 3');\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s; // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1;\n  var n = Point.getN();\n  var G = Point.getG(); // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  } // Compute -e from e\n\n\n  var eNeg = e.neg().umod(n); // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n\n  var rInv = r.invm(n); // var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function () {\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  }\n\n  return false;\n};\n\nECDSA.toLowS = function (s) {\n  // enforce low s\n  // see BIP 62, \"low S values in signatures\"\n  var maxS = '7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0';\n\n  if (s.gt(BN.fromBuffer(Buffer.from(maxS, 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n\n  return s;\n};\n\nECDSA.prototype._findSignature = function (d, e) {\n  var N = Point.getN();\n  var G = Point.getG(); // try different values of k until r, s are valid\n\n  var badrs = 0;\n  var Q;\n  var r;\n  var s;\n\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n\n    badrs += 1;\n    var k = this.k;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s,\n    r\n  };\n};\n\nECDSA.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  preconditions.checkState(hashbuf && privkey && d, 'invalid parameters');\n  preconditions.checkState(BufferUtil.isBuffer(hashbuf), 'hashbuf must be a buffer');\n  preconditions.checkState(hashbuf.length === 32, 'hashbuf must be 32 bytes');\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n\n  obj.compressed = this.pubkey.compressed;\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function () {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function () {\n  var obj = {};\n\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n\n  return this;\n};\n\nECDSA.sign = function (hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf,\n    endian,\n    privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function (hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf,\n    endian,\n    sig,\n    pubkey\n  }).verify().verified;\n};\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\nvar ENABLE_SIGHASH_FORKID = true;\n\nclass Sighash {\n  static sighashForForkId(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n    var input = transaction.inputs[inputNumber];\n    preconditions.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n\n    function GetPrevoutHash(tx) {\n      var writer = new BufferWriter();\n\n      _.each(tx.inputs, txIn => {\n        writer.writeReverse(txIn.prevTxId);\n        writer.writeUInt32LE(txIn.outputIndex);\n      });\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    function GetSequenceHash(tx) {\n      var writer = new BufferWriter();\n\n      _.each(tx.inputs, txIn => {\n        writer.writeUInt32LE(txIn.sequenceNumber);\n      });\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    function GetOutputsHash(tx, n) {\n      var writer = new BufferWriter();\n\n      if (_.isUndefined(n)) {\n        _.each(tx.outputs, output => {\n          output.toBufferWriter(writer);\n        });\n      } else {\n        tx.outputs[n].toBufferWriter(writer);\n      }\n\n      var buf = writer.toBuffer();\n      var ret = Hash.sha256sha256(buf);\n      return ret;\n    }\n\n    var hashPrevouts = BufferUtil.emptyBuffer(32);\n    var hashSequence = BufferUtil.emptyBuffer(32);\n    var hashOutputs = BufferUtil.emptyBuffer(32);\n\n    if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n      hashPrevouts = GetPrevoutHash(transaction);\n    }\n\n    if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {\n      hashSequence = GetSequenceHash(transaction);\n    }\n\n    if ((sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {\n      hashOutputs = GetOutputsHash(transaction);\n    } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n      hashOutputs = GetOutputsHash(transaction, inputNumber);\n    }\n\n    var writer = new BufferWriter(); // Version\n\n    writer.writeInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n    writer.write(hashPrevouts);\n    writer.write(hashSequence); //  outpoint (32-byte hash + 4-byte little endian)\n\n    writer.writeReverse(input.prevTxId);\n    writer.writeUInt32LE(input.outputIndex); // scriptCode of the input (serialized as scripts inside CTxOuts)\n\n    writer.writeVarintNum(subscript.toBuffer().length);\n    writer.write(subscript.toBuffer()); // value of the output spent by this input (8-byte little endian)\n\n    writer.writeUInt64LEBN(satoshisBN); // nSequence of the input (4-byte little endian)\n\n    var sequenceNumber = input.sequenceNumber;\n    writer.writeUInt32LE(sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n    writer.write(hashOutputs); // Locktime\n\n    writer.writeUInt32LE(transaction.nLockTime); // sighashType\n\n    writer.writeUInt32LE(sighashType >>> 0);\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n  /**\n   * Returns a buffer of length 32 bytes with the hash that needs to be signed\n   * for OP_CHECKSIG.\n   *\n   * @name Signing.sighash\n   * @param {Transaction} transaction the transaction to sign\n   * @param {number} sighashType the type of the hash\n   * @param {number} inputNumber the input index for the signature\n   * @param {Script} subscript the script that will be signed\n   * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n   *\n   */\n\n\n  static sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n    // Copy transaction\n    var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n    subscript = new Script(subscript);\n\n    if (sighashType & Signature.SIGHASH_FORKID && ENABLE_SIGHASH_FORKID) {\n      return Sighash.sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n    } // For no ForkId sighash, separators need to be removed.\n\n\n    subscript.removeCodeseparators();\n    var i;\n\n    for (i = 0; i < txcopy.inputs.length; i += 1) {\n      // Blank signatures for other inputs\n      txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n    }\n\n    txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n    if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n      // clear all sequenceNumbers\n      for (i = 0; i < txcopy.inputs.length; i += 1) {\n        if (i !== inputNumber) {\n          txcopy.inputs[i].sequenceNumber = 0;\n        }\n      }\n    }\n\n    if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n      txcopy.outputs = [];\n    } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n      // The SIGHASH_SINGLE bug.\n      // https://bitcointalk.org/index.php?topic=260595.0\n      if (inputNumber >= txcopy.outputs.length) {\n        return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n      }\n\n      txcopy.outputs.length = inputNumber + 1;\n\n      for (i = 0; i < inputNumber; i += 1) {\n        txcopy.outputs[i] = new Output({\n          satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n          script: Script.empty()\n        });\n      }\n    }\n\n    if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n      txcopy.inputs = [txcopy.inputs[inputNumber]];\n    }\n\n    var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n  /**\n   * Create a signature\n   *\n   * @name Signing.sign\n   * @param {Transaction} transaction\n   * @param {PrivateKey} privateKey\n   * @param {number} sighash\n   * @param {number} inputIndex\n   * @param {Script} subscript\n   * @param {satoshisBN} input's amount\n   * @return {Signature}\n   */\n\n\n  static sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n    var hashbuf = Sighash.sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n    var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n  /**\n   * Verify a signature\n   *\n   * @name Signing.verify\n   * @param {Transaction} transaction\n   * @param {Signature} signature\n   * @param {PublicKey} publicKey\n   * @param {number} inputIndex\n   * @param {Script} subscript\n   * @param {satoshisBN} input's amount\n   * @return {boolean}\n   */\n\n\n  static verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n    preconditions.checkArgument(!_.isUndefined(transaction));\n    preconditions.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n    var hashbuf = Sighash.sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n\n}\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\n\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\n\nclass Input {\n  constructor(params) {\n    if (!(this instanceof Input)) {\n      return new Input(params);\n    }\n\n    if (params) {\n      return this._fromObject(params);\n    }\n  }\n\n  get script() {\n    if (this.isNull()) {\n      return null;\n    }\n\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n\n    return this._script;\n  }\n\n  static fromObject(obj) {\n    preconditions.checkArgument(obj !== null && typeof obj === 'object');\n    return new Input()._fromObject(obj);\n  }\n\n  _fromObject(params) {\n    if (params.script === undefined && params.scriptBuffer === undefined) {\n      throw new errors.Transaction.Input.MissingScript();\n    }\n\n    this.prevTxId = typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId) ? Buffer.from(params.prevTxId, 'hex') : params.prevTxId;\n\n    if (params.output) {\n      this.output = params.output instanceof Output ? params.output : new Output(params.output);\n    }\n\n    this.outputIndex = params.outputIndex === undefined ? params.txoutnum : params.outputIndex;\n\n    if (params.sequenceNumber !== undefined) {\n      this.sequenceNumber = params.sequenceNumber;\n    } else if (params.seqnum !== undefined) {\n      this.sequenceNumber = params.seqnum;\n    } else {\n      this.sequenceNumber = DEFAULT_SEQNUMBER;\n    }\n\n    this.setScript(params.scriptBuffer || params.script);\n    return this;\n  }\n\n  toJSON() {\n    var obj = {\n      prevTxId: this.prevTxId.toString('hex'),\n      outputIndex: this.outputIndex,\n      sequenceNumber: this.sequenceNumber,\n      script: this._scriptBuffer.toString('hex')\n    }; // add human readable form if input contains valid script\n\n    if (this.script) {\n      obj.scriptString = this.script.toString();\n    }\n\n    if (this.output) {\n      obj.output = this.output.toObject();\n    }\n\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  static fromBufferReader(br) {\n    var input = new Input();\n    input.prevTxId = br.readReverse(32);\n    input.outputIndex = br.readUInt32LE();\n    input._scriptBuffer = br.readVarLengthBuffer();\n    input.sequenceNumber = br.readUInt32LE(); // TODO: return different classes according to which input it is\n    // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n\n    return input;\n  }\n\n  toBufferWriter(writer) {\n    writer = writer || new BufferWriter();\n    writer.writeReverse(this.prevTxId);\n    writer.writeUInt32LE(this.outputIndex);\n    var script = this._scriptBuffer;\n    writer.writeVarintNum(script.length);\n    writer.write(script);\n    writer.writeUInt32LE(this.sequenceNumber);\n    return writer;\n  }\n\n  setScript(script) {\n    this._script = null;\n\n    if (script instanceof Script) {\n      this._script = script;\n      this._script._isInput = true;\n      this._scriptBuffer = script.toBuffer();\n    } else if (JSUtil.isHexa(script)) {\n      // hex string script\n      this._scriptBuffer = Buffer.from(script, 'hex');\n    } else if (typeof script === 'string') {\n      // human readable string script\n      this._script = new Script(script);\n      this._script._isInput = true;\n      this._scriptBuffer = this._script.toBuffer();\n    } else if (BufferUtil.isBuffer(script)) {\n      // buffer script\n      this._scriptBuffer = Buffer.from(script);\n    } else {\n      throw new TypeError('Invalid argument type: script');\n    }\n\n    return this;\n  }\n  /**\n   * Retrieve signatures for the provided PrivateKey.\n   *\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key to use when signing\n   * @param {number} inputIndex - the index of this input in the provided transaction\n   * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n   * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n   *     public key associated with the private key provided\n   * @abstract\n   */\n\n\n  getSignatures() {\n    throw new errors.AbstractMethodInvoked(\"\".concat('Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ').concat(JSON.stringify(this)));\n  }\n\n  isFullySigned() {\n    throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n  }\n\n  isFinal() {\n    return this.sequenceNumber !== 4294967295;\n  }\n\n  addSignature() {\n    throw new errors.AbstractMethodInvoked('Input#addSignature');\n  }\n\n  clearSignatures() {\n    throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN);\n  }\n  /**\n   * @returns true if this is a coinbase input (represents no input)\n   */\n\n\n  isNull() {\n    return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff;\n  }\n\n  _estimateSize() {\n    return this.toBufferWriter().toBuffer().length;\n  }\n\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\n/**\n * @desc\n * Wrapper around Signature with fields related to signing a transaction specifically\n *\n * @param {Object|string|TransactionSignature} arg\n * @constructor\n */\n\nclass TransactionSignature extends Signature {\n  constructor(arg) {\n    super(arg);\n\n    if (arg instanceof TransactionSignature) {\n      return arg;\n    }\n\n    if (_.isObject(arg)) {\n      return this._fromObject(arg);\n    }\n\n    throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\n  }\n\n  _fromObject(arg) {\n    TransactionSignature._checkObjectArgs(arg);\n\n    this.publicKey = new PublicKey(arg.publicKey);\n    this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\n    this.outputIndex = arg.outputIndex;\n    this.inputIndex = arg.inputIndex;\n\n    if (arg.signature instanceof Signature) {\n      this.signature = arg.signature;\n    } else if (BufferUtil.isBuffer(arg.signature)) {\n      this.signature = Signature.fromBuffer(arg.signature);\n    } else {\n      this.signature = Signature.fromString(arg.signature);\n    }\n\n    this.sigtype = arg.sigtype;\n    return this;\n  }\n\n  static _checkObjectArgs(arg) {\n    preconditions.checkArgument(PublicKey(arg.publicKey), 'publicKey');\n    preconditions.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex');\n    preconditions.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex');\n    preconditions.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number');\n    preconditions.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number');\n    preconditions.checkArgument(arg.signature, 'signature');\n    preconditions.checkArgument(arg.prevTxId, 'prevTxId');\n    preconditions.checkState(arg.signature instanceof Signature || BufferUtil.isBuffer(arg.signature) || JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\n    preconditions.checkState(BufferUtil.isBuffer(arg.prevTxId) || JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\n    preconditions.checkArgument(arg.sigtype, 'sigtype');\n    preconditions.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number');\n  }\n  /**\n   * Serializes a transaction to a plain JS object\n   * @return {Object}\n   */\n\n\n  toJSON() {\n    return {\n      publicKey: this.publicKey.toString(),\n      prevTxId: this.prevTxId.toString('hex'),\n      outputIndex: this.outputIndex,\n      inputIndex: this.inputIndex,\n      signature: this.signature.toString(),\n      sigtype: this.sigtype\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * Builds a TransactionSignature from an object\n   * @param {Object} object\n   * @return {TransactionSignature}\n   */\n\n\n  static fromObject(object) {\n    preconditions.checkArgument(object);\n    return new TransactionSignature(object);\n  }\n\n}\n\nclass MultiSigScriptHashInput extends Input {\n  constructor(input, pubkeys, threshold, signatures, redeemScript) {\n    super(input, pubkeys, threshold, signatures, redeemScript);\n    var self = this;\n    pubkeys = pubkeys || input.publicKeys;\n    this.threshold = threshold || input.threshold;\n    signatures = signatures || input.signatures;\n    this.publicKeys = _.sortBy(pubkeys, publicKey => publicKey.toString('hex'));\n    this.redeemScript = redeemScript || Script.buildMultisigOut(this.publicKeys, this.threshold); // $.checkState(\n    //   Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),\n    //   'RedeemScript does not hash to the provided output'\n    // )\n\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      self.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  } // eslint-disable-next-line max-len\n\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n      cachedMultisig: this.redeemScript\n    }));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    return this.publicKeys.filter(publicKey => !this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript, this.output.satoshisBN);\n  }\n\n  _estimateSize() {\n    return MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;\n  }\n\n}\n\nMultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\n\nMultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\n\nMultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\n\nclass MultiSigInput extends Input {\n  constructor(input, pubkeys, threshold, signatures) {\n    super(input, pubkeys, threshold, signatures);\n    pubkeys = pubkeys || input.publicKeys;\n    this.threshold = threshold || input.threshold;\n    signatures = signatures || input.signatures;\n    this.publicKeys = _.sortBy(pubkeys, publicKey => publicKey.toString('hex')); // $.checkState(\n    //   Script.buildMultisigOut(this.publicKeys, this.threshold).equals(this.output.script),\n    //   \"Provided public keys don't match to the provided output script\"\n    // )\n\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      this.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  }\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    return this.publicKeys.filter(publicKey => !this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN);\n  }\n  /**\n   * @param {Buffer[]} signatures\n   * @param {PublicKey[]} publicKeys\n   * @param {Transaction} transaction\n   * @param {Integer} inputIndex\n   * @param {Input} input\n   * @returns {TransactionSignature[]}\n   */\n  // eslint-disable-next-line max-len\n\n\n  static normalizeSignatures(transaction, input, inputIndex, signatures, publicKeys) {\n    return publicKeys.map(pubKey => {\n      var signatureMatch = null;\n      signatures = signatures.filter(signatureBuffer => {\n        if (signatureMatch) {\n          return true;\n        }\n\n        var signature = new TransactionSignature({\n          signature: Signature.fromTxFormat(signatureBuffer),\n          publicKey: pubKey,\n          prevTxId: input.prevTxId,\n          outputIndex: input.outputIndex,\n          inputIndex,\n          sigtype: Signature.SIGHASH_ALL\n        });\n        signature.signature.nhashtype = signature.sigtype;\n        var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script);\n\n        if (isMatch) {\n          signatureMatch = signature;\n          return false;\n        }\n\n        return true;\n      });\n      return signatureMatch || null;\n    });\n  }\n\n  _estimateSize() {\n    return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n  }\n\n}\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n */\n\nclass PublicKeyInput extends Input {\n  /**\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n   * @param {number} index - the index of the input in the transaction input vector\n   * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n   * @return {Array} of objects that can be\n   */\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKey = privateKey.toPublicKey();\n\n    if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n      return [new TransactionSignature({\n        publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n        sigtype\n      })];\n    }\n\n    return [];\n  }\n  /**\n   * Add the provided signature\n   *\n   * @param {Object} signature\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @param {number=} signature.sigtype\n   * @return {PublicKeyInput} this, for chaining\n   */\n\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    this.setScript(Script.buildPublicKeyIn(signature.signature.toDER(), signature.sigtype));\n    return this;\n  }\n  /**\n   * Clear the input's signature\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  clearSignatures() {\n    this.setScript(Script.empty());\n    return this;\n  }\n  /**\n   * Query whether the input is signed\n   * @return {boolean}\n   */\n\n\n  isFullySigned() {\n    return this.script.isPublicKeyIn();\n  }\n\n  _estimateSize() {\n    return PublicKeyInput.SCRIPT_MAX_SIZE;\n  }\n\n}\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n */\n\nclass PublicKeyHashInput extends Input {\n  /**\n   * @param {Transaction} transaction - the transaction to be signed\n   * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n   * @param {number} index - the index of the input in the transaction input vector\n   * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n   * @param {Buffer=} hashData - the precalculated hash of the public key associated with the\n   *   privateKey provided\n   * @return {Array} of objects that can be\n   */\n  // eslint-disable-next-line max-len\n  getSignatures(transaction, privateKey, index, sigtype, hashData) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n\n    if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n      return [new TransactionSignature({\n        publicKey: privateKey.toPublicKey(),\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n        sigtype\n      })];\n    }\n\n    return [];\n  }\n  /**\n   * Add the provided signature\n   *\n   * @param {Object} signature\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @param {number=} signature.sigtype\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(this.isValidSignature(transaction, signature), 'Signature invalid');\n    var script = Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(), signature.sigtype);\n    this.setScript(script);\n    return this;\n  }\n  /**\n   * Clear the input's signature\n   * @return {PublicKeyHashInput} this, for chaining\n   */\n\n\n  clearSignatures() {\n    this.setScript(Script.empty());\n    return this;\n  }\n  /**\n   * Query whether the input is signed\n   * @return {boolean}\n   */\n\n\n  isFullySigned() {\n    return this.script.isPublicKeyHashIn();\n  }\n\n  _estimateSize() {\n    return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n\n}\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nvar UNITS = {\n  BTC: [1e8, 8],\n  mBTC: [1e5, 5],\n  uBTC: [1e2, 2],\n  bits: [1e2, 2],\n  satoshis: [1, 0]\n};\n/**\n * Utility for handling and converting bitcoins units. The supported units are\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\n * It also allows to be created from a fiat amount and the exchange rate, or\n * alternatively using the {fromFiat} static method.\n * You can consult for different representation of a unit instance using it's\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\n * the unit accessors. It also can be converted to a fiat amount by providing the\n * corresponding BTC/fiat exchange rate.\n *\n * @example\n * ```javascript\n * var sats = Unit.fromBTC(1.3).toSatoshis();\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\n * var bits = Unit.fromFiat(1.3, 350).bits;\n * var btc = new Unit(1.3, Unit.bits).BTC;\n * ```\n *\n * @param {Number} amount - The amount to be represented\n * @param {String|Number} code - The unit of the amount or the exchange rate\n * @returns {Unit} A new instance of an Unit\n * @constructor\n */\n\nfunction Unit(amount, code) {\n  if (!(this instanceof Unit)) {\n    return new Unit(amount, code);\n  } // convert fiat to BTC\n\n\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n\n    amount /= code;\n    code = Unit.BTC;\n  }\n\n  this._value = this._from(amount, code);\n  var self = this;\n\n  var defineAccesor = function defineAccesor(key) {\n    Object.defineProperty(self, key, {\n      get() {\n        return self.to(key);\n      },\n\n      enumerable: true\n    });\n  };\n\n  Object.keys(UNITS).forEach(defineAccesor);\n}\n\nObject.keys(UNITS).forEach(key => {\n  Unit[key] = key;\n});\n/**\n * Returns a Unit instance created from JSON string or object\n *\n * @param {String|Object} json - JSON with keys: amount and code\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromObject = function fromObject(data) {\n  preconditions.checkArgument(_.isObject(data), 'Argument is expected to be an object');\n  return new Unit(data.amount, data.code);\n};\n/**\n * Returns a Unit instance created from an amount in BTC\n *\n * @param {Number} amount - The amount in BTC\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromBTC = function (amount) {\n  return new Unit(amount, Unit.BTC);\n};\n/**\n * Returns a Unit instance created from an amount in mBTC\n *\n * @param {Number} amount - The amount in mBTC\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromMilis = function (amount) {\n  return new Unit(amount, Unit.mBTC);\n};\n\nUnit.fromMillis = Unit.fromMilis;\n/**\n * Returns a Unit instance created from an amount in bits\n *\n * @param {Number} amount - The amount in bits\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromBits = function (amount) {\n  return new Unit(amount, Unit.bits);\n};\n\nUnit.fromMicros = Unit.fromBits;\n/**\n * Returns a Unit instance created from an amount in satoshis\n *\n * @param {Number} amount - The amount in satoshis\n * @returns {Unit} A Unit instance\n */\n\nUnit.fromSatoshis = function (amount) {\n  return new Unit(amount, Unit.satoshis);\n};\n/**\n * Returns a Unit instance created from a fiat amount and exchange rate.\n *\n * @param {Number} amount - The amount in fiat\n * @param {Number} rate - The exchange rate BTC/fiat\n * @returns {Unit} A Unit instance\n */\n\n\nUnit.fromFiat = function (amount, rate) {\n  return new Unit(amount, rate);\n};\n\nUnit.prototype._from = function (amount, code) {\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  return parseInt((amount * UNITS[code][0]).toFixed(), 10);\n};\n/**\n * Returns the value represented in the specified unit\n *\n * @param {String|Number} code - The unit code or exchange rate\n * @returns {Number} The converted value\n */\n\n\nUnit.prototype.to = function (code) {\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n\n    return parseFloat((this.BTC * code).toFixed(2));\n  }\n\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  var value = this._value / UNITS[code][0];\n  return parseFloat(value.toFixed(UNITS[code][1]));\n};\n/**\n * Returns the value represented in BTC\n *\n * @returns {Number} The value converted to BTC\n */\n\n\nUnit.prototype.toBTC = function () {\n  return this.to(Unit.BTC);\n};\n/**\n * Returns the value represented in mBTC\n *\n * @returns {Number} The value converted to mBTC\n */\n\n\nUnit.prototype.toMilis = function () {\n  return this.to(Unit.mBTC);\n};\n\nUnit.prototype.toMillis = Unit.prototype.toMilis;\n/**\n * Returns the value represented in bits\n *\n * @returns {Number} The value converted to bits\n */\n\nUnit.prototype.toBits = function () {\n  return this.to(Unit.bits);\n};\n\nUnit.prototype.toMicros = Unit.prototype.toBits;\n/**\n * Returns the value represented in satoshis\n *\n * @returns {Number} The value converted to satoshis\n */\n\nUnit.prototype.toSatoshis = function () {\n  return this.to(Unit.satoshis);\n};\n/**\n * Returns the value represented in fiat\n *\n * @param {string} rate - The exchange rate between BTC/currency\n * @returns {Number} The value converted to satoshis\n */\n\n\nUnit.prototype.atRate = function (rate) {\n  return this.to(rate);\n};\n/**\n * Returns a the string representation of the value in satoshis\n *\n * @returns {string} the value in satoshis\n */\n\n\nUnit.prototype.toString = function () {\n  return \"\".concat(this.satoshis, \" satoshis\");\n};\n/**\n * Returns a plain object representation of the Unit\n *\n * @returns {Object} An object with the keys: amount and code\n */\n\n\nUnit.prototype.toJSON = function toObject() {\n  return {\n    amount: this.BTC,\n    code: Unit.BTC\n  };\n};\n\nUnit.prototype.toObject = Unit.prototype.toJSON;\n/**\n * Returns a string formatted for the console\n *\n * @returns {string} the value in satoshis\n */\n\nUnit.prototype.inspect = function () {\n  return \"<Unit: \".concat(this.toString(), \">\");\n};\n/**\n * Represents an unspent output information: its script, associated amount and address,\n * transaction id and output index.\n *\n * @constructor\n * @param {object} data\n * @param {string} data.txid the previous transaction id\n * @param {string=} data.txId alias for `txid`\n * @param {number} data.vout the index in the transaction\n * @param {number=} data.outputIndex alias for `vout`\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\n * @param {string|Script=} data.script alias for `scriptPubKey`\n * @param {number} data.amount amount of bitcoins associated\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis\n *   (1 BTC = 1e8 satoshis)\n * @param {string|Address=} data.address the associated address to the script, if provided\n */\n\n\nclass UnspentOutput {\n  constructor(data) {\n    preconditions.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\n    var address = data.address ? new Address(data.address) : undefined;\n    var txId = data.txid ? data.txid : data.txId;\n\n    if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\n      // TODO: Use the errors library\n      throw new Error('Invalid TXID in object', data);\n    }\n\n    var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\n\n    if (!_.isNumber(outputIndex)) {\n      throw new Error(\"Invalid outputIndex, received \".concat(outputIndex));\n    }\n\n    preconditions.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script), 'Must provide the scriptPubKey for that output!');\n    var script = new Script(data.scriptPubKey || data.script);\n    preconditions.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis), 'Must provide an amount for the output');\n    var amount = !_.isUndefined(data.amount) ? Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    JSUtil.defineImmutable(this, {\n      address,\n      txId,\n      outputIndex,\n      script,\n      satoshis: amount\n    });\n  }\n  /**\n   * Provide an informative output when displaying this object in the console\n   * @returns string\n   */\n\n\n  inspect() {\n    var unspent = \"UnspentOutput: \".concat(this.txId, \":\").concat(this.outputIndex);\n    var satoshis = \"satoshis: \".concat(this.satoshis);\n    var address = \"address: \".concat(this.address);\n    return \"<\".concat(unspent, \", \").concat(satoshis, \", \").concat(address, \">\");\n  }\n  /**\n   * String representation: just \"txid:index\"\n   * @returns string\n   */\n\n\n  toString() {\n    return \"\".concat(this.txId, \":\").concat(this.outputIndex);\n  }\n  /**\n   * Deserialize an UnspentOutput from an object\n   * @param {object|string} data\n   * @return UnspentOutput\n   */\n\n\n  static fromObject(data) {\n    return new UnspentOutput(data);\n  }\n  /**\n   * Returns a plain object (no prototype or methods) with the associated info for this output\n   * @return {object}\n   */\n\n\n  toJSON() {\n    return {\n      address: this.address ? this.address.toString() : undefined,\n      txid: this.txId,\n      vout: this.outputIndex,\n      scriptPubKey: this.script.toBuffer().toString('hex'),\n      amount: Unit.fromSatoshis(this.satoshis).toBTC()\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n}\n\nvar compare = Buffer.compare || bufferCompare;\nvar CURRENT_VERSION = 1;\nvar DEFAULT_NLOCKTIME = 0;\nvar MAX_BLOCK_SIZE = 1000000;\n/**\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\n *\n * @param {*} serialized\n * @constructor\n */\n\nclass Transaction {\n  constructor(serialized) {\n    this.inputs = [];\n    this.outputs = [];\n    this._inputAmount = undefined;\n    this._outputAmount = undefined;\n\n    if (serialized) {\n      if (serialized instanceof Transaction) {\n        return Transaction.shallowCopy(serialized);\n      }\n\n      if (JSUtil.isHexa(serialized)) {\n        this.fromString(serialized);\n      } else if (BufferUtil.isBuffer(serialized)) {\n        this.fromBuffer(serialized);\n      } else if (_.isObject(serialized)) {\n        this.fromObject(serialized);\n      } else {\n        throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\n      }\n    } else {\n      this._newTransaction();\n    }\n  }\n\n  get hash() {\n    return new BufferReader(this._getHash()).readReverse().toString('hex');\n  }\n\n  get id() {\n    return new BufferReader(this._getHash()).readReverse().toString('hex');\n  }\n\n  get inputAmount() {\n    return this._getInputAmount();\n  }\n\n  get outputAmount() {\n    return this._getOutputAmount();\n  }\n  /**\n   * Retrieve the little endian hash of the transaction (used for serialization)\n   * @return {Buffer}\n   */\n\n\n  _getHash() {\n    return Hash.sha256sha256(this.toBuffer());\n  }\n  /**\n   * Retrieve a hexa string that can be used with bitcoind's CLI interface\n   * (decoderawtransaction, sendrawtransaction)\n   *\n   * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\n   *   it's expected to contain a set of flags to skip certain tests:\n   * * `disableAll`: disable all checks\n   * * `disableSmallFees`: disable checking for fees that are too small\n   * * `disableLargeFees`: disable checking for fees that are too large\n   * * `disableIsFullySigned`: disable checking if all inputs are fully signed\n   * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\n   * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than\n   *    the sum of the input amounts\n   * @return {string}\n   */\n\n\n  serialize(unsafe) {\n    if (unsafe === true || unsafe && unsafe.disableAll) {\n      return this.uncheckedSerialize();\n    }\n\n    return this.checkedSerialize(unsafe);\n  }\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n\n  uncheckedSerialize() {\n    return this.toString();\n  }\n  /**\n   * Retrieve a hexa string that can be used with bitcoind's CLI interface\n   * (decoderawtransaction, sendrawtransaction)\n   *\n   * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n   * @return {string}\n   */\n\n\n  checkedSerialize(opts) {\n    var serializationError = this.getSerializationError(opts);\n\n    if (serializationError) {\n      serializationError.message += ' - For more information please see: https://bitcore.io/api/lib/transaction#serialization-checks';\n      throw serializationError;\n    }\n\n    return this.uncheckedSerialize();\n  }\n\n  invalidSatoshis() {\n    return this.outputs.some(output => output.invalidSatoshis());\n  }\n  /**\n   * Retrieve a possible error that could appear when trying to serialize and\n   * broadcast this transaction.\n   *\n   * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n   * @return {bitcore.Error}\n   */\n\n\n  getSerializationError() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.invalidSatoshis()) {\n      return new errors.Transaction.InvalidSatoshis();\n    }\n\n    var unspent = this._getUnspentValue();\n\n    var unspentError;\n\n    if (unspent < 0) {\n      if (!opts.disableMoreOutputThanInput) {\n        unspentError = new errors.Transaction.InvalidOutputAmountSum();\n      }\n    } else {\n      unspentError = this._hasFeeError(opts, unspent);\n    }\n\n    return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts);\n  }\n\n  _hasFeeError(opts, unspent) {\n    if (this._fee !== undefined && this._fee !== unspent) {\n      return new errors.Transaction.FeeError.Different(\"Unspent value is \".concat(unspent, \" but specified fee is \").concat(this._fee));\n    }\n\n    if (!opts.disableLargeFees) {\n      var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\n\n      if (unspent > maximumFee) {\n        if (this._missingChange()) {\n          return new errors.Transaction.ChangeAddressMissing('Fee is too large and no change address was provided');\n        }\n\n        return new errors.Transaction.FeeError.TooLarge(\"expected less than \".concat(maximumFee, \" but got \").concat(unspent));\n      }\n    }\n\n    if (!opts.disableSmallFees) {\n      var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\n\n      if (unspent < minimumFee) {\n        return new errors.Transaction.FeeError.TooSmall(\"expected more than \".concat(minimumFee, \" but got \").concat(unspent));\n      }\n    }\n\n    return undefined;\n  }\n\n  _missingChange() {\n    return !this._changeScript;\n  }\n\n  _hasDustOutputs(opts) {\n    if (!opts.disableDustOutputs) {\n      // eslint-disable-next-line max-len\n      var dustOutputs = this.outputs.filter(output => output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut());\n\n      if (dustOutputs.length > 0) {\n        return new errors.Transaction.DustOutputs();\n      }\n    }\n\n    return undefined;\n  }\n\n  _isMissingSignatures(opts) {\n    if (!opts.disableIsFullySigned && !this.isFullySigned()) {\n      return new errors.Transaction.MissingSignatures();\n    }\n\n    return undefined;\n  }\n\n  inspect() {\n    return \"<Transaction: \".concat(this.uncheckedSerialize(), \">\");\n  }\n\n  toBuffer() {\n    var writer = new BufferWriter();\n    return this.toBufferWriter(writer).toBuffer();\n  }\n\n  toBufferWriter(writer) {\n    writer.writeInt32LE(this.version);\n    writer.writeVarintNum(this.inputs.length);\n    this.inputs.forEach(input => input.toBufferWriter(writer));\n    writer.writeVarintNum(this.outputs.length);\n    this.outputs.forEach(output => output.toBufferWriter(writer));\n    writer.writeUInt32LE(this.nLockTime);\n    return writer;\n  }\n\n  fromBuffer(buffer) {\n    var reader = new BufferReader(buffer);\n    return this.fromBufferReader(reader);\n  }\n\n  fromBufferReader(reader) {\n    preconditions.checkArgument(!reader.finished(), 'No transaction data received when creating transaction from buffer');\n    var i;\n    this.version = reader.readInt32LE();\n    var sizeTxIns = reader.readVarintNum();\n\n    for (i = 0; i < sizeTxIns; i += 1) {\n      var input = Input.fromBufferReader(reader);\n      this.inputs.push(input);\n    }\n\n    var sizeTxOuts = reader.readVarintNum();\n\n    for (i = 0; i < sizeTxOuts; i += 1) {\n      this.outputs.push(Output.fromBufferReader(reader));\n    }\n\n    this.nLockTime = reader.readUInt32LE();\n    return this;\n  }\n\n  toJSON() {\n    var inputs = this.inputs.map(input => input.toObject());\n    var outputs = this.outputs.map(output => output.toObject());\n    var obj = {\n      hash: this.hash,\n      version: this.version,\n      inputs,\n      outputs,\n      nLockTime: this.nLockTime\n    };\n\n    if (this._changeScript) {\n      obj.changeScript = this._changeScript.toString();\n    }\n\n    if (this._changeIndex !== undefined) {\n      obj.changeIndex = this._changeIndex;\n    }\n\n    if (this._fee !== undefined) {\n      obj.fee = this._fee;\n    }\n\n    if (this._dataInputs !== undefined) {\n      obj.dataInputs = this._dataInputs;\n    }\n\n    if (this._dataOutputs !== undefined) {\n      obj.dataOutputs = this._dataOutputs;\n    }\n\n    return obj;\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n\n  fromObject(arg) {\n    preconditions.checkArgument(_.isObject(arg) || arg instanceof Transaction);\n    var transaction = arg instanceof Transaction ? arg.toObject() : arg;\n    transaction.inputs.forEach(input => {\n      if (!input.output || !input.output.script) {\n        this.uncheckedAddInput(new Input(input));\n        return;\n      }\n\n      var script = new Script(input.output.script);\n      var txin;\n\n      if (script.isPublicKeyHashOut()) {\n        txin = new PublicKeyHashInput(input);\n      } else if (script.isScriptHashOut() && input.publicKeys && input.threshold) {\n        txin = new MultiSigScriptHashInput(input, input.publicKeys, input.threshold, input.signatures);\n      } else if (script.isPublicKeyOut()) {\n        txin = new PublicKeyInput(input);\n      } else {\n        throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\n      }\n\n      this.addInput(txin);\n    });\n    transaction.outputs.forEach(output => this.addOutput(new Output(output)));\n\n    if (transaction.changeIndex) {\n      this._changeIndex = transaction.changeIndex;\n    }\n\n    if (transaction.changeScript) {\n      this._changeScript = new Script(transaction.changeScript);\n    }\n\n    if (transaction.fee) {\n      this._fee = transaction.fee;\n    }\n\n    this.nLockTime = transaction.nLockTime;\n    this.version = transaction.version;\n\n    this._checkConsistency(arg);\n\n    return this;\n  }\n\n  _checkConsistency(arg) {\n    if (this._changeIndex !== undefined) {\n      preconditions.checkState(this._changeScript, 'Change script missing');\n      preconditions.checkState(this.outputs[this._changeIndex], 'Change output missing');\n      preconditions.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), 'Script in argument does not match script in transaction');\n    }\n\n    if (arg && arg.hash) {\n      preconditions.checkState(arg.hash === this.hash, 'Hash in argument does not match transaction hash');\n    }\n  }\n  /**\n   * Sets nLockTime so that transaction is not valid until the desired date(a\n   * timestamp in seconds since UNIX epoch is also accepted)\n   *\n   * @param {Date | Number} time\n   * @return {Transaction} this\n   */\n\n\n  lockUntilDate(time) {\n    preconditions.checkArgument(time);\n\n    if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      throw new errors.Transaction.LockTimeTooEarly();\n    }\n\n    if (_.isDate(time)) {\n      time = time.getTime() / 1000;\n    }\n\n    this.inputs.forEach(input => {\n      if (input.sequenceNumber === Input.DEFAULT_SEQNUMBER) {\n        input.sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n      }\n    });\n    this.nLockTime = time;\n    return this;\n  }\n  /**\n   * Sets nLockTime so that transaction is not valid until the desired block\n   * height.\n   *\n   * @param {Number} height\n   * @return {Transaction} this\n   */\n\n\n  lockUntilBlockHeight(height) {\n    preconditions.checkArgument(_.isNumber(height), 'Block height must be a number');\n\n    if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      throw new errors.Transaction.BlockHeightTooHigh();\n    }\n\n    if (height < 0) {\n      throw new errors.Transaction.NLockTimeOutOfRange();\n    }\n\n    this.inputs.forEach(input => {\n      if (input.sequenceNumber === Input.DEFAULT_SEQNUMBER) {\n        input.sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n      }\n    });\n    this.nLockTime = height;\n    return this;\n  }\n  /**\n   *  Returns a semantic version of the transaction's nLockTime.\n   *  @return {Number|Date}\n   *  If nLockTime is 0, it returns null,\n   *  if it is < 500000000, it returns a block height (number)\n   *  else it returns a Date object.\n   */\n\n\n  getLockTime() {\n    if (!this.nLockTime) {\n      return null;\n    }\n\n    if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n      return this.nLockTime;\n    }\n\n    return new Date(1000 * this.nLockTime);\n  }\n\n  fromString(string) {\n    this.fromBuffer(Buffer.from(string, 'hex'));\n  }\n\n  _newTransaction() {\n    this.version = CURRENT_VERSION;\n    this.nLockTime = DEFAULT_NLOCKTIME;\n  }\n  /**\n   * Add an input to this transaction. This is a high level interface\n   * to add an input, for more control, use @{link Transaction#addInput}.\n   *\n   * Can receive, as output information, the output of bitcoind's `listunspent` command,\n   * and a slightly fancier format recognized by bitcore:\n   *\n   * ```\n   * {\n   *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n   *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n   *  outputIndex: 0,\n   *  script: Script.empty(),\n   *  satoshis: 1020000\n   * }\n   * ```\n   * Where `address` can be either a string or a bitcore Address object. The\n   * same is true for `script`, which can be a string or a bitcore Script.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @example\n   * ```javascript\n   * var transaction = new Transaction();\n   *\n   * // From a pay to public key hash output from bitcoind's listunspent\n   * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n   *\n   * // From a pay to public key hash output\n   * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n   *\n   * // From a multisig P2SH output\n   * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n   *                  ['03000...', '02000...'], 2);\n   * ```\n   *\n   * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} txs\n   * @param {Array=} pubkeys\n   * @param {number=} threshold\n   */\n\n\n  from(txs, pubkeys, threshold) {\n    if (Array.isArray(txs)) {\n      txs.forEach(tx => this.from(tx, pubkeys, threshold));\n      return this;\n    } // TODO: Maybe prevTxId should be a string? Or defined as read only property?\n    // Check if the utxo has already been added as an input\n\n\n    var utxoExists = this.inputs.some(input => input.prevTxId.toString('hex') === txs.txId && input.outputIndex === txs.outputIndex);\n    var Clazz;\n    var utxo = new UnspentOutput(txs);\n\n    if (utxoExists) {\n      return this; // P2SH case\n    }\n\n    if (pubkeys && threshold) {\n      preconditions.checkArgument(threshold <= pubkeys.length, 'Number of signatures must be greater than the number of public keys');\n\n      if (utxo.script.isMultisigOut()) {\n        Clazz = MultiSigInput;\n      } else if (utxo.script.isScriptHashOut()) {\n        Clazz = MultiSigScriptHashInput;\n      } else {\n        Clazz = MultiSigInput;\n      } // non P2SH case\n\n    } else if (utxo.script.isPublicKeyHashOut()) {\n      Clazz = PublicKeyHashInput;\n    } else if (utxo.script.isPublicKeyOut()) {\n      Clazz = PublicKeyInput;\n    } else {\n      Clazz = Input;\n    }\n\n    var input = new Clazz({\n      output: new Output({\n        script: utxo.script,\n        satoshis: utxo.satoshis\n      }),\n      prevTxId: utxo.txId,\n      outputIndex: utxo.outputIndex,\n      script: Script.empty()\n    }, pubkeys, threshold);\n    this.addInput(input);\n    return this;\n  }\n  /**\n   * Add an input to this transaction. The input must be an instance of the `Input` class.\n   * It should have information about the Output that it's spending, but if it's not already\n   * set, two additional parameters, `outputScript` and `satoshis` can be provided.\n   *\n   * @param {Input} input\n   * @param {String|Script} outputScript\n   * @param {number} satoshis\n   * @return Transaction this, for chaining\n   */\n\n\n  addInput(input, outputScript, satoshis) {\n    preconditions.checkArgumentType(input, Input, 'Trying to add input of type other than input');\n\n    if (!input.output && (outputScript === undefined || satoshis === undefined)) {\n      throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\n    }\n\n    if (!input.output && outputScript && satoshis !== undefined) {\n      outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\n      preconditions.checkArgumentType(satoshis, 'number', 'Satoshis must be a number when adding input');\n      input.output = new Output({\n        script: outputScript,\n        satoshis\n      });\n    }\n\n    return this.uncheckedAddInput(input);\n  }\n  /**\n   * Add an input to this transaction, without checking that the input has information about\n   * the output that it's spending.\n   *\n   * @param {Input} input\n   * @return Transaction this, for chaining\n   */\n\n\n  uncheckedAddInput(input) {\n    preconditions.checkArgumentType(input, Input, 'Trying to add input of type other than input');\n    this.inputs.push(input);\n    this._inputAmount = undefined;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Returns true if the transaction has enough info on all inputs to be correctly validated\n   *\n   * @return {boolean}\n   */\n\n\n  hasAllUtxoInfo() {\n    return this.inputs.map(input => !!input.output);\n  }\n  /**\n   * Manually set the fee for this transaction. Beware that this resets all the signatures\n   * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n   * be reset).\n   *\n   * @param {number} amount satoshis to be sent\n   * @return {Transaction} this, for chaining\n   */\n\n\n  fee(amount) {\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    this._fee = amount;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\n   * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n   * be reset).\n   *\n   * @param {number} amount satoshis per KB to be sent\n   * @return {Transaction} this, for chaining\n   */\n\n\n  feePerKb(amount) {\n    preconditions.checkArgument(_.isNumber(amount), 'Amount must be a number');\n    this._feePerKb = amount;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Set the change address for this transaction\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {Address} address An address for change to be sent to.\n   * @return {Transaction} this, for chaining\n   */\n\n\n  change(address) {\n    preconditions.checkArgument(address, 'Address is required');\n    this._changeScript = Script.fromAddress(address);\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * @return {Output} change output, if it exists\n   */\n\n\n  getChangeOutput() {\n    if (this._changeIndex !== undefined) {\n      return this.outputs[this._changeIndex];\n    }\n\n    return null;\n  }\n  /**\n   * Add an output to the transaction.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {(string|Address|Array.<Transaction~toObject>)} address\n   * @param {number} amount in satoshis\n   * @return {Transaction} this, for chaining\n   */\n\n\n  to(address, amount) {\n    if (Array.isArray(address)) {\n      var self = this;\n      address.forEach(to => self.to(to.address, to.satoshis));\n      return this;\n    }\n\n    preconditions.checkArgument(JSUtil.isNaturalNumber(amount), 'Amount is expected to be a positive integer');\n    this.addOutput(new Output({\n      script: Script(new Address(address)),\n      satoshis: amount\n    }));\n    return this;\n  }\n  /**\n   * Add an OP_RETURN output to the transaction.\n   *\n   * Beware that this resets all the signatures for inputs (in further versions,\n   * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n   *\n   * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\n   *    In case of a string, the UTF-8 representation will be stored\n   * @return {Transaction} this, for chaining\n   */\n\n\n  addData(value) {\n    this.addOutput(new Output({\n      script: Script.buildDataOut(value),\n      satoshis: 0\n    }));\n    return this;\n  }\n  /**\n   * Add an output to the transaction.\n   *\n   * @param {Output} output the output to add.\n   * @return {Transaction} this, for chaining\n   */\n\n\n  addOutput(output) {\n    preconditions.checkArgumentType(output, Output, 'Output needs to be of type output');\n\n    this._addOutput(output);\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n  /**\n   * Remove all outputs from the transaction.\n   *\n   * @return {Transaction} this, for chaining\n   */\n\n\n  clearOutputs() {\n    this.outputs = [];\n\n    this._clearSignatures();\n\n    this._outputAmount = undefined;\n    this._changeIndex = undefined;\n\n    this._updateChangeOutput();\n\n    return this;\n  }\n\n  _addOutput(output) {\n    this.outputs.push(output);\n    this._outputAmount = undefined;\n  }\n  /**\n   * Calculates or gets the total output amount in satoshis\n   *\n   * @return {Number} the transaction total output amount\n   */\n\n\n  _getOutputAmount() {\n    if (this._outputAmount === undefined) {\n      this._outputAmount = this.outputs.reduce((acc, output) => acc + output.satoshis, 0);\n    }\n\n    return this._outputAmount;\n  }\n  /**\n   * Calculates or gets the total input amount in satoshis\n   *\n   * @return {Number} the transaction total input amount\n   */\n\n\n  _getInputAmount() {\n    if (this._inputAmount === undefined) {\n      var self = this;\n      this._inputAmount = 0;\n      this.inputs.forEach(input => {\n        if (input.output === undefined) {\n          throw new errors.Transaction.Input.MissingPreviousOutput();\n        }\n\n        self._inputAmount += input.output.satoshis;\n      });\n    }\n\n    return this._inputAmount;\n  }\n\n  _updateChangeOutput() {\n    if (!this._changeScript) {\n      return;\n    }\n\n    this._clearSignatures();\n\n    if (this._changeIndex !== undefined) {\n      this._removeOutput(this._changeIndex);\n    }\n\n    var available = this._getUnspentValue();\n\n    var fee = this.getFee();\n    var changeAmount = available - fee;\n\n    if (changeAmount > 0) {\n      this._changeIndex = this.outputs.length;\n\n      this._addOutput(new Output({\n        script: this._changeScript,\n        satoshis: changeAmount\n      }));\n    } else {\n      this._changeIndex = undefined;\n    }\n  }\n  /**\n   * Calculates the fee of the transaction.\n   *\n   * If there's a fixed fee set, return that.\n   *\n   * If there is no change output set, the fee is the\n   * total value of the outputs minus inputs. Note that\n   * a serialized transaction only specifies the value\n   * of its outputs. (The value of inputs are recorded\n   * in the previous transaction outputs being spent.)\n   * This method therefore raises a \"MissingPreviousOutput\"\n   * error when called on a serialized transaction.\n   *\n   * If there's no fee set and no change address,\n   * estimate the fee based on size.\n   *\n   * @return {Number} fee of this transaction in satoshis\n   */\n\n\n  getFee() {\n    if (this.isCoinbase()) {\n      return 0;\n    }\n\n    if (this._fee !== undefined) {\n      return this._fee;\n    } // if no change output is set, fees should equal all the unspent amount\n\n\n    if (!this._changeScript) {\n      return this._getUnspentValue();\n    }\n\n    return this._estimateFee();\n  }\n  /**\n   * Estimates fee from serialized transaction size in bytes.\n   */\n\n\n  _estimateFee() {\n    var estimatedSize = this._estimateSize();\n\n    var available = this._getUnspentValue();\n\n    return Transaction._estimateFee(estimatedSize, available, this._feePerKb);\n  }\n\n  _getUnspentValue() {\n    return this._getInputAmount() - this._getOutputAmount();\n  }\n\n  _clearSignatures() {\n    this.inputs.forEach(input => input.clearSignatures());\n  }\n\n  _estimateSize() {\n    var result = this.inputs.reduce((acc, input) => acc + input._estimateSize(), Transaction.MAXIMUM_EXTRA_SIZE);\n    result = this.outputs.reduce((acc, output) => acc + output.script.toBuffer().length + 9, result);\n    return result;\n  }\n\n  _removeOutput(index) {\n    var output = this.outputs[index];\n    this.outputs = this.outputs.filter(val => val !== output);\n    this._outputAmount = undefined;\n  }\n\n  removeOutput(index) {\n    this._removeOutput(index);\n\n    this._updateChangeOutput();\n  }\n  /**\n   * Sort a transaction's inputs and outputs according to BIP69\n   *\n   * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\n   * @return {Transaction} this\n   */\n\n\n  sort() {\n    /* eslint-disable max-len */\n    this.sortInputs(inputs => {\n      var copy = Array.prototype.concat.apply([], inputs);\n      copy.sort((first, second) => compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex);\n      return copy;\n    });\n    this.sortOutputs(outputs => {\n      var copy = Array.prototype.concat.apply([], outputs);\n      copy.sort((first, second) => first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()));\n      return copy;\n    });\n    /* eslint-enable max-len */\n\n    return this;\n  }\n  /**\n   * Randomize this transaction's outputs ordering. The shuffling algorithm is a\n   * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\n   *\n   * @return {Transaction} this\n   */\n\n\n  shuffleOutputs() {\n    return this.sortOutputs(_.shuffle);\n  }\n  /**\n   * Sort this transaction's outputs, according to a given sorting function that\n   * takes an array as argument and returns a new array, with the same elements\n   * but with a different order. The argument function MUST NOT modify the order\n   * of the original array\n   *\n   * @param {Function} sortingFunction\n   * @return {Transaction} this\n   */\n\n\n  sortOutputs(sortingFunction) {\n    var outs = sortingFunction(this.outputs);\n    return this._newOutputOrder(outs);\n  }\n  /**\n   * Sort this transaction's inputs, according to a given sorting function that\n   * takes an array as argument and returns a new array, with the same elements\n   * but with a different order.\n   *\n   * @param {Function} sortingFunction\n   * @return {Transaction} this\n   */\n\n\n  sortInputs(sortingFunction) {\n    this.inputs = sortingFunction(this.inputs);\n\n    this._clearSignatures();\n\n    return this;\n  }\n\n  _newOutputOrder(newOutputs) {\n    var isInvalidSorting = this.outputs.length !== newOutputs.length || _.difference(this.outputs, newOutputs).length !== 0;\n\n    if (isInvalidSorting) {\n      throw new errors.Transaction.InvalidSorting();\n    }\n\n    if (this._changeIndex !== undefined) {\n      var changeOutput = this.outputs[this._changeIndex];\n      this._changeIndex = _.findIndex(newOutputs, changeOutput);\n    }\n\n    this.outputs = newOutputs;\n    return this;\n  }\n\n  removeInput(txId, outputIndex) {\n    var index;\n\n    if (!outputIndex && _.isNumber(txId)) {\n      index = txId;\n    } else {\n      index = _.findIndex(this.inputs, input => input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex);\n    }\n\n    if (index < 0 || index >= this.inputs.length) {\n      throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\n    }\n\n    var input = this.inputs[index];\n    this.inputs = _.without(this.inputs, input);\n    this._inputAmount = undefined;\n\n    this._updateChangeOutput();\n  }\n  /**\n   * Sign the transaction using one or more private keys.\n   *\n   * It tries to sign each input, verifying that the signature will be valid\n   * (matches a public key).\n   *\n   * @param {Array|String|PrivateKey} privateKeys\n   * @param {number} sigtype\n   * @return {Transaction} this, for chaining\n   */\n\n\n  sign(privateKeys, sigtype) {\n    preconditions.checkState(this.hasAllUtxoInfo(), 'Cannot sign because an input is not defined');\n    var self = this;\n\n    if (Array.isArray(privateKeys)) {\n      privateKeys.forEach(privateKey => self.sign(privateKey, sigtype));\n      return this;\n    }\n\n    var signatures = this.getSignatures(privateKeys, sigtype);\n    signatures.forEach(signature => self.applySignature(signature));\n    return this;\n  }\n\n  getSignatures(privKey, sigtype) {\n    privKey = new PrivateKey(privKey); // By default, signs using ALL|FORKID\n\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var transaction = this;\n    var results = [];\n    var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\n    this.inputs.forEach((input, index) => {\n      var signatures = input.getSignatures(transaction, privKey, index, sigtype, hashData);\n      signatures.forEach(signature => results.push(signature));\n    });\n    return results;\n  }\n  /**\n   * Add a signature to the transaction\n   *\n   * @param {Object} signature\n   * @param {number} signature.inputIndex\n   * @param {number} signature.sigtype\n   * @param {PublicKey} signature.publicKey\n   * @param {Signature} signature.signature\n   * @return {Transaction} this, for chaining\n   */\n\n\n  applySignature(signature) {\n    this.inputs[signature.inputIndex].addSignature(this, signature);\n    return this;\n  }\n\n  isFullySigned() {\n    this.inputs.forEach(input => {\n      if (input.isFullySigned === Input.prototype.isFullySigned) {\n        throw new errors.Transaction.UnableToVerifySignature('Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction');\n      }\n    });\n    return this.inputs.map(input => input.isFullySigned()).every(x => x);\n  }\n\n  isValidSignature(signature) {\n    var self = this;\n\n    if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\n      throw new errors.Transaction.UnableToVerifySignature('Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction');\n    }\n\n    return this.inputs[signature.inputIndex].isValidSignature(self, signature);\n  }\n  /**\n   * @returns {bool} whether the signature is valid for this transaction input\n   */\n\n\n  verifySignature(sig, pubkey, nin, subscript) {\n    return Sighash.verify(this, sig, pubkey, nin, subscript);\n  }\n  /**\n   * Check that a transaction passes basic sanity tests. If not, return a string\n   * describing the error. This function contains the same logic as\n   * CheckTransaction in bitcoin core.\n   */\n\n\n  verify() {\n    var i; // Basic checks that don't depend on any context\n\n    if (this.inputs.length === 0) {\n      return 'transaction txins empty';\n    }\n\n    if (this.outputs.length === 0) {\n      return 'transaction txouts empty';\n    } // Check for negative or overflow output values\n\n\n    var valueoutbn = new BN(0);\n\n    for (i = 0; i < this.outputs.length; i += 1) {\n      if (this.outputs[i].invalidSatoshis()) {\n        return 'Transaction output contains invalid amount';\n      }\n\n      if (this.outputs[i]._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\n        return 'Transaction output contains too high satoshi amount';\n      }\n\n      valueoutbn = valueoutbn.add(this.outputs[i]._satoshisBN);\n\n      if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\n        return 'Transaction output contains too high satoshi amount';\n      }\n    } // Size limits\n\n\n    if (this.toBuffer().length > MAX_BLOCK_SIZE) {\n      return 'Transaction over the maximum block size';\n    } // Check for duplicate inputs\n\n\n    var txinmap = {};\n\n    for (i = 0; i < this.inputs.length; i += 1) {\n      var inputid = \"\".concat(this.inputs[i].prevTxId, \":\").concat(this.inputs[i].outputIndex);\n\n      if (txinmap[inputid] !== undefined) {\n        return 'Transaction contains duplicate input';\n      }\n\n      txinmap[inputid] = true;\n    }\n\n    var isCoinbase = this.isCoinbase();\n\n    if (isCoinbase) {\n      var buf = this.inputs[0]._scriptBuffer;\n\n      if (buf.length < 2 || buf.length > 100) {\n        return 'Coinbase transaction script size invalid';\n      }\n    } else if (this.inputs.filter(input => input.isNull()).length > 0) {\n      return 'Transaction has null input';\n    }\n\n    return true;\n  }\n  /**\n   * Analogous to bitcoind's IsCoinBase function in transaction.h\n   */\n\n\n  isCoinbase() {\n    return this.inputs.length === 1 && this.inputs[0].isNull();\n  }\n  /**\n   * Determines if this transaction can be replaced in the mempool with another\n   * transaction that provides a sufficiently higher fee (RBF).\n   */\n\n\n  isRBF() {\n    return this.inputs.some(input => input.sequenceNumber < Input.MAXINT - 1);\n  }\n  /**\n   * Enable this transaction to be replaced in the mempool (RBF) if a transaction\n   * includes a sufficiently higher fee. It will set the sequenceNumber to\n   * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\n   * already enable RBF.\n   */\n\n\n  enableRBF() {\n    this.inputs = this.inputs.map(input => {\n      if (input.sequenceNumber >= Input.MAXINT - 1) {\n        input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\n      }\n\n      return input;\n    });\n    return this;\n  }\n  /**\n   * Create a 'shallow' copy of the transaction, by serializing and deserializing\n   * it dropping any additional information that inputs and outputs may have hold\n   *\n   * @param {Transaction} transaction\n   * @return {Transaction}\n   */\n\n\n  static shallowCopy(transaction) {\n    return new Transaction(transaction.toBuffer());\n  }\n\n  static _estimateFee(size, amountAvailable, feePerKb) {\n    var fee = Math.ceil(size / 1000 * (feePerKb || Transaction.FEE_PER_KB));\n\n    if (amountAvailable > fee) {\n      size += Transaction.CHANGE_OUTPUT_MAX_SIZE;\n    }\n\n    return Math.ceil(size / 1000 * (feePerKb || Transaction.FEE_PER_KB));\n  }\n\n} // Minimum amount for an output for it not to be considered a dust output\n\n\nTransaction.DUST_AMOUNT = 546; // Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big\n// difference.\n\nTransaction.FEE_SECURITY_MARGIN = 150; // max amount of satoshis in circulation\n\nTransaction.MAX_MONEY = 21000000 * 1e8; // nlocktime limit to be considered block height rather than a timestamp\n\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8; // Max value for an unsigned 32 bit value\n\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295; // Value used for fee estimation (satoshis per kilobyte)\n\nTransaction.FEE_PER_KB = 20000; // Safe upper bound for change address script size in bytes\n\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\n\nclass Block {\n  constructor(arg) {\n    if (!(this instanceof Block)) {\n      return new Block(arg);\n    }\n\n    _.extend(this, Block._from(arg));\n\n    return this;\n  }\n  /**\n   * @param {*} - A Buffer, JSON string or Object\n   * @returns {Object} - An object representing block data\n   * @throws {TypeError} - If the argument was not recognized\n   * @private\n   */\n\n\n  static _from(arg) {\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = Block._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      info = Block._fromObject(arg);\n    } else {\n      throw new TypeError('Unrecognized argument for Block');\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Object} - An object representing block data\n   * @private\n   */\n\n\n  static _fromObject(data) {\n    var transactions = [];\n    data.transactions.forEach(tx => {\n      if (tx instanceof Transaction) {\n        transactions.push(tx);\n      } else {\n        transactions.push(new Transaction().fromObject(tx));\n      }\n    });\n    var info = {\n      header: BlockHeader.fromObject(data.header),\n      transactions\n    };\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromObject(obj) {\n    var info = Block._fromObject(obj);\n\n    return new Block(info);\n  }\n  /**\n   * @param {BufferReader} - Block data\n   * @returns {Object} - An object representing the block data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var info = {};\n    preconditions.checkState(!br.finished(), 'No block data received');\n    info.header = BlockHeader.fromBufferReader(br);\n    var transactions = br.readVarintNum();\n    info.transactions = [];\n\n    for (var i = 0; i < transactions; i += 1) {\n      info.transactions.push(new Transaction().fromBufferReader(br));\n    }\n\n    return info;\n  }\n  /**\n   * @param {BufferReader} - A buffer reader of the block\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromBufferReader(br) {\n    preconditions.checkArgument(br, 'br is required');\n\n    var info = Block._fromBufferReader(br);\n\n    return new Block(info);\n  }\n  /**\n   * @param {Buffer} - A buffer of the block\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromBuffer(buf) {\n    return Block.fromBufferReader(new BufferReader(buf));\n  }\n  /**\n   * @param {string} - str - A hex encoded string of the block\n   * @returns {Block} - A hex encoded string of the block\n   */\n\n\n  static fromString(str) {\n    var buf = Buffer.from(str, 'hex');\n    return Block.fromBuffer(buf);\n  }\n  /**\n   * @param {Binary} - Raw block binary data or buffer\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromRawBlock(data) {\n    if (!BufferUtil.isBuffer(data)) {\n      data = Buffer.from(data, 'binary');\n    }\n\n    var br = BufferReader(data);\n    br.pos = Block.Values.START_OF_BLOCK;\n\n    var info = Block._fromBufferReader(br);\n\n    return new Block(info);\n  }\n  /**\n   * @returns {Object} - A plain object with the block properties\n   */\n\n\n  toJSON() {\n    var transactions = [];\n    this.transactions.forEach(tx => {\n      transactions.push(tx.toObject());\n    });\n    return {\n      header: this.header.toObject(),\n      transactions\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * @returns {Buffer} - A buffer of the block\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @returns {string} - A hex encoded string of the block\n   */\n\n\n  toString() {\n    return this.toBuffer().toString('hex');\n  }\n  /**\n   * @param {BufferWriter} - An existing instance of BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n   */\n\n\n  toBufferWriter(bw) {\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.write(this.header.toBuffer());\n    bw.writeVarintNum(this.transactions.length);\n\n    for (var i = 0; i < this.transactions.length; i += 1) {\n      this.transactions[i].toBufferWriter(bw);\n    }\n\n    return bw;\n  }\n  /**\n   * Will iterate through each transaction and return an array of hashes\n   * @returns {Array} - An array with transaction hashes\n   */\n\n\n  getTransactionHashes() {\n    var hashes = [];\n\n    if (this.transactions.length === 0) {\n      return [Block.Values.NULL_HASH];\n    }\n\n    for (var t = 0; t < this.transactions.length; t += 1) {\n      hashes.push(this.transactions[t]._getHash());\n    }\n\n    return hashes;\n  }\n  /**\n   * Will build a merkle tree of all the transactions, ultimately arriving at\n   * a single point, the merkle root.\n   * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n   * @returns {Array} - An array with each level of the tree after the other.\n   */\n\n\n  getMerkleTree() {\n    var tree = this.getTransactionHashes();\n    var j = 0;\n\n    for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n      for (var i = 0; i < size; i += 2) {\n        var i2 = Math.min(i + 1, size - 1);\n        var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n        tree.push(Hash.sha256sha256(buf));\n      }\n\n      j += size;\n    }\n\n    return tree;\n  }\n  /**\n   * Calculates the merkleRoot from the transactions.\n   * @returns {Buffer} - A buffer of the merkle root hash\n   */\n\n\n  getMerkleRoot() {\n    var tree = this.getMerkleTree();\n    return tree[tree.length - 1];\n  }\n  /**\n   * Verifies that the transactions in the block match the header merkle root\n   * @returns {Boolean} - If the merkle roots match\n   */\n\n\n  validMerkleRoot() {\n    var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n    var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n    if (h.cmp(c) !== 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Buffer} - The little endian hash buffer of the header\n   */\n\n\n  _getHash() {\n    return this.header._getHash();\n  }\n  /**\n   * @returns {string} - A string formatted for the console\n   */\n\n\n  inspect() {\n    return \"<Block \".concat(this.id, \">\");\n  }\n\n} // https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\n\n\nBlock.MAX_BLOCK_SIZE = 1000000;\nvar idProperty$1 = {\n  configurable: false,\n  enumerable: true,\n\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n\n    return this._id;\n  },\n\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty$1);\nObject.defineProperty(Block.prototype, 'hash', idProperty$1);\nBlock.Values = {\n  START_OF_BLOCK: 8,\n  // Start of block in raw block data\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n}; // refactor progress\n\nvar hdErrors = errors.HDPublicKey;\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\nfunction HDPublicKey(arg) {\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      }\n\n      if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      }\n\n      if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n        return new HDPrivateKey(arg).hdPublicKey;\n      }\n\n      throw error;\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        }\n\n        return this._buildFromObject(arg);\n      }\n\n      throw new hdErrors.UnrecognizedArgument(arg);\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  }\n\n  throw new hdErrors.InvalidDerivationArgument(arg);\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode,\n    publicKey\n  });\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce((prev, index) => prev._deriveWithNumber(index), this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Networks.livenet.xprivkey || version === Networks.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Networks.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Networks.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  // TODO: Type validation\n  var publicKey;\n\n  if (_.isString(arg.publicKey)) {\n    publicKey = BufferUtil.hexToBuffer(arg.publicKey);\n  } else if (BufferUtil.isBuffer(arg.publicKey)) {\n    publicKey = arg.publicKey;\n  } else {\n    publicKey = arg.publicKey.toBuffer();\n  }\n\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Networks.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey,\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.publicKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n    throw new errors.InvalidB58Checksum(concat, checksum);\n  }\n\n  var network = Networks.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey,\n    network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey,\n    fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), \"\".concat(name, \" argument is not a buffer, it's \").concat(typeof buff));\n    assert(buff.length === size, \"\".concat(name, \" size unexpected: found \").concat(buff.length, \", expected \").concat(size));\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  preconditions.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  preconditions.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return \"<HDPublicKey: \".concat(this.xpubkey, \">\");\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Networks.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON;\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nvar hdErrors$1 = errors.HDPrivateKey;\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\n\nfunction HDPrivateKey(arg) {\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Networks.get(arg)) {\n    return this._generateRandomly(arg);\n  }\n\n  if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors$1.UnrecognizedArgument(arg);\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\n\n\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/'); // Special cases:\n\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(step => {\n    var isHardened = step.slice(-1) === \"'\";\n\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n\n    var index = +step; // cast to number\n\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n  return _.some(indexes, Number.isNaN) ? null : indexes;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead.\n * This is not BIP32 compliant.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.derive = function (arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  }\n\n  throw new hdErrors$1.InvalidDerivationArgument(arg);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  }\n\n  if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  }\n\n  throw new hdErrors$1.InvalidDerivationArgument(arg);\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors$1.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({\n      size: 32\n    });\n    assert(privateKeyBuffer.length === 32, 'private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode,\n    privateKey\n  });\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors$1.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce((prev, index) => prev._deriveWithNumber(index, null, nonCompliant), this);\n  return derived;\n};\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\n\n\nHDPrivateKey.getSerializedError = function (data, network) {\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors$1.UnrecognizedArgument('Expected string or buffer');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors$1.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Networks.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(0, 4);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPrivateKey.fromString = function (arg) {\n  preconditions.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function (arg) {\n  preconditions.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  // TODO: Type validation\n  var checksum;\n\n  if (arg.checksum) {\n    if (arg.checksum.length) {\n      checksum = arg.checksum;\n    } else {\n      checksum = BufferUtil.integerAsBuffer(arg.checksum);\n    }\n  }\n\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Networks.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\n\n\nHDPrivateKey.fromSeed = function (hexa, network) {\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors$1.InvalidEntropyArgument(hexa);\n  }\n\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors$1.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors$1.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Networks.get(network) || Networks.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.privateKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\n\n\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = Buffer.concat(sequence);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n    throw new errors.InvalidB58Checksum(concat);\n  }\n\n  var network = Networks.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey = Base58Check.encode(Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey,\n    network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey,\n    publicKey,\n    fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n\n    get() {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey;\n    }\n\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n\n    get() {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey.xpubkey;\n    }\n\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), \"\".concat(name, \" argument is not a buffer\"));\n    assert(buff.length === size, \"\".concat(name, \" size unexpected: found \").concat(buff.length, \", expected \").concat(size));\n  };\n\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\n\n\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\n\n\nHDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Networks.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON;\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\n\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\n\n\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', \"m'\", \"M'\"];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\n\nclass MerkleBlock {\n  constructor(arg) {\n    if (!(this instanceof MerkleBlock)) {\n      return new MerkleBlock(arg);\n    }\n\n    var info = {};\n\n    if (BufferUtil.isBuffer(arg)) {\n      info = MerkleBlock._fromBufferReader(BufferReader(arg));\n    } else if (_.isObject(arg)) {\n      var header;\n\n      if (arg.header instanceof BlockHeader) {\n        header = arg.header;\n      } else {\n        header = BlockHeader.fromObject(arg.header);\n      }\n\n      info = {\n        /**\n         * @name MerkleBlock#header\n         * @type {BlockHeader}\n         */\n        header,\n\n        /**\n         * @name MerkleBlock#numTransactions\n         * @type {Number}\n         */\n        numTransactions: arg.numTransactions,\n\n        /**\n         * @name MerkleBlock#hashes\n         * @type {String[]}\n         */\n        hashes: arg.hashes,\n\n        /**\n         * @name MerkleBlock#flags\n         * @type {Number[]}\n         */\n        flags: arg.flags\n      };\n    } else {\n      throw new TypeError('Unrecognized argument for MerkleBlock');\n    }\n\n    _.extend(this, info);\n\n    this._flagBitsUsed = 0;\n    this._hashesUsed = 0;\n    return this;\n  }\n  /**\n   * @param {Buffer} - MerkleBlock data in a Buffer object\n   * @returns {MerkleBlock} - A MerkleBlock object\n   */\n\n\n  static fromBuffer(buf) {\n    return MerkleBlock.fromBufferReader(BufferReader(buf));\n  }\n  /**\n   * @param {BufferReader} - MerkleBlock data in a BufferReader object\n   * @returns {MerkleBlock} - A MerkleBlock object\n   */\n\n\n  static fromBufferReader(br) {\n    return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n  }\n  /**\n   * @returns {Buffer} - A buffer of the block\n   */\n\n\n  toBuffer() {\n    return this.toBufferWriter().concat();\n  }\n  /**\n   * @param {BufferWriter} - An existing instance of BufferWriter\n   * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n   */\n\n\n  toBufferWriter(bw) {\n    var i;\n\n    if (!bw) {\n      bw = new BufferWriter();\n    }\n\n    bw.write(this.header.toBuffer());\n    bw.writeUInt32LE(this.numTransactions);\n    bw.writeVarintNum(this.hashes.length);\n\n    for (i = 0; i < this.hashes.length; i += 1) {\n      bw.write(Buffer.from(this.hashes[i], 'hex'));\n    }\n\n    bw.writeVarintNum(this.flags.length);\n\n    for (i = 0; i < this.flags.length; i += 1) {\n      bw.writeUInt8(this.flags[i]);\n    }\n\n    return bw;\n  }\n  /**\n   * @returns {Object} - A plain object with the MerkleBlock properties\n   */\n\n\n  toJSON() {\n    return {\n      header: this.header.toObject(),\n      numTransactions: this.numTransactions,\n      hashes: this.hashes,\n      flags: this.flags\n    };\n  }\n\n  toObject() {\n    return this.toJSON();\n  }\n  /**\n   * Verify that the MerkleBlock is valid\n   * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n   */\n\n\n  validMerkleTree() {\n    preconditions.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n    preconditions.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n    if (this.hashes.length > this.numTransactions) {\n      return false;\n    } // Can't have more flag bits than num hashes\n\n\n    if (this.flags.length * 8 < this.hashes.length) {\n      return false;\n    }\n\n    var height = this._calcTreeHeight();\n\n    var opts = {\n      hashesUsed: 0,\n      flagBitsUsed: 0\n    };\n\n    var root = this._traverseMerkleTree(height, 0, opts);\n\n    if (opts.hashesUsed !== this.hashes.length) {\n      return false;\n    }\n\n    return BufferUtil.equals(root, this.header.merkleRoot);\n  }\n  /**\n   * Traverse a the tree in this MerkleBlock, validating it along the way\n   * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n   * @param {Number} - depth - Current height\n   * @param {Number} - pos - Current position in the tree\n   * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n   * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n   * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n   * @param {Array} - opts.txs - Will finish populated by transactions found during traversal\n   * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n   * @private\n   */\n\n\n  _traverseMerkleTree(depth, pos, opts) {\n    opts = opts || {};\n    opts.txs = opts.txs || [];\n    opts.flagBitsUsed = opts.flagBitsUsed || 0;\n    opts.hashesUsed = opts.hashesUsed || 0;\n\n    if (opts.flagBitsUsed > this.flags.length * 8) {\n      return null;\n    }\n\n    var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed & 7) & 1;\n    opts.flagBitsUsed += 1;\n\n    if (depth === 0 || !isParentOfMatch) {\n      if (opts.hashesUsed >= this.hashes.length) {\n        return null;\n      }\n\n      var hash = this.hashes[opts.hashesUsed];\n      opts.hashesUsed += 1;\n\n      if (depth === 0 && isParentOfMatch) {\n        opts.txs.push(hash);\n      }\n\n      return Buffer.from(hash, 'hex');\n    }\n\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n\n    var right = left;\n\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n\n    return Hash.sha256sha256(Buffer.concat([left, right]));\n  }\n  /** Calculates the width of a merkle tree at a given height.\n   *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n   * @param {Number} - Height at which we want the tree width\n   * @returns {Number} - Width of the tree at a given height\n   * @private\n   */\n\n\n  _calcTreeWidth(height) {\n    return this.numTransactions + (1 << height) - 1 >> height;\n  }\n  /** Calculates the height of the merkle tree in this MerkleBlock\n   * @param {Number} - Height at which we want the tree width\n   * @returns {Number} - Height of the merkle tree in this MerkleBlock\n   * @private\n   */\n\n\n  _calcTreeHeight() {\n    var height = 0;\n\n    while (this._calcTreeWidth(height) > 1) {\n      height += 1;\n    }\n\n    return height;\n  }\n  /**\n   * @param {Transaction|String} - Transaction or Transaction ID Hash\n   * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n   * @private\n   */\n\n\n  hasTransaction(tx) {\n    preconditions.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n    preconditions.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n    var hash = tx;\n\n    if (tx instanceof Transaction) {\n      // We need to reverse the id hash for the lookup\n      hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n    }\n\n    var txs = [];\n\n    var height = this._calcTreeHeight();\n\n    this._traverseMerkleTree(height, 0, {\n      txs\n    });\n\n    return txs.indexOf(hash) !== -1;\n  }\n  /**\n   * @param {Buffer} - MerkleBlock data\n   * @returns {Object} - An Object representing merkleblock data\n   * @private\n   */\n\n\n  static _fromBufferReader(br) {\n    var i;\n    preconditions.checkState(!br.finished(), 'No merkleblock data received');\n    var info = {};\n    info.header = BlockHeader.fromBufferReader(br);\n    info.numTransactions = br.readUInt32LE();\n    var numHashes = br.readVarintNum();\n    info.hashes = [];\n\n    for (i = 0; i < numHashes; i += 1) {\n      info.hashes.push(br.read(32).toString('hex'));\n    }\n\n    var numFlags = br.readVarintNum();\n    info.flags = [];\n\n    for (i = 0; i < numFlags; i += 1) {\n      info.flags.push(br.readUInt8());\n    }\n\n    return info;\n  }\n  /**\n   * @param {Object} - A plain JavaScript object\n   * @returns {Block} - An instance of block\n   */\n\n\n  static fromObject(obj) {\n    return new MerkleBlock(obj);\n  }\n\n}\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\n\n\nclass Message {\n  constructor(message) {\n    preconditions.checkArgument(_.isString(message), 'First argument should be a string');\n    this.message = message;\n    return this;\n  }\n\n  magicHash() {\n    var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n    var messageBuffer = Buffer.from(this.message);\n    var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n    var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n    var hash = Hash.sha256sha256(buf);\n    return hash;\n  }\n\n  _sign(privateKey) {\n    preconditions.checkArgument(privateKey instanceof PrivateKey, 'First argument should be a PrivateKey');\n    var hash = this.magicHash();\n    var ecdsa = new ECDSA();\n    ecdsa.hashbuf = hash;\n    ecdsa.privkey = privateKey;\n    ecdsa.pubkey = privateKey.toPublicKey();\n    ecdsa.signRandomK();\n    ecdsa.calci();\n    return ecdsa.sig;\n  }\n  /**\n   * Will sign a message with a given bitcoin private key.\n   *\n   * @param {PrivateKey} privateKey - An instance of PrivateKey\n   * @returns {String} A base64 encoded compact signature\n   */\n\n\n  sign(privateKey) {\n    var signature = this._sign(privateKey);\n\n    return signature.toCompact().toString('base64');\n  }\n\n  _verify(publicKey, signature) {\n    preconditions.checkArgument(publicKey instanceof PublicKey, 'First argument should be a PublicKey');\n    preconditions.checkArgument(signature instanceof Signature, 'Second argument should be a Signature');\n    var hash = this.magicHash();\n    var verified = ECDSA.verify(hash, signature, publicKey);\n\n    if (!verified) {\n      this.error = 'The signature was invalid';\n    }\n\n    return verified;\n  }\n  /**\n   * Will return a boolean if the signature is valid for a given bitcoin address.\n   * If it isn't the specific reason is accessible via the \"error\" member.\n   *\n   * @param {Address|String} bitcoinAddress - A bitcoin address\n   * @param {String} signatureString - A base64 encoded compact signature\n   * @returns {Boolean}\n   */\n\n\n  verify(bitcoinAddress, signatureString) {\n    preconditions.checkArgument(bitcoinAddress);\n    preconditions.checkArgument(signatureString && _.isString(signatureString));\n\n    if (_.isString(bitcoinAddress)) {\n      bitcoinAddress = Address.fromString(bitcoinAddress);\n    }\n\n    var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64')); // recover the public key\n\n    var ecdsa = new ECDSA();\n    ecdsa.hashbuf = this.magicHash();\n    ecdsa.sig = signature;\n    var publicKey = ecdsa.toPublicKey();\n    var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network); // check that the recovered address and specified address match\n\n    if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n      this.error = 'The signature did not match the message digest';\n      return false;\n    }\n\n    return this._verify(publicKey, signature);\n  }\n  /**\n   * Instantiate a message from a message string\n   *\n   * @param {String} str - A string of the message\n   * @returns {Message} A new instance of a Message\n   */\n\n\n  static fromString(str) {\n    return new Message(str);\n  }\n  /**\n   * Instantiate a message from JSON\n   *\n   * @param {String} json - An JSON string or Object with keys: message\n   * @returns {Message} A new instance of a Message\n   */\n\n\n  static fromJSON(json) {\n    if (JSUtil.isValidJSON(json)) {\n      json = JSON.parse(json);\n    }\n\n    return new Message(json.message);\n  }\n  /**\n   * @returns {Object} A plain object with the message information\n   */\n\n\n  toObject() {\n    return {\n      message: this.message\n    };\n  }\n  /**\n   * @returns {String} A JSON representation of the message information\n   */\n\n\n  toJSON() {\n    return JSON.stringify(this.toObject());\n  }\n  /**\n   * Will return a the string representation of the message\n   *\n   * @returns {String} Message\n   */\n\n\n  toString() {\n    return this.message;\n  }\n  /**\n   * Will return a string formatted for the console\n   *\n   * @returns {String} Message\n   */\n\n\n  inspect() {\n    return \"<Message: \".concat(this.toString(), \">\");\n  }\n\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n/**\n * PDKBF2\n * Credit to: https://github.com/stayradiated/pbkdf2-sha512\n * Copyright (c) 2014, JP Richardson Copyright (c) 2010-2011 Intalio Pte, All Rights Reserved\n */\n\nfunction pbkdf2(key, salt, iterations, dkLen) {\n  var hLen = 64; // SHA512 Mac length\n\n  if (dkLen > (2 ** 32 - 1) * hLen) {\n    throw Error('Requested key length too long');\n  }\n\n  if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n    throw new TypeError('key must a string or Buffer');\n  }\n\n  if (typeof salt !== 'string' && !Buffer.isBuffer(salt)) {\n    throw new TypeError('salt must a string or Buffer');\n  }\n\n  if (typeof key === 'string') {\n    key = Buffer.from(key);\n  }\n\n  if (typeof salt === 'string') {\n    salt = Buffer.from(salt);\n  }\n\n  var DK = Buffer.alloc(dkLen);\n  var U = Buffer.alloc(hLen);\n  var T = Buffer.alloc(hLen);\n  var block1 = Buffer.alloc(salt.length + 4);\n  var l = Math.ceil(dkLen / hLen);\n  var r = dkLen - (l - 1) * hLen;\n  salt.copy(block1, 0, 0, salt.length);\n\n  for (var i = 1; i <= l; i += 1) {\n    block1[salt.length + 0] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i >> 0 & 0xff;\n    var digest = hash.hmac(hash.sha512, key).update(block1).digest();\n    U = Buffer.from(digest);\n    U.copy(T, 0, 0, hLen);\n\n    for (var j = 1; j < iterations; j += 1) {\n      var innerDigest = hash.hmac(hash.sha512, key).update(U).digest();\n      U = Buffer.from(innerDigest);\n\n      for (var k = 0; k < hLen; k += 1) {\n        T[k] ^= U[k];\n      }\n    }\n\n    var destPos = (i - 1) * hLen;\n    var len = i === l ? r : hLen;\n    T.copy(DK, destPos, 0, len);\n  }\n\n  return DK;\n}\n\nvar CHINESE = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];\nvar ENGLISH = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];\nvar FRENCH = ['abaisser', 'abandon', 'abdiquer', 'abeille', 'abolir', 'aborder', 'aboutir', 'aboyer', 'abrasif', 'abreuver', 'abriter', 'abroger', 'abrupt', 'absence', 'absolu', 'absurde', 'abusif', 'abyssal', 'academie', 'acajou', 'acarien', 'accabler', 'accepter', 'acclamer', 'accolade', 'accroche', 'accuser', 'acerbe', 'achat', 'acheter', 'aciduler', 'acier', 'acompte', 'acquerir', 'acronyme', 'acteur', 'actif', 'actuel', 'adepte', 'adequat', 'adhesif', 'adjectif', 'adjuger', 'admettre', 'admirer', 'adopter', 'adorer', 'adoucir', 'adresse', 'adroit', 'adulte', 'adverbe', 'aerer', 'aeronef', 'affaire', 'affecter', 'affiche', 'affreux', 'affubler', 'agacer', 'agencer', 'agile', 'agiter', 'agrafer', 'agreable', 'agrume', 'aider', 'aiguille', 'ailier', 'aimable', 'aisance', 'ajouter', 'ajuster', 'alarmer', 'alchimie', 'alerte', 'algebre', 'algue', 'aliener', 'aliment', 'alleger', 'alliage', 'allouer', 'allumer', 'alourdir', 'alpaga', 'altesse', 'alveole', 'amateur', 'ambigu', 'ambre', 'amenager', 'amertume', 'amidon', 'amiral', 'amorcer', 'amour', 'amovible', 'amphibie', 'ampleur', 'amusant', 'analyse', 'anaphore', 'anarchie', 'anatomie', 'ancien', 'aneantir', 'angle', 'angoisse', 'anguleux', 'animal', 'annexer', 'annonce', 'annuel', 'anodin', 'anomalie', 'anonyme', 'anormal', 'antenne', 'antidote', 'anxieux', 'apaiser', 'aperitif', 'aplanir', 'apologie', 'appareil', 'appeler', 'apporter', 'appuyer', 'aquarium', 'aqueduc', 'arbitre', 'arbuste', 'ardeur', 'ardoise', 'argent', 'arlequin', 'armature', 'armement', 'armoire', 'armure', 'arpenter', 'arracher', 'arriver', 'arroser', 'arsenic', 'arteriel', 'article', 'aspect', 'asphalte', 'aspirer', 'assaut', 'asservir', 'assiette', 'associer', 'assurer', 'asticot', 'astre', 'astuce', 'atelier', 'atome', 'atrium', 'atroce', 'attaque', 'attentif', 'attirer', 'attraper', 'aubaine', 'auberge', 'audace', 'audible', 'augurer', 'aurore', 'automne', 'autruche', 'avaler', 'avancer', 'avarice', 'avenir', 'averse', 'aveugle', 'aviateur', 'avide', 'avion', 'aviser', 'avoine', 'avouer', 'avril', 'axial', 'axiome', 'badge', 'bafouer', 'bagage', 'baguette', 'baignade', 'balancer', 'balcon', 'baleine', 'balisage', 'bambin', 'bancaire', 'bandage', 'banlieue', 'banniere', 'banquier', 'barbier', 'baril', 'baron', 'barque', 'barrage', 'bassin', 'bastion', 'bataille', 'bateau', 'batterie', 'baudrier', 'bavarder', 'belette', 'belier', 'belote', 'benefice', 'berceau', 'berger', 'berline', 'bermuda', 'besace', 'besogne', 'betail', 'beurre', 'biberon', 'bicycle', 'bidule', 'bijou', 'bilan', 'bilingue', 'billard', 'binaire', 'biologie', 'biopsie', 'biotype', 'biscuit', 'bison', 'bistouri', 'bitume', 'bizarre', 'blafard', 'blague', 'blanchir', 'blessant', 'blinder', 'blond', 'bloquer', 'blouson', 'bobard', 'bobine', 'boire', 'boiser', 'bolide', 'bonbon', 'bondir', 'bonheur', 'bonifier', 'bonus', 'bordure', 'borne', 'botte', 'boucle', 'boueux', 'bougie', 'boulon', 'bouquin', 'bourse', 'boussole', 'boutique', 'boxeur', 'branche', 'brasier', 'brave', 'brebis', 'breche', 'breuvage', 'bricoler', 'brigade', 'brillant', 'brioche', 'brique', 'brochure', 'broder', 'bronzer', 'brousse', 'broyeur', 'brume', 'brusque', 'brutal', 'bruyant', 'buffle', 'buisson', 'bulletin', 'bureau', 'burin', 'bustier', 'butiner', 'butoir', 'buvable', 'buvette', 'cabanon', 'cabine', 'cachette', 'cadeau', 'cadre', 'cafeine', 'caillou', 'caisson', 'calculer', 'calepin', 'calibre', 'calmer', 'calomnie', 'calvaire', 'camarade', 'camera', 'camion', 'campagne', 'canal', 'caneton', 'canon', 'cantine', 'canular', 'capable', 'caporal', 'caprice', 'capsule', 'capter', 'capuche', 'carabine', 'carbone', 'caresser', 'caribou', 'carnage', 'carotte', 'carreau', 'carton', 'cascade', 'casier', 'casque', 'cassure', 'causer', 'caution', 'cavalier', 'caverne', 'caviar', 'cedille', 'ceinture', 'celeste', 'cellule', 'cendrier', 'censurer', 'central', 'cercle', 'cerebral', 'cerise', 'cerner', 'cerveau', 'cesser', 'chagrin', 'chaise', 'chaleur', 'chambre', 'chance', 'chapitre', 'charbon', 'chasseur', 'chaton', 'chausson', 'chavirer', 'chemise', 'chenille', 'chequier', 'chercher', 'cheval', 'chien', 'chiffre', 'chignon', 'chimere', 'chiot', 'chlorure', 'chocolat', 'choisir', 'chose', 'chouette', 'chrome', 'chute', 'cigare', 'cigogne', 'cimenter', 'cinema', 'cintrer', 'circuler', 'cirer', 'cirque', 'citerne', 'citoyen', 'citron', 'civil', 'clairon', 'clameur', 'claquer', 'classe', 'clavier', 'client', 'cligner', 'climat', 'clivage', 'cloche', 'clonage', 'cloporte', 'cobalt', 'cobra', 'cocasse', 'cocotier', 'coder', 'codifier', 'coffre', 'cogner', 'cohesion', 'coiffer', 'coincer', 'colere', 'colibri', 'colline', 'colmater', 'colonel', 'combat', 'comedie', 'commande', 'compact', 'concert', 'conduire', 'confier', 'congeler', 'connoter', 'consonne', 'contact', 'convexe', 'copain', 'copie', 'corail', 'corbeau', 'cordage', 'corniche', 'corpus', 'correct', 'cortege', 'cosmique', 'costume', 'coton', 'coude', 'coupure', 'courage', 'couteau', 'couvrir', 'coyote', 'crabe', 'crainte', 'cravate', 'crayon', 'creature', 'crediter', 'cremeux', 'creuser', 'crevette', 'cribler', 'crier', 'cristal', 'critere', 'croire', 'croquer', 'crotale', 'crucial', 'cruel', 'crypter', 'cubique', 'cueillir', 'cuillere', 'cuisine', 'cuivre', 'culminer', 'cultiver', 'cumuler', 'cupide', 'curatif', 'curseur', 'cyanure', 'cycle', 'cylindre', 'cynique', 'daigner', 'damier', 'danger', 'danseur', 'dauphin', 'debattre', 'debiter', 'deborder', 'debrider', 'debutant', 'decaler', 'decembre', 'dechirer', 'decider', 'declarer', 'decorer', 'decrire', 'decupler', 'dedale', 'deductif', 'deesse', 'defensif', 'defiler', 'defrayer', 'degager', 'degivrer', 'deglutir', 'degrafer', 'dejeuner', 'delice', 'deloger', 'demander', 'demeurer', 'demolir', 'denicher', 'denouer', 'dentelle', 'denuder', 'depart', 'depenser', 'dephaser', 'deplacer', 'deposer', 'deranger', 'derober', 'desastre', 'descente', 'desert', 'designer', 'desobeir', 'dessiner', 'destrier', 'detacher', 'detester', 'detourer', 'detresse', 'devancer', 'devenir', 'deviner', 'devoir', 'diable', 'dialogue', 'diamant', 'dicter', 'differer', 'digerer', 'digital', 'digne', 'diluer', 'dimanche', 'diminuer', 'dioxyde', 'directif', 'diriger', 'discuter', 'disposer', 'dissiper', 'distance', 'divertir', 'diviser', 'docile', 'docteur', 'dogme', 'doigt', 'domaine', 'domicile', 'dompter', 'donateur', 'donjon', 'donner', 'dopamine', 'dortoir', 'dorure', 'dosage', 'doseur', 'dossier', 'dotation', 'douanier', 'double', 'douceur', 'douter', 'doyen', 'dragon', 'draper', 'dresser', 'dribbler', 'droiture', 'duperie', 'duplexe', 'durable', 'durcir', 'dynastie', 'eblouir', 'ecarter', 'echarpe', 'echelle', 'eclairer', 'eclipse', 'eclore', 'ecluse', 'ecole', 'economie', 'ecorce', 'ecouter', 'ecraser', 'ecremer', 'ecrivain', 'ecrou', 'ecume', 'ecureuil', 'edifier', 'eduquer', 'effacer', 'effectif', 'effigie', 'effort', 'effrayer', 'effusion', 'egaliser', 'egarer', 'ejecter', 'elaborer', 'elargir', 'electron', 'elegant', 'elephant', 'eleve', 'eligible', 'elitisme', 'eloge', 'elucider', 'eluder', 'emballer', 'embellir', 'embryon', 'emeraude', 'emission', 'emmener', 'emotion', 'emouvoir', 'empereur', 'employer', 'emporter', 'emprise', 'emulsion', 'encadrer', 'enchere', 'enclave', 'encoche', 'endiguer', 'endosser', 'endroit', 'enduire', 'energie', 'enfance', 'enfermer', 'enfouir', 'engager', 'engin', 'englober', 'enigme', 'enjamber', 'enjeu', 'enlever', 'ennemi', 'ennuyeux', 'enrichir', 'enrobage', 'enseigne', 'entasser', 'entendre', 'entier', 'entourer', 'entraver', 'enumerer', 'envahir', 'enviable', 'envoyer', 'enzyme', 'eolien', 'epaissir', 'epargne', 'epatant', 'epaule', 'epicerie', 'epidemie', 'epier', 'epilogue', 'epine', 'episode', 'epitaphe', 'epoque', 'epreuve', 'eprouver', 'epuisant', 'equerre', 'equipe', 'eriger', 'erosion', 'erreur', 'eruption', 'escalier', 'espadon', 'espece', 'espiegle', 'espoir', 'esprit', 'esquiver', 'essayer', 'essence', 'essieu', 'essorer', 'estime', 'estomac', 'estrade', 'etagere', 'etaler', 'etanche', 'etatique', 'eteindre', 'etendoir', 'eternel', 'ethanol', 'ethique', 'ethnie', 'etirer', 'etoffer', 'etoile', 'etonnant', 'etourdir', 'etrange', 'etroit', 'etude', 'euphorie', 'evaluer', 'evasion', 'eventail', 'evidence', 'eviter', 'evolutif', 'evoquer', 'exact', 'exagerer', 'exaucer', 'exceller', 'excitant', 'exclusif', 'excuse', 'executer', 'exemple', 'exercer', 'exhaler', 'exhorter', 'exigence', 'exiler', 'exister', 'exotique', 'expedier', 'explorer', 'exposer', 'exprimer', 'exquis', 'extensif', 'extraire', 'exulter', 'fable', 'fabuleux', 'facette', 'facile', 'facture', 'faiblir', 'falaise', 'fameux', 'famille', 'farceur', 'farfelu', 'farine', 'farouche', 'fasciner', 'fatal', 'fatigue', 'faucon', 'fautif', 'faveur', 'favori', 'febrile', 'feconder', 'federer', 'felin', 'femme', 'femur', 'fendoir', 'feodal', 'fermer', 'feroce', 'ferveur', 'festival', 'feuille', 'feutre', 'fevrier', 'fiasco', 'ficeler', 'fictif', 'fidele', 'figure', 'filature', 'filetage', 'filiere', 'filleul', 'filmer', 'filou', 'filtrer', 'financer', 'finir', 'fiole', 'firme', 'fissure', 'fixer', 'flairer', 'flamme', 'flasque', 'flatteur', 'fleau', 'fleche', 'fleur', 'flexion', 'flocon', 'flore', 'fluctuer', 'fluide', 'fluvial', 'folie', 'fonderie', 'fongible', 'fontaine', 'forcer', 'forgeron', 'formuler', 'fortune', 'fossile', 'foudre', 'fougere', 'fouiller', 'foulure', 'fourmi', 'fragile', 'fraise', 'franchir', 'frapper', 'frayeur', 'fregate', 'freiner', 'frelon', 'fremir', 'frenesie', 'frere', 'friable', 'friction', 'frisson', 'frivole', 'froid', 'fromage', 'frontal', 'frotter', 'fruit', 'fugitif', 'fuite', 'fureur', 'furieux', 'furtif', 'fusion', 'futur', 'gagner', 'galaxie', 'galerie', 'gambader', 'garantir', 'gardien', 'garnir', 'garrigue', 'gazelle', 'gazon', 'geant', 'gelatine', 'gelule', 'gendarme', 'general', 'genie', 'genou', 'gentil', 'geologie', 'geometre', 'geranium', 'germe', 'gestuel', 'geyser', 'gibier', 'gicler', 'girafe', 'givre', 'glace', 'glaive', 'glisser', 'globe', 'gloire', 'glorieux', 'golfeur', 'gomme', 'gonfler', 'gorge', 'gorille', 'goudron', 'gouffre', 'goulot', 'goupille', 'gourmand', 'goutte', 'graduel', 'graffiti', 'graine', 'grand', 'grappin', 'gratuit', 'gravir', 'grenat', 'griffure', 'griller', 'grimper', 'grogner', 'gronder', 'grotte', 'groupe', 'gruger', 'grutier', 'gruyere', 'guepard', 'guerrier', 'guide', 'guimauve', 'guitare', 'gustatif', 'gymnaste', 'gyrostat', 'habitude', 'hachoir', 'halte', 'hameau', 'hangar', 'hanneton', 'haricot', 'harmonie', 'harpon', 'hasard', 'helium', 'hematome', 'herbe', 'herisson', 'hermine', 'heron', 'hesiter', 'heureux', 'hiberner', 'hibou', 'hilarant', 'histoire', 'hiver', 'homard', 'hommage', 'homogene', 'honneur', 'honorer', 'honteux', 'horde', 'horizon', 'horloge', 'hormone', 'horrible', 'houleux', 'housse', 'hublot', 'huileux', 'humain', 'humble', 'humide', 'humour', 'hurler', 'hydromel', 'hygiene', 'hymne', 'hypnose', 'idylle', 'ignorer', 'iguane', 'illicite', 'illusion', 'image', 'imbiber', 'imiter', 'immense', 'immobile', 'immuable', 'impact', 'imperial', 'implorer', 'imposer', 'imprimer', 'imputer', 'incarner', 'incendie', 'incident', 'incliner', 'incolore', 'indexer', 'indice', 'inductif', 'inedit', 'ineptie', 'inexact', 'infini', 'infliger', 'informer', 'infusion', 'ingerer', 'inhaler', 'inhiber', 'injecter', 'injure', 'innocent', 'inoculer', 'inonder', 'inscrire', 'insecte', 'insigne', 'insolite', 'inspirer', 'instinct', 'insulter', 'intact', 'intense', 'intime', 'intrigue', 'intuitif', 'inutile', 'invasion', 'inventer', 'inviter', 'invoquer', 'ironique', 'irradier', 'irreel', 'irriter', 'isoler', 'ivoire', 'ivresse', 'jaguar', 'jaillir', 'jambe', 'janvier', 'jardin', 'jauger', 'jaune', 'javelot', 'jetable', 'jeton', 'jeudi', 'jeunesse', 'joindre', 'joncher', 'jongler', 'joueur', 'jouissif', 'journal', 'jovial', 'joyau', 'joyeux', 'jubiler', 'jugement', 'junior', 'jupon', 'juriste', 'justice', 'juteux', 'juvenile', 'kayak', 'kimono', 'kiosque', 'label', 'labial', 'labourer', 'lacerer', 'lactose', 'lagune', 'laine', 'laisser', 'laitier', 'lambeau', 'lamelle', 'lampe', 'lanceur', 'langage', 'lanterne', 'lapin', 'largeur', 'larme', 'laurier', 'lavabo', 'lavoir', 'lecture', 'legal', 'leger', 'legume', 'lessive', 'lettre', 'levier', 'lexique', 'lezard', 'liasse', 'liberer', 'libre', 'licence', 'licorne', 'liege', 'lievre', 'ligature', 'ligoter', 'ligue', 'limer', 'limite', 'limonade', 'limpide', 'lineaire', 'lingot', 'lionceau', 'liquide', 'lisiere', 'lister', 'lithium', 'litige', 'littoral', 'livreur', 'logique', 'lointain', 'loisir', 'lombric', 'loterie', 'louer', 'lourd', 'loutre', 'louve', 'loyal', 'lubie', 'lucide', 'lucratif', 'lueur', 'lugubre', 'luisant', 'lumiere', 'lunaire', 'lundi', 'luron', 'lutter', 'luxueux', 'machine', 'magasin', 'magenta', 'magique', 'maigre', 'maillon', 'maintien', 'mairie', 'maison', 'majorer', 'malaxer', 'malefice', 'malheur', 'malice', 'mallette', 'mammouth', 'mandater', 'maniable', 'manquant', 'manteau', 'manuel', 'marathon', 'marbre', 'marchand', 'mardi', 'maritime', 'marqueur', 'marron', 'marteler', 'mascotte', 'massif', 'materiel', 'matiere', 'matraque', 'maudire', 'maussade', 'mauve', 'maximal', 'mechant', 'meconnu', 'medaille', 'medecin', 'mediter', 'meduse', 'meilleur', 'melange', 'melodie', 'membre', 'memoire', 'menacer', 'mener', 'menhir', 'mensonge', 'mentor', 'mercredi', 'merite', 'merle', 'messager', 'mesure', 'metal', 'meteore', 'methode', 'metier', 'meuble', 'miauler', 'microbe', 'miette', 'mignon', 'migrer', 'milieu', 'million', 'mimique', 'mince', 'mineral', 'minimal', 'minorer', 'minute', 'miracle', 'miroiter', 'missile', 'mixte', 'mobile', 'moderne', 'moelleux', 'mondial', 'moniteur', 'monnaie', 'monotone', 'monstre', 'montagne', 'monument', 'moqueur', 'morceau', 'morsure', 'mortier', 'moteur', 'motif', 'mouche', 'moufle', 'moulin', 'mousson', 'mouton', 'mouvant', 'multiple', 'munition', 'muraille', 'murene', 'murmure', 'muscle', 'museum', 'musicien', 'mutation', 'muter', 'mutuel', 'myriade', 'myrtille', 'mystere', 'mythique', 'nageur', 'nappe', 'narquois', 'narrer', 'natation', 'nation', 'nature', 'naufrage', 'nautique', 'navire', 'nebuleux', 'nectar', 'nefaste', 'negation', 'negliger', 'negocier', 'neige', 'nerveux', 'nettoyer', 'neurone', 'neutron', 'neveu', 'niche', 'nickel', 'nitrate', 'niveau', 'noble', 'nocif', 'nocturne', 'noirceur', 'noisette', 'nomade', 'nombreux', 'nommer', 'normatif', 'notable', 'notifier', 'notoire', 'nourrir', 'nouveau', 'novateur', 'novembre', 'novice', 'nuage', 'nuancer', 'nuire', 'nuisible', 'numero', 'nuptial', 'nuque', 'nutritif', 'obeir', 'objectif', 'obliger', 'obscur', 'observer', 'obstacle', 'obtenir', 'obturer', 'occasion', 'occuper', 'ocean', 'octobre', 'octroyer', 'octupler', 'oculaire', 'odeur', 'odorant', 'offenser', 'officier', 'offrir', 'ogive', 'oiseau', 'oisillon', 'olfactif', 'olivier', 'ombrage', 'omettre', 'onctueux', 'onduler', 'onereux', 'onirique', 'opale', 'opaque', 'operer', 'opinion', 'opportun', 'opprimer', 'opter', 'optique', 'orageux', 'orange', 'orbite', 'ordonner', 'oreille', 'organe', 'orgueil', 'orifice', 'ornement', 'orque', 'ortie', 'osciller', 'osmose', 'ossature', 'otarie', 'ouragan', 'ourson', 'outil', 'outrager', 'ouvrage', 'ovation', 'oxyde', 'oxygene', 'ozone', 'paisible', 'palace', 'palmares', 'palourde', 'palper', 'panache', 'panda', 'pangolin', 'paniquer', 'panneau', 'panorama', 'pantalon', 'papaye', 'papier', 'papoter', 'papyrus', 'paradoxe', 'parcelle', 'paresse', 'parfumer', 'parler', 'parole', 'parrain', 'parsemer', 'partager', 'parure', 'parvenir', 'passion', 'pasteque', 'paternel', 'patience', 'patron', 'pavillon', 'pavoiser', 'payer', 'paysage', 'peigne', 'peintre', 'pelage', 'pelican', 'pelle', 'pelouse', 'peluche', 'pendule', 'penetrer', 'penible', 'pensif', 'penurie', 'pepite', 'peplum', 'perdrix', 'perforer', 'periode', 'permuter', 'perplexe', 'persil', 'perte', 'peser', 'petale', 'petit', 'petrir', 'peuple', 'pharaon', 'phobie', 'phoque', 'photon', 'phrase', 'physique', 'piano', 'pictural', 'piece', 'pierre', 'pieuvre', 'pilote', 'pinceau', 'pipette', 'piquer', 'pirogue', 'piscine', 'piston', 'pivoter', 'pixel', 'pizza', 'placard', 'plafond', 'plaisir', 'planer', 'plaque', 'plastron', 'plateau', 'pleurer', 'plexus', 'pliage', 'plomb', 'plonger', 'pluie', 'plumage', 'pochette', 'poesie', 'poete', 'pointe', 'poirier', 'poisson', 'poivre', 'polaire', 'policier', 'pollen', 'polygone', 'pommade', 'pompier', 'ponctuel', 'ponderer', 'poney', 'portique', 'position', 'posseder', 'posture', 'potager', 'poteau', 'potion', 'pouce', 'poulain', 'poumon', 'pourpre', 'poussin', 'pouvoir', 'prairie', 'pratique', 'precieux', 'predire', 'prefixe', 'prelude', 'prenom', 'presence', 'pretexte', 'prevoir', 'primitif', 'prince', 'prison', 'priver', 'probleme', 'proceder', 'prodige', 'profond', 'progres', 'proie', 'projeter', 'prologue', 'promener', 'propre', 'prospere', 'proteger', 'prouesse', 'proverbe', 'prudence', 'pruneau', 'psychose', 'public', 'puceron', 'puiser', 'pulpe', 'pulsar', 'punaise', 'punitif', 'pupitre', 'purifier', 'puzzle', 'pyramide', 'quasar', 'querelle', 'question', 'quietude', 'quitter', 'quotient', 'racine', 'raconter', 'radieux', 'ragondin', 'raideur', 'raisin', 'ralentir', 'rallonge', 'ramasser', 'rapide', 'rasage', 'ratisser', 'ravager', 'ravin', 'rayonner', 'reactif', 'reagir', 'realiser', 'reanimer', 'recevoir', 'reciter', 'reclamer', 'recolter', 'recruter', 'reculer', 'recycler', 'rediger', 'redouter', 'refaire', 'reflexe', 'reformer', 'refrain', 'refuge', 'regalien', 'region', 'reglage', 'regulier', 'reiterer', 'rejeter', 'rejouer', 'relatif', 'relever', 'relief', 'remarque', 'remede', 'remise', 'remonter', 'remplir', 'remuer', 'renard', 'renfort', 'renifler', 'renoncer', 'rentrer', 'renvoi', 'replier', 'reporter', 'reprise', 'reptile', 'requin', 'reserve', 'resineux', 'resoudre', 'respect', 'rester', 'resultat', 'retablir', 'retenir', 'reticule', 'retomber', 'retracer', 'reunion', 'reussir', 'revanche', 'revivre', 'revolte', 'revulsif', 'richesse', 'rideau', 'rieur', 'rigide', 'rigoler', 'rincer', 'riposter', 'risible', 'risque', 'rituel', 'rival', 'riviere', 'rocheux', 'romance', 'rompre', 'ronce', 'rondin', 'roseau', 'rosier', 'rotatif', 'rotor', 'rotule', 'rouge', 'rouille', 'rouleau', 'routine', 'royaume', 'ruban', 'rubis', 'ruche', 'ruelle', 'rugueux', 'ruiner', 'ruisseau', 'ruser', 'rustique', 'rythme', 'sabler', 'saboter', 'sabre', 'sacoche', 'safari', 'sagesse', 'saisir', 'salade', 'salive', 'salon', 'saluer', 'samedi', 'sanction', 'sanglier', 'sarcasme', 'sardine', 'saturer', 'saugrenu', 'saumon', 'sauter', 'sauvage', 'savant', 'savonner', 'scalpel', 'scandale', 'scelerat', 'scenario', 'sceptre', 'schema', 'science', 'scinder', 'score', 'scrutin', 'sculpter', 'seance', 'secable', 'secher', 'secouer', 'secreter', 'sedatif', 'seduire', 'seigneur', 'sejour', 'selectif', 'semaine', 'sembler', 'semence', 'seminal', 'senateur', 'sensible', 'sentence', 'separer', 'sequence', 'serein', 'sergent', 'serieux', 'serrure', 'serum', 'service', 'sesame', 'sevir', 'sevrage', 'sextuple', 'sideral', 'siecle', 'sieger', 'siffler', 'sigle', 'signal', 'silence', 'silicium', 'simple', 'sincere', 'sinistre', 'siphon', 'sirop', 'sismique', 'situer', 'skier', 'social', 'socle', 'sodium', 'soigneux', 'soldat', 'soleil', 'solitude', 'soluble', 'sombre', 'sommeil', 'somnoler', 'sonde', 'songeur', 'sonnette', 'sonore', 'sorcier', 'sortir', 'sosie', 'sottise', 'soucieux', 'soudure', 'souffle', 'soulever', 'soupape', 'source', 'soutirer', 'souvenir', 'spacieux', 'spatial', 'special', 'sphere', 'spiral', 'stable', 'station', 'sternum', 'stimulus', 'stipuler', 'strict', 'studieux', 'stupeur', 'styliste', 'sublime', 'substrat', 'subtil', 'subvenir', 'succes', 'sucre', 'suffixe', 'suggerer', 'suiveur', 'sulfate', 'superbe', 'supplier', 'surface', 'suricate', 'surmener', 'surprise', 'sursaut', 'survie', 'suspect', 'syllabe', 'symbole', 'symetrie', 'synapse', 'syntaxe', 'systeme', 'tabac', 'tablier', 'tactile', 'tailler', 'talent', 'talisman', 'talonner', 'tambour', 'tamiser', 'tangible', 'tapis', 'taquiner', 'tarder', 'tarif', 'tartine', 'tasse', 'tatami', 'tatouage', 'taupe', 'taureau', 'taxer', 'temoin', 'temporel', 'tenaille', 'tendre', 'teneur', 'tenir', 'tension', 'terminer', 'terne', 'terrible', 'tetine', 'texte', 'theme', 'theorie', 'therapie', 'thorax', 'tibia', 'tiede', 'timide', 'tirelire', 'tiroir', 'tissu', 'titane', 'titre', 'tituber', 'toboggan', 'tolerant', 'tomate', 'tonique', 'tonneau', 'toponyme', 'torche', 'tordre', 'tornade', 'torpille', 'torrent', 'torse', 'tortue', 'totem', 'toucher', 'tournage', 'tousser', 'toxine', 'traction', 'trafic', 'tragique', 'trahir', 'train', 'trancher', 'travail', 'trefle', 'tremper', 'tresor', 'treuil', 'triage', 'tribunal', 'tricoter', 'trilogie', 'triomphe', 'tripler', 'triturer', 'trivial', 'trombone', 'tronc', 'tropical', 'troupeau', 'tuile', 'tulipe', 'tumulte', 'tunnel', 'turbine', 'tuteur', 'tutoyer', 'tuyau', 'tympan', 'typhon', 'typique', 'tyran', 'ubuesque', 'ultime', 'ultrason', 'unanime', 'unifier', 'union', 'unique', 'unitaire', 'univers', 'uranium', 'urbain', 'urticant', 'usage', 'usine', 'usuel', 'usure', 'utile', 'utopie', 'vacarme', 'vaccin', 'vagabond', 'vague', 'vaillant', 'vaincre', 'vaisseau', 'valable', 'valise', 'vallon', 'valve', 'vampire', 'vanille', 'vapeur', 'varier', 'vaseux', 'vassal', 'vaste', 'vecteur', 'vedette', 'vegetal', 'vehicule', 'veinard', 'veloce', 'vendredi', 'venerer', 'venger', 'venimeux', 'ventouse', 'verdure', 'verin', 'vernir', 'verrou', 'verser', 'vertu', 'veston', 'veteran', 'vetuste', 'vexant', 'vexer', 'viaduc', 'viande', 'victoire', 'vidange', 'video', 'vignette', 'vigueur', 'vilain', 'village', 'vinaigre', 'violon', 'vipere', 'virement', 'virtuose', 'virus', 'visage', 'viseur', 'vision', 'visqueux', 'visuel', 'vital', 'vitesse', 'viticole', 'vitrine', 'vivace', 'vivipare', 'vocation', 'voguer', 'voile', 'voisin', 'voiture', 'volaille', 'volcan', 'voltiger', 'volume', 'vorace', 'vortex', 'voter', 'vouloir', 'voyage', 'voyelle', 'wagon', 'xenon', 'yacht', 'zebre', 'zenith', 'zeste', 'zoologie'];\nvar ITALIAN = ['abaco', 'abbaglio', 'abbinato', 'abete', 'abisso', 'abolire', 'abrasivo', 'abrogato', 'accadere', 'accenno', 'accusato', 'acetone', 'achille', 'acido', 'acqua', 'acre', 'acrilico', 'acrobata', 'acuto', 'adagio', 'addebito', 'addome', 'adeguato', 'aderire', 'adipe', 'adottare', 'adulare', 'affabile', 'affetto', 'affisso', 'affranto', 'aforisma', 'afoso', 'africano', 'agave', 'agente', 'agevole', 'aggancio', 'agire', 'agitare', 'agonismo', 'agricolo', 'agrumeto', 'aguzzo', 'alabarda', 'alato', 'albatro', 'alberato', 'albo', 'albume', 'alce', 'alcolico', 'alettone', 'alfa', 'algebra', 'aliante', 'alibi', 'alimento', 'allagato', 'allegro', 'allievo', 'allodola', 'allusivo', 'almeno', 'alogeno', 'alpaca', 'alpestre', 'altalena', 'alterno', 'alticcio', 'altrove', 'alunno', 'alveolo', 'alzare', 'amalgama', 'amanita', 'amarena', 'ambito', 'ambrato', 'ameba', 'america', 'ametista', 'amico', 'ammasso', 'ammenda', 'ammirare', 'ammonito', 'amore', 'ampio', 'ampliare', 'amuleto', 'anacardo', 'anagrafe', 'analista', 'anarchia', 'anatra', 'anca', 'ancella', 'ancora', 'andare', 'andrea', 'anello', 'angelo', 'angolare', 'angusto', 'anima', 'annegare', 'annidato', 'anno', 'annuncio', 'anonimo', 'anticipo', 'anzi', 'apatico', 'apertura', 'apode', 'apparire', 'appetito', 'appoggio', 'approdo', 'appunto', 'aprile', 'arabica', 'arachide', 'aragosta', 'araldica', 'arancio', 'aratura', 'arazzo', 'arbitro', 'archivio', 'ardito', 'arenile', 'argento', 'argine', 'arguto', 'aria', 'armonia', 'arnese', 'arredato', 'arringa', 'arrosto', 'arsenico', 'arso', 'artefice', 'arzillo', 'asciutto', 'ascolto', 'asepsi', 'asettico', 'asfalto', 'asino', 'asola', 'aspirato', 'aspro', 'assaggio', 'asse', 'assoluto', 'assurdo', 'asta', 'astenuto', 'astice', 'astratto', 'atavico', 'ateismo', 'atomico', 'atono', 'attesa', 'attivare', 'attorno', 'attrito', 'attuale', 'ausilio', 'austria', 'autista', 'autonomo', 'autunno', 'avanzato', 'avere', 'avvenire', 'avviso', 'avvolgere', 'azione', 'azoto', 'azzimo', 'azzurro', 'babele', 'baccano', 'bacino', 'baco', 'badessa', 'badilata', 'bagnato', 'baita', 'balcone', 'baldo', 'balena', 'ballata', 'balzano', 'bambino', 'bandire', 'baraonda', 'barbaro', 'barca', 'baritono', 'barlume', 'barocco', 'basilico', 'basso', 'batosta', 'battuto', 'baule', 'bava', 'bavosa', 'becco', 'beffa', 'belgio', 'belva', 'benda', 'benevole', 'benigno', 'benzina', 'bere', 'berlina', 'beta', 'bibita', 'bici', 'bidone', 'bifido', 'biga', 'bilancia', 'bimbo', 'binocolo', 'biologo', 'bipede', 'bipolare', 'birbante', 'birra', 'biscotto', 'bisesto', 'bisnonno', 'bisonte', 'bisturi', 'bizzarro', 'blando', 'blatta', 'bollito', 'bonifico', 'bordo', 'bosco', 'botanico', 'bottino', 'bozzolo', 'braccio', 'bradipo', 'brama', 'branca', 'bravura', 'bretella', 'brevetto', 'brezza', 'briglia', 'brillante', 'brindare', 'broccolo', 'brodo', 'bronzina', 'brullo', 'bruno', 'bubbone', 'buca', 'budino', 'buffone', 'buio', 'bulbo', 'buono', 'burlone', 'burrasca', 'bussola', 'busta', 'cadetto', 'caduco', 'calamaro', 'calcolo', 'calesse', 'calibro', 'calmo', 'caloria', 'cambusa', 'camerata', 'camicia', 'cammino', 'camola', 'campale', 'canapa', 'candela', 'cane', 'canino', 'canotto', 'cantina', 'capace', 'capello', 'capitolo', 'capogiro', 'cappero', 'capra', 'capsula', 'carapace', 'carcassa', 'cardo', 'carisma', 'carovana', 'carretto', 'cartolina', 'casaccio', 'cascata', 'caserma', 'caso', 'cassone', 'castello', 'casuale', 'catasta', 'catena', 'catrame', 'cauto', 'cavillo', 'cedibile', 'cedrata', 'cefalo', 'celebre', 'cellulare', 'cena', 'cenone', 'centesimo', 'ceramica', 'cercare', 'certo', 'cerume', 'cervello', 'cesoia', 'cespo', 'ceto', 'chela', 'chiaro', 'chicca', 'chiedere', 'chimera', 'china', 'chirurgo', 'chitarra', 'ciao', 'ciclismo', 'cifrare', 'cigno', 'cilindro', 'ciottolo', 'circa', 'cirrosi', 'citrico', 'cittadino', 'ciuffo', 'civetta', 'civile', 'classico', 'clinica', 'cloro', 'cocco', 'codardo', 'codice', 'coerente', 'cognome', 'collare', 'colmato', 'colore', 'colposo', 'coltivato', 'colza', 'coma', 'cometa', 'commando', 'comodo', 'computer', 'comune', 'conciso', 'condurre', 'conferma', 'congelare', 'coniuge', 'connesso', 'conoscere', 'consumo', 'continuo', 'convegno', 'coperto', 'copione', 'coppia', 'copricapo', 'corazza', 'cordata', 'coricato', 'cornice', 'corolla', 'corpo', 'corredo', 'corsia', 'cortese', 'cosmico', 'costante', 'cottura', 'covato', 'cratere', 'cravatta', 'creato', 'credere', 'cremoso', 'crescita', 'creta', 'criceto', 'crinale', 'crisi', 'critico', 'croce', 'cronaca', 'crostata', 'cruciale', 'crusca', 'cucire', 'cuculo', 'cugino', 'cullato', 'cupola', 'curatore', 'cursore', 'curvo', 'cuscino', 'custode', 'dado', 'daino', 'dalmata', 'damerino', 'daniela', 'dannoso', 'danzare', 'datato', 'davanti', 'davvero', 'debutto', 'decennio', 'deciso', 'declino', 'decollo', 'decreto', 'dedicato', 'definito', 'deforme', 'degno', 'delegare', 'delfino', 'delirio', 'delta', 'demenza', 'denotato', 'dentro', 'deposito', 'derapata', 'derivare', 'deroga', 'descritto', 'deserto', 'desiderio', 'desumere', 'detersivo', 'devoto', 'diametro', 'dicembre', 'diedro', 'difeso', 'diffuso', 'digerire', 'digitale', 'diluvio', 'dinamico', 'dinnanzi', 'dipinto', 'diploma', 'dipolo', 'diradare', 'dire', 'dirotto', 'dirupo', 'disagio', 'discreto', 'disfare', 'disgelo', 'disposto', 'distanza', 'disumano', 'dito', 'divano', 'divelto', 'dividere', 'divorato', 'doblone', 'docente', 'doganale', 'dogma', 'dolce', 'domato', 'domenica', 'dominare', 'dondolo', 'dono', 'dormire', 'dote', 'dottore', 'dovuto', 'dozzina', 'drago', 'druido', 'dubbio', 'dubitare', 'ducale', 'duna', 'duomo', 'duplice', 'duraturo', 'ebano', 'eccesso', 'ecco', 'eclissi', 'economia', 'edera', 'edicola', 'edile', 'editoria', 'educare', 'egemonia', 'egli', 'egoismo', 'egregio', 'elaborato', 'elargire', 'elegante', 'elencato', 'eletto', 'elevare', 'elfico', 'elica', 'elmo', 'elsa', 'eluso', 'emanato', 'emblema', 'emesso', 'emiro', 'emotivo', 'emozione', 'empirico', 'emulo', 'endemico', 'enduro', 'energia', 'enfasi', 'enoteca', 'entrare', 'enzima', 'epatite', 'epilogo', 'episodio', 'epocale', 'eppure', 'equatore', 'erario', 'erba', 'erboso', 'erede', 'eremita', 'erigere', 'ermetico', 'eroe', 'erosivo', 'errante', 'esagono', 'esame', 'esanime', 'esaudire', 'esca', 'esempio', 'esercito', 'esibito', 'esigente', 'esistere', 'esito', 'esofago', 'esortato', 'esoso', 'espanso', 'espresso', 'essenza', 'esso', 'esteso', 'estimare', 'estonia', 'estroso', 'esultare', 'etilico', 'etnico', 'etrusco', 'etto', 'euclideo', 'europa', 'evaso', 'evidenza', 'evitato', 'evoluto', 'evviva', 'fabbrica', 'faccenda', 'fachiro', 'falco', 'famiglia', 'fanale', 'fanfara', 'fango', 'fantasma', 'fare', 'farfalla', 'farinoso', 'farmaco', 'fascia', 'fastoso', 'fasullo', 'faticare', 'fato', 'favoloso', 'febbre', 'fecola', 'fede', 'fegato', 'felpa', 'feltro', 'femmina', 'fendere', 'fenomeno', 'fermento', 'ferro', 'fertile', 'fessura', 'festivo', 'fetta', 'feudo', 'fiaba', 'fiducia', 'fifa', 'figurato', 'filo', 'finanza', 'finestra', 'finire', 'fiore', 'fiscale', 'fisico', 'fiume', 'flacone', 'flamenco', 'flebo', 'flemma', 'florido', 'fluente', 'fluoro', 'fobico', 'focaccia', 'focoso', 'foderato', 'foglio', 'folata', 'folclore', 'folgore', 'fondente', 'fonetico', 'fonia', 'fontana', 'forbito', 'forchetta', 'foresta', 'formica', 'fornaio', 'foro', 'fortezza', 'forzare', 'fosfato', 'fosso', 'fracasso', 'frana', 'frassino', 'fratello', 'freccetta', 'frenata', 'fresco', 'frigo', 'frollino', 'fronde', 'frugale', 'frutta', 'fucilata', 'fucsia', 'fuggente', 'fulmine', 'fulvo', 'fumante', 'fumetto', 'fumoso', 'fune', 'funzione', 'fuoco', 'furbo', 'furgone', 'furore', 'fuso', 'futile', 'gabbiano', 'gaffe', 'galateo', 'gallina', 'galoppo', 'gambero', 'gamma', 'garanzia', 'garbo', 'garofano', 'garzone', 'gasdotto', 'gasolio', 'gastrico', 'gatto', 'gaudio', 'gazebo', 'gazzella', 'geco', 'gelatina', 'gelso', 'gemello', 'gemmato', 'gene', 'genitore', 'gennaio', 'genotipo', 'gergo', 'ghepardo', 'ghiaccio', 'ghisa', 'giallo', 'gilda', 'ginepro', 'giocare', 'gioiello', 'giorno', 'giove', 'girato', 'girone', 'gittata', 'giudizio', 'giurato', 'giusto', 'globulo', 'glutine', 'gnomo', 'gobba', 'golf', 'gomito', 'gommone', 'gonfio', 'gonna', 'governo', 'gracile', 'grado', 'grafico', 'grammo', 'grande', 'grattare', 'gravoso', 'grazia', 'greca', 'gregge', 'grifone', 'grigio', 'grinza', 'grotta', 'gruppo', 'guadagno', 'guaio', 'guanto', 'guardare', 'gufo', 'guidare', 'ibernato', 'icona', 'identico', 'idillio', 'idolo', 'idra', 'idrico', 'idrogeno', 'igiene', 'ignaro', 'ignorato', 'ilare', 'illeso', 'illogico', 'illudere', 'imballo', 'imbevuto', 'imbocco', 'imbuto', 'immane', 'immerso', 'immolato', 'impacco', 'impeto', 'impiego', 'importo', 'impronta', 'inalare', 'inarcare', 'inattivo', 'incanto', 'incendio', 'inchino', 'incisivo', 'incluso', 'incontro', 'incrocio', 'incubo', 'indagine', 'india', 'indole', 'inedito', 'infatti', 'infilare', 'inflitto', 'ingaggio', 'ingegno', 'inglese', 'ingordo', 'ingrosso', 'innesco', 'inodore', 'inoltrare', 'inondato', 'insano', 'insetto', 'insieme', 'insonnia', 'insulina', 'intasato', 'intero', 'intonaco', 'intuito', 'inumidire', 'invalido', 'invece', 'invito', 'iperbole', 'ipnotico', 'ipotesi', 'ippica', 'iride', 'irlanda', 'ironico', 'irrigato', 'irrorare', 'isolato', 'isotopo', 'isterico', 'istituto', 'istrice', 'italia', 'iterare', 'labbro', 'labirinto', 'lacca', 'lacerato', 'lacrima', 'lacuna', 'laddove', 'lago', 'lampo', 'lancetta', 'lanterna', 'lardoso', 'larga', 'laringe', 'lastra', 'latenza', 'latino', 'lattuga', 'lavagna', 'lavoro', 'legale', 'leggero', 'lembo', 'lentezza', 'lenza', 'leone', 'lepre', 'lesivo', 'lessato', 'lesto', 'letterale', 'leva', 'levigato', 'libero', 'lido', 'lievito', 'lilla', 'limatura', 'limitare', 'limpido', 'lineare', 'lingua', 'liquido', 'lira', 'lirica', 'lisca', 'lite', 'litigio', 'livrea', 'locanda', 'lode', 'logica', 'lombare', 'londra', 'longevo', 'loquace', 'lorenzo', 'loto', 'lotteria', 'luce', 'lucidato', 'lumaca', 'luminoso', 'lungo', 'lupo', 'luppolo', 'lusinga', 'lusso', 'lutto', 'macabro', 'macchina', 'macero', 'macinato', 'madama', 'magico', 'maglia', 'magnete', 'magro', 'maiolica', 'malafede', 'malgrado', 'malinteso', 'malsano', 'malto', 'malumore', 'mana', 'mancia', 'mandorla', 'mangiare', 'manifesto', 'mannaro', 'manovra', 'mansarda', 'mantide', 'manubrio', 'mappa', 'maratona', 'marcire', 'maretta', 'marmo', 'marsupio', 'maschera', 'massaia', 'mastino', 'materasso', 'matricola', 'mattone', 'maturo', 'mazurca', 'meandro', 'meccanico', 'mecenate', 'medesimo', 'meditare', 'mega', 'melassa', 'melis', 'melodia', 'meninge', 'meno', 'mensola', 'mercurio', 'merenda', 'merlo', 'meschino', 'mese', 'messere', 'mestolo', 'metallo', 'metodo', 'mettere', 'miagolare', 'mica', 'micelio', 'michele', 'microbo', 'midollo', 'miele', 'migliore', 'milano', 'milite', 'mimosa', 'minerale', 'mini', 'minore', 'mirino', 'mirtillo', 'miscela', 'missiva', 'misto', 'misurare', 'mitezza', 'mitigare', 'mitra', 'mittente', 'mnemonico', 'modello', 'modifica', 'modulo', 'mogano', 'mogio', 'mole', 'molosso', 'monastero', 'monco', 'mondina', 'monetario', 'monile', 'monotono', 'monsone', 'montato', 'monviso', 'mora', 'mordere', 'morsicato', 'mostro', 'motivato', 'motosega', 'motto', 'movenza', 'movimento', 'mozzo', 'mucca', 'mucosa', 'muffa', 'mughetto', 'mugnaio', 'mulatto', 'mulinello', 'multiplo', 'mummia', 'munto', 'muovere', 'murale', 'musa', 'muscolo', 'musica', 'mutevole', 'muto', 'nababbo', 'nafta', 'nanometro', 'narciso', 'narice', 'narrato', 'nascere', 'nastrare', 'naturale', 'nautica', 'naviglio', 'nebulosa', 'necrosi', 'negativo', 'negozio', 'nemmeno', 'neofita', 'neretto', 'nervo', 'nessuno', 'nettuno', 'neutrale', 'neve', 'nevrotico', 'nicchia', 'ninfa', 'nitido', 'nobile', 'nocivo', 'nodo', 'nome', 'nomina', 'nordico', 'normale', 'norvegese', 'nostrano', 'notare', 'notizia', 'notturno', 'novella', 'nucleo', 'nulla', 'numero', 'nuovo', 'nutrire', 'nuvola', 'nuziale', 'oasi', 'obbedire', 'obbligo', 'obelisco', 'oblio', 'obolo', 'obsoleto', 'occasione', 'occhio', 'occidente', 'occorrere', 'occultare', 'ocra', 'oculato', 'odierno', 'odorare', 'offerta', 'offrire', 'offuscato', 'oggetto', 'oggi', 'ognuno', 'olandese', 'olfatto', 'oliato', 'oliva', 'ologramma', 'oltre', 'omaggio', 'ombelico', 'ombra', 'omega', 'omissione', 'ondoso', 'onere', 'onice', 'onnivoro', 'onorevole', 'onta', 'operato', 'opinione', 'opposto', 'oracolo', 'orafo', 'ordine', 'orecchino', 'orefice', 'orfano', 'organico', 'origine', 'orizzonte', 'orma', 'ormeggio', 'ornativo', 'orologio', 'orrendo', 'orribile', 'ortensia', 'ortica', 'orzata', 'orzo', 'osare', 'oscurare', 'osmosi', 'ospedale', 'ospite', 'ossa', 'ossidare', 'ostacolo', 'oste', 'otite', 'otre', 'ottagono', 'ottimo', 'ottobre', 'ovale', 'ovest', 'ovino', 'oviparo', 'ovocito', 'ovunque', 'ovviare', 'ozio', 'pacchetto', 'pace', 'pacifico', 'padella', 'padrone', 'paese', 'paga', 'pagina', 'palazzina', 'palesare', 'pallido', 'palo', 'palude', 'pandoro', 'pannello', 'paolo', 'paonazzo', 'paprica', 'parabola', 'parcella', 'parere', 'pargolo', 'pari', 'parlato', 'parola', 'partire', 'parvenza', 'parziale', 'passivo', 'pasticca', 'patacca', 'patologia', 'pattume', 'pavone', 'peccato', 'pedalare', 'pedonale', 'peggio', 'peloso', 'penare', 'pendice', 'penisola', 'pennuto', 'penombra', 'pensare', 'pentola', 'pepe', 'pepita', 'perbene', 'percorso', 'perdonato', 'perforare', 'pergamena', 'periodo', 'permesso', 'perno', 'perplesso', 'persuaso', 'pertugio', 'pervaso', 'pesatore', 'pesista', 'peso', 'pestifero', 'petalo', 'pettine', 'petulante', 'pezzo', 'piacere', 'pianta', 'piattino', 'piccino', 'picozza', 'piega', 'pietra', 'piffero', 'pigiama', 'pigolio', 'pigro', 'pila', 'pilifero', 'pillola', 'pilota', 'pimpante', 'pineta', 'pinna', 'pinolo', 'pioggia', 'piombo', 'piramide', 'piretico', 'pirite', 'pirolisi', 'pitone', 'pizzico', 'placebo', 'planare', 'plasma', 'platano', 'plenario', 'pochezza', 'poderoso', 'podismo', 'poesia', 'poggiare', 'polenta', 'poligono', 'pollice', 'polmonite', 'polpetta', 'polso', 'poltrona', 'polvere', 'pomice', 'pomodoro', 'ponte', 'popoloso', 'porfido', 'poroso', 'porpora', 'porre', 'portata', 'posa', 'positivo', 'possesso', 'postulato', 'potassio', 'potere', 'pranzo', 'prassi', 'pratica', 'precluso', 'predica', 'prefisso', 'pregiato', 'prelievo', 'premere', 'prenotare', 'preparato', 'presenza', 'pretesto', 'prevalso', 'prima', 'principe', 'privato', 'problema', 'procura', 'produrre', 'profumo', 'progetto', 'prolunga', 'promessa', 'pronome', 'proposta', 'proroga', 'proteso', 'prova', 'prudente', 'prugna', 'prurito', 'psiche', 'pubblico', 'pudica', 'pugilato', 'pugno', 'pulce', 'pulito', 'pulsante', 'puntare', 'pupazzo', 'pupilla', 'puro', 'quadro', 'qualcosa', 'quasi', 'querela', 'quota', 'raccolto', 'raddoppio', 'radicale', 'radunato', 'raffica', 'ragazzo', 'ragione', 'ragno', 'ramarro', 'ramingo', 'ramo', 'randagio', 'rantolare', 'rapato', 'rapina', 'rappreso', 'rasatura', 'raschiato', 'rasente', 'rassegna', 'rastrello', 'rata', 'ravveduto', 'reale', 'recepire', 'recinto', 'recluta', 'recondito', 'recupero', 'reddito', 'redimere', 'regalato', 'registro', 'regola', 'regresso', 'relazione', 'remare', 'remoto', 'renna', 'replica', 'reprimere', 'reputare', 'resa', 'residente', 'responso', 'restauro', 'rete', 'retina', 'retorica', 'rettifica', 'revocato', 'riassunto', 'ribadire', 'ribelle', 'ribrezzo', 'ricarica', 'ricco', 'ricevere', 'riciclato', 'ricordo', 'ricreduto', 'ridicolo', 'ridurre', 'rifasare', 'riflesso', 'riforma', 'rifugio', 'rigare', 'rigettato', 'righello', 'rilassato', 'rilevato', 'rimanere', 'rimbalzo', 'rimedio', 'rimorchio', 'rinascita', 'rincaro', 'rinforzo', 'rinnovo', 'rinomato', 'rinsavito', 'rintocco', 'rinuncia', 'rinvenire', 'riparato', 'ripetuto', 'ripieno', 'riportare', 'ripresa', 'ripulire', 'risata', 'rischio', 'riserva', 'risibile', 'riso', 'rispetto', 'ristoro', 'risultato', 'risvolto', 'ritardo', 'ritegno', 'ritmico', 'ritrovo', 'riunione', 'riva', 'riverso', 'rivincita', 'rivolto', 'rizoma', 'roba', 'robotico', 'robusto', 'roccia', 'roco', 'rodaggio', 'rodere', 'roditore', 'rogito', 'rollio', 'romantico', 'rompere', 'ronzio', 'rosolare', 'rospo', 'rotante', 'rotondo', 'rotula', 'rovescio', 'rubizzo', 'rubrica', 'ruga', 'rullino', 'rumine', 'rumoroso', 'ruolo', 'rupe', 'russare', 'rustico', 'sabato', 'sabbiare', 'sabotato', 'sagoma', 'salasso', 'saldatura', 'salgemma', 'salivare', 'salmone', 'salone', 'saltare', 'saluto', 'salvo', 'sapere', 'sapido', 'saporito', 'saraceno', 'sarcasmo', 'sarto', 'sassoso', 'satellite', 'satira', 'satollo', 'saturno', 'savana', 'savio', 'saziato', 'sbadiglio', 'sbalzo', 'sbancato', 'sbarra', 'sbattere', 'sbavare', 'sbendare', 'sbirciare', 'sbloccato', 'sbocciato', 'sbrinare', 'sbruffone', 'sbuffare', 'scabroso', 'scadenza', 'scala', 'scambiare', 'scandalo', 'scapola', 'scarso', 'scatenare', 'scavato', 'scelto', 'scenico', 'scettro', 'scheda', 'schiena', 'sciarpa', 'scienza', 'scindere', 'scippo', 'sciroppo', 'scivolo', 'sclerare', 'scodella', 'scolpito', 'scomparto', 'sconforto', 'scoprire', 'scorta', 'scossone', 'scozzese', 'scriba', 'scrollare', 'scrutinio', 'scuderia', 'scultore', 'scuola', 'scuro', 'scusare', 'sdebitare', 'sdoganare', 'seccatura', 'secondo', 'sedano', 'seggiola', 'segnalato', 'segregato', 'seguito', 'selciato', 'selettivo', 'sella', 'selvaggio', 'semaforo', 'sembrare', 'seme', 'seminato', 'sempre', 'senso', 'sentire', 'sepolto', 'sequenza', 'serata', 'serbato', 'sereno', 'serio', 'serpente', 'serraglio', 'servire', 'sestina', 'setola', 'settimana', 'sfacelo', 'sfaldare', 'sfamato', 'sfarzoso', 'sfaticato', 'sfera', 'sfida', 'sfilato', 'sfinge', 'sfocato', 'sfoderare', 'sfogo', 'sfoltire', 'sforzato', 'sfratto', 'sfruttato', 'sfuggito', 'sfumare', 'sfuso', 'sgabello', 'sgarbato', 'sgonfiare', 'sgorbio', 'sgrassato', 'sguardo', 'sibilo', 'siccome', 'sierra', 'sigla', 'signore', 'silenzio', 'sillaba', 'simbolo', 'simpatico', 'simulato', 'sinfonia', 'singolo', 'sinistro', 'sino', 'sintesi', 'sinusoide', 'sipario', 'sisma', 'sistole', 'situato', 'slitta', 'slogatura', 'sloveno', 'smarrito', 'smemorato', 'smentito', 'smeraldo', 'smilzo', 'smontare', 'smottato', 'smussato', 'snellire', 'snervato', 'snodo', 'sobbalzo', 'sobrio', 'soccorso', 'sociale', 'sodale', 'soffitto', 'sogno', 'soldato', 'solenne', 'solido', 'sollazzo', 'solo', 'solubile', 'solvente', 'somatico', 'somma', 'sonda', 'sonetto', 'sonnifero', 'sopire', 'soppeso', 'sopra', 'sorgere', 'sorpasso', 'sorriso', 'sorso', 'sorteggio', 'sorvolato', 'sospiro', 'sosta', 'sottile', 'spada', 'spalla', 'spargere', 'spatola', 'spavento', 'spazzola', 'specie', 'spedire', 'spegnere', 'spelatura', 'speranza', 'spessore', 'spettrale', 'spezzato', 'spia', 'spigoloso', 'spillato', 'spinoso', 'spirale', 'splendido', 'sportivo', 'sposo', 'spranga', 'sprecare', 'spronato', 'spruzzo', 'spuntino', 'squillo', 'sradicare', 'srotolato', 'stabile', 'stacco', 'staffa', 'stagnare', 'stampato', 'stantio', 'starnuto', 'stasera', 'statuto', 'stelo', 'steppa', 'sterzo', 'stiletto', 'stima', 'stirpe', 'stivale', 'stizzoso', 'stonato', 'storico', 'strappo', 'stregato', 'stridulo', 'strozzare', 'strutto', 'stuccare', 'stufo', 'stupendo', 'subentro', 'succoso', 'sudore', 'suggerito', 'sugo', 'sultano', 'suonare', 'superbo', 'supporto', 'surgelato', 'surrogato', 'sussurro', 'sutura', 'svagare', 'svedese', 'sveglio', 'svelare', 'svenuto', 'svezia', 'sviluppo', 'svista', 'svizzera', 'svolta', 'svuotare', 'tabacco', 'tabulato', 'tacciare', 'taciturno', 'tale', 'talismano', 'tampone', 'tannino', 'tara', 'tardivo', 'targato', 'tariffa', 'tarpare', 'tartaruga', 'tasto', 'tattico', 'taverna', 'tavolata', 'tazza', 'teca', 'tecnico', 'telefono', 'temerario', 'tempo', 'temuto', 'tendone', 'tenero', 'tensione', 'tentacolo', 'teorema', 'terme', 'terrazzo', 'terzetto', 'tesi', 'tesserato', 'testato', 'tetro', 'tettoia', 'tifare', 'tigella', 'timbro', 'tinto', 'tipico', 'tipografo', 'tiraggio', 'tiro', 'titanio', 'titolo', 'titubante', 'tizio', 'tizzone', 'toccare', 'tollerare', 'tolto', 'tombola', 'tomo', 'tonfo', 'tonsilla', 'topazio', 'topologia', 'toppa', 'torba', 'tornare', 'torrone', 'tortora', 'toscano', 'tossire', 'tostatura', 'totano', 'trabocco', 'trachea', 'trafila', 'tragedia', 'tralcio', 'tramonto', 'transito', 'trapano', 'trarre', 'trasloco', 'trattato', 'trave', 'treccia', 'tremolio', 'trespolo', 'tributo', 'tricheco', 'trifoglio', 'trillo', 'trincea', 'trio', 'tristezza', 'triturato', 'trivella', 'tromba', 'trono', 'troppo', 'trottola', 'trovare', 'truccato', 'tubatura', 'tuffato', 'tulipano', 'tumulto', 'tunisia', 'turbare', 'turchino', 'tuta', 'tutela', 'ubicato', 'uccello', 'uccisore', 'udire', 'uditivo', 'uffa', 'ufficio', 'uguale', 'ulisse', 'ultimato', 'umano', 'umile', 'umorismo', 'uncinetto', 'ungere', 'ungherese', 'unicorno', 'unificato', 'unisono', 'unitario', 'unte', 'uovo', 'upupa', 'uragano', 'urgenza', 'urlo', 'usanza', 'usato', 'uscito', 'usignolo', 'usuraio', 'utensile', 'utilizzo', 'utopia', 'vacante', 'vaccinato', 'vagabondo', 'vagliato', 'valanga', 'valgo', 'valico', 'valletta', 'valoroso', 'valutare', 'valvola', 'vampata', 'vangare', 'vanitoso', 'vano', 'vantaggio', 'vanvera', 'vapore', 'varano', 'varcato', 'variante', 'vasca', 'vedetta', 'vedova', 'veduto', 'vegetale', 'veicolo', 'velcro', 'velina', 'velluto', 'veloce', 'venato', 'vendemmia', 'vento', 'verace', 'verbale', 'vergogna', 'verifica', 'vero', 'verruca', 'verticale', 'vescica', 'vessillo', 'vestale', 'veterano', 'vetrina', 'vetusto', 'viandante', 'vibrante', 'vicenda', 'vichingo', 'vicinanza', 'vidimare', 'vigilia', 'vigneto', 'vigore', 'vile', 'villano', 'vimini', 'vincitore', 'viola', 'vipera', 'virgola', 'virologo', 'virulento', 'viscoso', 'visione', 'vispo', 'vissuto', 'visura', 'vita', 'vitello', 'vittima', 'vivanda', 'vivido', 'viziare', 'voce', 'voga', 'volatile', 'volere', 'volpe', 'voragine', 'vulcano', 'zampogna', 'zanna', 'zappato', 'zattera', 'zavorra', 'zefiro', 'zelante', 'zelo', 'zenzero', 'zerbino', 'zibetto', 'zinco', 'zircone', 'zitto', 'zolla', 'zotico', 'zucchero', 'zufolo', 'zulu', 'zuppa'];\nvar JAPANESE = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];\nvar SPANISH = ['abaco', 'abdomen', 'abeja', 'abierto', 'abogado', 'abono', 'aborto', 'abrazo', 'abrir', 'abuelo', 'abuso', 'acabar', 'academia', 'acceso', 'accion', 'aceite', 'acelga', 'acento', 'aceptar', 'acido', 'aclarar', 'acne', 'acoger', 'acoso', 'activo', 'acto', 'actriz', 'actuar', 'acudir', 'acuerdo', 'acusar', 'adicto', 'admitir', 'adoptar', 'adorno', 'aduana', 'adulto', 'aereo', 'afectar', 'aficion', 'afinar', 'afirmar', 'agil', 'agitar', 'agonia', 'agosto', 'agotar', 'agregar', 'agrio', 'agua', 'agudo', 'aguila', 'aguja', 'ahogo', 'ahorro', 'aire', 'aislar', 'ajedrez', 'ajeno', 'ajuste', 'alacran', 'alambre', 'alarma', 'alba', 'album', 'alcalde', 'aldea', 'alegre', 'alejar', 'alerta', 'aleta', 'alfiler', 'alga', 'algodon', 'aliado', 'aliento', 'alivio', 'alma', 'almeja', 'almibar', 'altar', 'alteza', 'altivo', 'alto', 'altura', 'alumno', 'alzar', 'amable', 'amante', 'amapola', 'amargo', 'amasar', 'ambar', 'ambito', 'ameno', 'amigo', 'amistad', 'amor', 'amparo', 'amplio', 'ancho', 'anciano', 'ancla', 'andar', 'anden', 'anemia', 'angulo', 'anillo', 'animo', 'anis', 'anotar', 'antena', 'antiguo', 'antojo', 'anual', 'anular', 'anuncio', 'anadir', 'anejo', 'ano', 'apagar', 'aparato', 'apetito', 'apio', 'aplicar', 'apodo', 'aporte', 'apoyo', 'aprender', 'aprobar', 'apuesta', 'apuro', 'arado', 'arana', 'arar', 'arbitro', 'arbol', 'arbusto', 'archivo', 'arco', 'arder', 'ardilla', 'arduo', 'area', 'arido', 'aries', 'armonia', 'arnes', 'aroma', 'arpa', 'arpon', 'arreglo', 'arroz', 'arruga', 'arte', 'artista', 'asa', 'asado', 'asalto', 'ascenso', 'asegurar', 'aseo', 'asesor', 'asiento', 'asilo', 'asistir', 'asno', 'asombro', 'aspero', 'astilla', 'astro', 'astuto', 'asumir', 'asunto', 'atajo', 'ataque', 'atar', 'atento', 'ateo', 'atico', 'atleta', 'atomo', 'atraer', 'atroz', 'atun', 'audaz', 'audio', 'auge', 'aula', 'aumento', 'ausente', 'autor', 'aval', 'avance', 'avaro', 'ave', 'avellana', 'avena', 'avestruz', 'avion', 'aviso', 'ayer', 'ayuda', 'ayuno', 'azafran', 'azar', 'azote', 'azucar', 'azufre', 'azul', 'baba', 'babor', 'bache', 'bahia', 'baile', 'bajar', 'balanza', 'balcon', 'balde', 'bambu', 'banco', 'banda', 'bano', 'barba', 'barco', 'barniz', 'barro', 'bascula', 'baston', 'basura', 'batalla', 'bateria', 'batir', 'batuta', 'baul', 'bazar', 'bebe', 'bebida', 'bello', 'besar', 'beso', 'bestia', 'bicho', 'bien', 'bingo', 'blanco', 'bloque', 'blusa', 'boa', 'bobina', 'bobo', 'boca', 'bocina', 'boda', 'bodega', 'boina', 'bola', 'bolero', 'bolsa', 'bomba', 'bondad', 'bonito', 'bono', 'bonsai', 'borde', 'borrar', 'bosque', 'bote', 'botin', 'boveda', 'bozal', 'bravo', 'brazo', 'brecha', 'breve', 'brillo', 'brinco', 'brisa', 'broca', 'broma', 'bronce', 'brote', 'bruja', 'brusco', 'bruto', 'buceo', 'bucle', 'bueno', 'buey', 'bufanda', 'bufon', 'buho', 'buitre', 'bulto', 'burbuja', 'burla', 'burro', 'buscar', 'butaca', 'buzon', 'caballo', 'cabeza', 'cabina', 'cabra', 'cacao', 'cadaver', 'cadena', 'caer', 'cafe', 'caida', 'caiman', 'caja', 'cajon', 'cal', 'calamar', 'calcio', 'caldo', 'calidad', 'calle', 'calma', 'calor', 'calvo', 'cama', 'cambio', 'camello', 'camino', 'campo', 'cancer', 'candil', 'canela', 'canguro', 'canica', 'canto', 'cana', 'canon', 'caoba', 'caos', 'capaz', 'capitan', 'capote', 'captar', 'capucha', 'cara', 'carbon', 'carcel', 'careta', 'carga', 'carino', 'carne', 'carpeta', 'carro', 'carta', 'casa', 'casco', 'casero', 'caspa', 'castor', 'catorce', 'catre', 'caudal', 'causa', 'cazo', 'cebolla', 'ceder', 'cedro', 'celda', 'celebre', 'celoso', 'celula', 'cemento', 'ceniza', 'centro', 'cerca', 'cerdo', 'cereza', 'cero', 'cerrar', 'certeza', 'cesped', 'cetro', 'chacal', 'chaleco', 'champu', 'chancla', 'chapa', 'charla', 'chico', 'chiste', 'chivo', 'choque', 'choza', 'chuleta', 'chupar', 'ciclon', 'ciego', 'cielo', 'cien', 'cierto', 'cifra', 'cigarro', 'cima', 'cinco', 'cine', 'cinta', 'cipres', 'circo', 'ciruela', 'cisne', 'cita', 'ciudad', 'clamor', 'clan', 'claro', 'clase', 'clave', 'cliente', 'clima', 'clinica', 'cobre', 'coccion', 'cochino', 'cocina', 'coco', 'codigo', 'codo', 'cofre', 'coger', 'cohete', 'cojin', 'cojo', 'cola', 'colcha', 'colegio', 'colgar', 'colina', 'collar', 'colmo', 'columna', 'combate', 'comer', 'comida', 'comodo', 'compra', 'conde', 'conejo', 'conga', 'conocer', 'consejo', 'contar', 'copa', 'copia', 'corazon', 'corbata', 'corcho', 'cordon', 'corona', 'correr', 'coser', 'cosmos', 'costa', 'craneo', 'crater', 'crear', 'crecer', 'creido', 'crema', 'cria', 'crimen', 'cripta', 'crisis', 'cromo', 'cronica', 'croqueta', 'crudo', 'cruz', 'cuadro', 'cuarto', 'cuatro', 'cubo', 'cubrir', 'cuchara', 'cuello', 'cuento', 'cuerda', 'cuesta', 'cueva', 'cuidar', 'culebra', 'culpa', 'culto', 'cumbre', 'cumplir', 'cuna', 'cuneta', 'cuota', 'cupon', 'cupula', 'curar', 'curioso', 'curso', 'curva', 'cutis', 'dama', 'danza', 'dar', 'dardo', 'datil', 'deber', 'debil', 'decada', 'decir', 'dedo', 'defensa', 'definir', 'dejar', 'delfin', 'delgado', 'delito', 'demora', 'denso', 'dental', 'deporte', 'derecho', 'derrota', 'desayuno', 'deseo', 'desfile', 'desnudo', 'destino', 'desvio', 'detalle', 'detener', 'deuda', 'dia', 'diablo', 'diadema', 'diamante', 'diana', 'diario', 'dibujo', 'dictar', 'diente', 'dieta', 'diez', 'dificil', 'digno', 'dilema', 'diluir', 'dinero', 'directo', 'dirigir', 'disco', 'diseno', 'disfraz', 'diva', 'divino', 'doble', 'doce', 'dolor', 'domingo', 'don', 'donar', 'dorado', 'dormir', 'dorso', 'dos', 'dosis', 'dragon', 'droga', 'ducha', 'duda', 'duelo', 'dueno', 'dulce', 'duo', 'duque', 'durar', 'dureza', 'duro', 'ebano', 'ebrio', 'echar', 'eco', 'ecuador', 'edad', 'edicion', 'edificio', 'editor', 'educar', 'efecto', 'eficaz', 'eje', 'ejemplo', 'elefante', 'elegir', 'elemento', 'elevar', 'elipse', 'elite', 'elixir', 'elogio', 'eludir', 'embudo', 'emitir', 'emocion', 'empate', 'empeno', 'empleo', 'empresa', 'enano', 'encargo', 'enchufe', 'encia', 'enemigo', 'enero', 'enfado', 'enfermo', 'engano', 'enigma', 'enlace', 'enorme', 'enredo', 'ensayo', 'ensenar', 'entero', 'entrar', 'envase', 'envio', 'epoca', 'equipo', 'erizo', 'escala', 'escena', 'escolar', 'escribir', 'escudo', 'esencia', 'esfera', 'esfuerzo', 'espada', 'espejo', 'espia', 'esposa', 'espuma', 'esqui', 'estar', 'este', 'estilo', 'estufa', 'etapa', 'eterno', 'etica', 'etnia', 'evadir', 'evaluar', 'evento', 'evitar', 'exacto', 'examen', 'exceso', 'excusa', 'exento', 'exigir', 'exilio', 'existir', 'exito', 'experto', 'explicar', 'exponer', 'extremo', 'fabrica', 'fabula', 'fachada', 'facil', 'factor', 'faena', 'faja', 'falda', 'fallo', 'falso', 'faltar', 'fama', 'familia', 'famoso', 'faraon', 'farmacia', 'farol', 'farsa', 'fase', 'fatiga', 'fauna', 'favor', 'fax', 'febrero', 'fecha', 'feliz', 'feo', 'feria', 'feroz', 'fertil', 'fervor', 'festin', 'fiable', 'fianza', 'fiar', 'fibra', 'ficcion', 'ficha', 'fideo', 'fiebre', 'fiel', 'fiera', 'fiesta', 'figura', 'fijar', 'fijo', 'fila', 'filete', 'filial', 'filtro', 'fin', 'finca', 'fingir', 'finito', 'firma', 'flaco', 'flauta', 'flecha', 'flor', 'flota', 'fluir', 'flujo', 'fluor', 'fobia', 'foca', 'fogata', 'fogon', 'folio', 'folleto', 'fondo', 'forma', 'forro', 'fortuna', 'forzar', 'fosa', 'foto', 'fracaso', 'fragil', 'franja', 'frase', 'fraude', 'freir', 'freno', 'fresa', 'frio', 'frito', 'fruta', 'fuego', 'fuente', 'fuerza', 'fuga', 'fumar', 'funcion', 'funda', 'furgon', 'furia', 'fusil', 'futbol', 'futuro', 'gacela', 'gafas', 'gaita', 'gajo', 'gala', 'galeria', 'gallo', 'gamba', 'ganar', 'gancho', 'ganga', 'ganso', 'garaje', 'garza', 'gasolina', 'gastar', 'gato', 'gavilan', 'gemelo', 'gemir', 'gen', 'genero', 'genio', 'gente', 'geranio', 'gerente', 'germen', 'gesto', 'gigante', 'gimnasio', 'girar', 'giro', 'glaciar', 'globo', 'gloria', 'gol', 'golfo', 'goloso', 'golpe', 'goma', 'gordo', 'gorila', 'gorra', 'gota', 'goteo', 'gozar', 'grada', 'grafico', 'grano', 'grasa', 'gratis', 'grave', 'grieta', 'grillo', 'gripe', 'gris', 'grito', 'grosor', 'grua', 'grueso', 'grumo', 'grupo', 'guante', 'guapo', 'guardia', 'guerra', 'guia', 'guino', 'guion', 'guiso', 'guitarra', 'gusano', 'gustar', 'haber', 'habil', 'hablar', 'hacer', 'hacha', 'hada', 'hallar', 'hamaca', 'harina', 'haz', 'hazana', 'hebilla', 'hebra', 'hecho', 'helado', 'helio', 'hembra', 'herir', 'hermano', 'heroe', 'hervir', 'hielo', 'hierro', 'higado', 'higiene', 'hijo', 'himno', 'historia', 'hocico', 'hogar', 'hoguera', 'hoja', 'hombre', 'hongo', 'honor', 'honra', 'hora', 'hormiga', 'horno', 'hostil', 'hoyo', 'hueco', 'huelga', 'huerta', 'hueso', 'huevo', 'huida', 'huir', 'humano', 'humedo', 'humilde', 'humo', 'hundir', 'huracan', 'hurto', 'icono', 'ideal', 'idioma', 'idolo', 'iglesia', 'iglu', 'igual', 'ilegal', 'ilusion', 'imagen', 'iman', 'imitar', 'impar', 'imperio', 'imponer', 'impulso', 'incapaz', 'indice', 'inerte', 'infiel', 'informe', 'ingenio', 'inicio', 'inmenso', 'inmune', 'innato', 'insecto', 'instante', 'interes', 'intimo', 'intuir', 'inutil', 'invierno', 'ira', 'iris', 'ironia', 'isla', 'islote', 'jabali', 'jabon', 'jamon', 'jarabe', 'jardin', 'jarra', 'jaula', 'jazmin', 'jefe', 'jeringa', 'jinete', 'jornada', 'joroba', 'joven', 'joya', 'juerga', 'jueves', 'juez', 'jugador', 'jugo', 'juguete', 'juicio', 'junco', 'jungla', 'junio', 'juntar', 'jupiter', 'jurar', 'justo', 'juvenil', 'juzgar', 'kilo', 'koala', 'labio', 'lacio', 'lacra', 'lado', 'ladron', 'lagarto', 'lagrima', 'laguna', 'laico', 'lamer', 'lamina', 'lampara', 'lana', 'lancha', 'langosta', 'lanza', 'lapiz', 'largo', 'larva', 'lastima', 'lata', 'latex', 'latir', 'laurel', 'lavar', 'lazo', 'leal', 'leccion', 'leche', 'lector', 'leer', 'legion', 'legumbre', 'lejano', 'lengua', 'lento', 'lena', 'leon', 'leopardo', 'lesion', 'letal', 'letra', 'leve', 'leyenda', 'libertad', 'libro', 'licor', 'lider', 'lidiar', 'lienzo', 'liga', 'ligero', 'lima', 'limite', 'limon', 'limpio', 'lince', 'lindo', 'linea', 'lingote', 'lino', 'linterna', 'liquido', 'liso', 'lista', 'litera', 'litio', 'litro', 'llaga', 'llama', 'llanto', 'llave', 'llegar', 'llenar', 'llevar', 'llorar', 'llover', 'lluvia', 'lobo', 'locion', 'loco', 'locura', 'logica', 'logro', 'lombriz', 'lomo', 'lonja', 'lote', 'lucha', 'lucir', 'lugar', 'lujo', 'luna', 'lunes', 'lupa', 'lustro', 'luto', 'luz', 'maceta', 'macho', 'madera', 'madre', 'maduro', 'maestro', 'mafia', 'magia', 'mago', 'maiz', 'maldad', 'maleta', 'malla', 'malo', 'mama', 'mambo', 'mamut', 'manco', 'mando', 'manejar', 'manga', 'maniqui', 'manjar', 'mano', 'manso', 'manta', 'manana', 'mapa', 'maquina', 'mar', 'marco', 'marea', 'marfil', 'margen', 'marido', 'marmol', 'marron', 'martes', 'marzo', 'masa', 'mascara', 'masivo', 'matar', 'materia', 'matiz', 'matriz', 'maximo', 'mayor', 'mazorca', 'mecha', 'medalla', 'medio', 'medula', 'mejilla', 'mejor', 'melena', 'melon', 'memoria', 'menor', 'mensaje', 'mente', 'menu', 'mercado', 'merengue', 'merito', 'mes', 'meson', 'meta', 'meter', 'metodo', 'metro', 'mezcla', 'miedo', 'miel', 'miembro', 'miga', 'mil', 'milagro', 'militar', 'millon', 'mimo', 'mina', 'minero', 'minimo', 'minuto', 'miope', 'mirar', 'misa', 'miseria', 'misil', 'mismo', 'mitad', 'mito', 'mochila', 'mocion', 'moda', 'modelo', 'moho', 'mojar', 'molde', 'moler', 'molino', 'momento', 'momia', 'monarca', 'moneda', 'monja', 'monto', 'mono', 'morada', 'morder', 'moreno', 'morir', 'morro', 'morsa', 'mortal', 'mosca', 'mostrar', 'motivo', 'mover', 'movil', 'mozo', 'mucho', 'mudar', 'mueble', 'muela', 'muerte', 'muestra', 'mugre', 'mujer', 'mula', 'muleta', 'multa', 'mundo', 'muneca', 'mural', 'muro', 'musculo', 'museo', 'musgo', 'musica', 'muslo', 'nacar', 'nacion', 'nadar', 'naipe', 'naranja', 'nariz', 'narrar', 'nasal', 'natal', 'nativo', 'natural', 'nausea', 'naval', 'nave', 'navidad', 'necio', 'nectar', 'negar', 'negocio', 'negro', 'neon', 'nervio', 'neto', 'neutro', 'nevar', 'nevera', 'nicho', 'nido', 'niebla', 'nieto', 'ninez', 'nino', 'nitido', 'nivel', 'nobleza', 'noche', 'nomina', 'noria', 'norma', 'norte', 'nota', 'noticia', 'novato', 'novela', 'novio', 'nube', 'nuca', 'nucleo', 'nudillo', 'nudo', 'nuera', 'nueve', 'nuez', 'nulo', 'numero', 'nutria', 'oasis', 'obeso', 'obispo', 'objeto', 'obra', 'obrero', 'observar', 'obtener', 'obvio', 'oca', 'ocaso', 'oceano', 'ochenta', 'ocho', 'ocio', 'ocre', 'octavo', 'octubre', 'oculto', 'ocupar', 'ocurrir', 'odiar', 'odio', 'odisea', 'oeste', 'ofensa', 'oferta', 'oficio', 'ofrecer', 'ogro', 'oido', 'oir', 'ojo', 'ola', 'oleada', 'olfato', 'olivo', 'olla', 'olmo', 'olor', 'olvido', 'ombligo', 'onda', 'onza', 'opaco', 'opcion', 'opera', 'opinar', 'oponer', 'optar', 'optica', 'opuesto', 'oracion', 'orador', 'oral', 'orbita', 'orca', 'orden', 'oreja', 'organo', 'orgia', 'orgullo', 'oriente', 'origen', 'orilla', 'oro', 'orquesta', 'oruga', 'osadia', 'oscuro', 'osezno', 'oso', 'ostra', 'otono', 'otro', 'oveja', 'ovulo', 'oxido', 'oxigeno', 'oyente', 'ozono', 'pacto', 'padre', 'paella', 'pagina', 'pago', 'pais', 'pajaro', 'palabra', 'palco', 'paleta', 'palido', 'palma', 'paloma', 'palpar', 'pan', 'panal', 'panico', 'pantera', 'panuelo', 'papa', 'papel', 'papilla', 'paquete', 'parar', 'parcela', 'pared', 'parir', 'paro', 'parpado', 'parque', 'parrafo', 'parte', 'pasar', 'paseo', 'pasion', 'paso', 'pasta', 'pata', 'patio', 'patria', 'pausa', 'pauta', 'pavo', 'payaso', 'peaton', 'pecado', 'pecera', 'pecho', 'pedal', 'pedir', 'pegar', 'peine', 'pelar', 'peldano', 'pelea', 'peligro', 'pellejo', 'pelo', 'peluca', 'pena', 'pensar', 'penon', 'peon', 'peor', 'pepino', 'pequeno', 'pera', 'percha', 'perder', 'pereza', 'perfil', 'perico', 'perla', 'permiso', 'perro', 'persona', 'pesa', 'pesca', 'pesimo', 'pestana', 'petalo', 'petroleo', 'pez', 'pezuna', 'picar', 'pichon', 'pie', 'piedra', 'pierna', 'pieza', 'pijama', 'pilar', 'piloto', 'pimienta', 'pino', 'pintor', 'pinza', 'pina', 'piojo', 'pipa', 'pirata', 'pisar', 'piscina', 'piso', 'pista', 'piton', 'pizca', 'placa', 'plan', 'plata', 'playa', 'plaza', 'pleito', 'pleno', 'plomo', 'pluma', 'plural', 'pobre', 'poco', 'poder', 'podio', 'poema', 'poesia', 'poeta', 'polen', 'policia', 'pollo', 'polvo', 'pomada', 'pomelo', 'pomo', 'pompa', 'poner', 'porcion', 'portal', 'posada', 'poseer', 'posible', 'poste', 'potencia', 'potro', 'pozo', 'prado', 'precoz', 'pregunta', 'premio', 'prensa', 'preso', 'previo', 'primo', 'principe', 'prision', 'privar', 'proa', 'probar', 'proceso', 'producto', 'proeza', 'profesor', 'programa', 'prole', 'promesa', 'pronto', 'propio', 'proximo', 'prueba', 'publico', 'puchero', 'pudor', 'pueblo', 'puerta', 'puesto', 'pulga', 'pulir', 'pulmon', 'pulpo', 'pulso', 'puma', 'punto', 'punal', 'puno', 'pupa', 'pupila', 'pure', 'quedar', 'queja', 'quemar', 'querer', 'queso', 'quieto', 'quimica', 'quince', 'quitar', 'rabano', 'rabia', 'rabo', 'racion', 'radical', 'raiz', 'rama', 'rampa', 'rancho', 'rango', 'rapaz', 'rapido', 'rapto', 'rasgo', 'raspa', 'rato', 'rayo', 'raza', 'razon', 'reaccion', 'realidad', 'rebano', 'rebote', 'recaer', 'receta', 'rechazo', 'recoger', 'recreo', 'recto', 'recurso', 'red', 'redondo', 'reducir', 'reflejo', 'reforma', 'refran', 'refugio', 'regalo', 'regir', 'regla', 'regreso', 'rehen', 'reino', 'reir', 'reja', 'relato', 'relevo', 'relieve', 'relleno', 'reloj', 'remar', 'remedio', 'remo', 'rencor', 'rendir', 'renta', 'reparto', 'repetir', 'reposo', 'reptil', 'res', 'rescate', 'resina', 'respeto', 'resto', 'resumen', 'retiro', 'retorno', 'retrato', 'reunir', 'reves', 'revista', 'rey', 'rezar', 'rico', 'riego', 'rienda', 'riesgo', 'rifa', 'rigido', 'rigor', 'rincon', 'rinon', 'rio', 'riqueza', 'risa', 'ritmo', 'rito', 'rizo', 'roble', 'roce', 'rociar', 'rodar', 'rodeo', 'rodilla', 'roer', 'rojizo', 'rojo', 'romero', 'romper', 'ron', 'ronco', 'ronda', 'ropa', 'ropero', 'rosa', 'rosca', 'rostro', 'rotar', 'rubi', 'rubor', 'rudo', 'rueda', 'rugir', 'ruido', 'ruina', 'ruleta', 'rulo', 'rumbo', 'rumor', 'ruptura', 'ruta', 'rutina', 'sabado', 'saber', 'sabio', 'sable', 'sacar', 'sagaz', 'sagrado', 'sala', 'saldo', 'salero', 'salir', 'salmon', 'salon', 'salsa', 'salto', 'salud', 'salvar', 'samba', 'sancion', 'sandia', 'sanear', 'sangre', 'sanidad', 'sano', 'santo', 'sapo', 'saque', 'sardina', 'sarten', 'sastre', 'satan', 'sauna', 'saxofon', 'seccion', 'seco', 'secreto', 'secta', 'sed', 'seguir', 'seis', 'sello', 'selva', 'semana', 'semilla', 'senda', 'sensor', 'senal', 'senor', 'separar', 'sepia', 'sequia', 'ser', 'serie', 'sermon', 'servir', 'sesenta', 'sesion', 'seta', 'setenta', 'severo', 'sexo', 'sexto', 'sidra', 'siesta', 'siete', 'siglo', 'signo', 'silaba', 'silbar', 'silencio', 'silla', 'simbolo', 'simio', 'sirena', 'sistema', 'sitio', 'situar', 'sobre', 'socio', 'sodio', 'sol', 'solapa', 'soldado', 'soledad', 'solido', 'soltar', 'solucion', 'sombra', 'sondeo', 'sonido', 'sonoro', 'sonrisa', 'sopa', 'soplar', 'soporte', 'sordo', 'sorpresa', 'sorteo', 'sosten', 'sotano', 'suave', 'subir', 'suceso', 'sudor', 'suegra', 'suelo', 'sueno', 'suerte', 'sufrir', 'sujeto', 'sultan', 'sumar', 'superar', 'suplir', 'suponer', 'supremo', 'sur', 'surco', 'sureno', 'surgir', 'susto', 'sutil', 'tabaco', 'tabique', 'tabla', 'tabu', 'taco', 'tacto', 'tajo', 'talar', 'talco', 'talento', 'talla', 'talon', 'tamano', 'tambor', 'tango', 'tanque', 'tapa', 'tapete', 'tapia', 'tapon', 'taquilla', 'tarde', 'tarea', 'tarifa', 'tarjeta', 'tarot', 'tarro', 'tarta', 'tatuaje', 'tauro', 'taza', 'tazon', 'teatro', 'techo', 'tecla', 'tecnica', 'tejado', 'tejer', 'tejido', 'tela', 'telefono', 'tema', 'temor', 'templo', 'tenaz', 'tender', 'tener', 'tenis', 'tenso', 'teoria', 'terapia', 'terco', 'termino', 'ternura', 'terror', 'tesis', 'tesoro', 'testigo', 'tetera', 'texto', 'tez', 'tibio', 'tiburon', 'tiempo', 'tienda', 'tierra', 'tieso', 'tigre', 'tijera', 'tilde', 'timbre', 'timido', 'timo', 'tinta', 'tio', 'tipico', 'tipo', 'tira', 'tiron', 'titan', 'titere', 'titulo', 'tiza', 'toalla', 'tobillo', 'tocar', 'tocino', 'todo', 'toga', 'toldo', 'tomar', 'tono', 'tonto', 'topar', 'tope', 'toque', 'torax', 'torero', 'tormenta', 'torneo', 'toro', 'torpedo', 'torre', 'torso', 'tortuga', 'tos', 'tosco', 'toser', 'toxico', 'trabajo', 'tractor', 'traer', 'trafico', 'trago', 'traje', 'tramo', 'trance', 'trato', 'trauma', 'trazar', 'trebol', 'tregua', 'treinta', 'tren', 'trepar', 'tres', 'tribu', 'trigo', 'tripa', 'triste', 'triunfo', 'trofeo', 'trompa', 'tronco', 'tropa', 'trote', 'trozo', 'truco', 'trueno', 'trufa', 'tuberia', 'tubo', 'tuerto', 'tumba', 'tumor', 'tunel', 'tunica', 'turbina', 'turismo', 'turno', 'tutor', 'ubicar', 'ulcera', 'umbral', 'unidad', 'unir', 'universo', 'uno', 'untar', 'una', 'urbano', 'urbe', 'urgente', 'urna', 'usar', 'usuario', 'util', 'utopia', 'uva', 'vaca', 'vacio', 'vacuna', 'vagar', 'vago', 'vaina', 'vajilla', 'vale', 'valido', 'valle', 'valor', 'valvula', 'vampiro', 'vara', 'variar', 'varon', 'vaso', 'vecino', 'vector', 'vehiculo', 'veinte', 'vejez', 'vela', 'velero', 'veloz', 'vena', 'vencer', 'venda', 'veneno', 'vengar', 'venir', 'venta', 'venus', 'ver', 'verano', 'verbo', 'verde', 'vereda', 'verja', 'verso', 'verter', 'via', 'viaje', 'vibrar', 'vicio', 'victima', 'vida', 'video', 'vidrio', 'viejo', 'viernes', 'vigor', 'vil', 'villa', 'vinagre', 'vino', 'vinedo', 'violin', 'viral', 'virgo', 'virtud', 'visor', 'vispera', 'vista', 'vitamina', 'viudo', 'vivaz', 'vivero', 'vivir', 'vivo', 'volcan', 'volumen', 'volver', 'voraz', 'votar', 'voto', 'voz', 'vuelo', 'vulgar', 'yacer', 'yate', 'yegua', 'yema', 'yerno', 'yeso', 'yodo', 'yoga', 'yogur', 'zafiro', 'zanja', 'zapato', 'zarza', 'zona', 'zorro', 'zumo', 'zurdo'];\nvar Words = {\n  CHINESE,\n  ENGLISH,\n  FRENCH,\n  ITALIAN,\n  JAPANESE,\n  SPANISH\n};\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\n// eslint-disable-next-line consistent-return\n\nvar Mnemonic = function Mnemonic(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  } // handle data overloading\n\n\n  var ent;\n  var phrase;\n  var seed;\n\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n\n  ent = ent || 128; // check and detect wordlist\n\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  } // validate phrase and ent\n\n\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = Words;\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * const valid = Mnemonic.isValid(\n *   'lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband',\n * );\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\n\nMnemonic.isValid = function (mnemonic, wordlist) {\n  var i;\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n\n  for (i = 0; i < words.length; i += 1) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin += \"00000000000\".concat(ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hashBits = bin.slice(-cs);\n  var nonhashBits = bin.slice(0, bin.length - cs);\n  var buf = Buffer.alloc(nonhashBits.length / 8);\n\n  for (i = 0; i < nonhashBits.length / 8; i += 1) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n\n  var expectedHashBits = Mnemonic._entropyChecksum(buf);\n\n  return expectedHashBits === hashBits;\n};\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\n\n\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n\n  for (var i = 0; i < words.length; i += 1) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n\n  return true;\n};\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\n\n\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n\n  for (var i = 0; i < dicts.length; i += 1) {\n    var key = dicts[i];\n\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n\n  return null;\n};\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\n\n\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return Mnemonic.pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd(\"mnemonic\".concat(passphrase)), 2048, 64);\n};\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\n\n\nMnemonic.fromSeed = function (seed, wordlist) {\n  preconditions.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  preconditions.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\n\n\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return HDPrivateKey.fromSeed(seed, network);\n};\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.inspect = function () {\n  return \"<Mnemonic: \".concat(this.toString(), \" >\");\n};\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n  var i;\n\n  for (i = 0; i < entropy.length; i += 1) {\n    bin += \"00000000\".concat(entropy[i].toString(2)).slice(-8);\n  }\n\n  bin += Mnemonic._entropyChecksum(entropy);\n\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n\n  var mnemonic = [];\n\n  for (i = 0; i < bin.length / 11; i += 1) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n\n  var ret;\n\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n\n  return ret;\n};\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\n\n\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2); // zero pad the hash bits\n\n  while (hashbits.length % 256 !== 0) {\n    hashbits = \"0\".concat(hashbits);\n  }\n\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\n\nMnemonic.pbkdf2 = pbkdf2;\nvar name = \"bitcoinsource\";\nvar version = \"0.1.19\";\nvar description = \"A simple, safe, and powerful JavaScript Bitcoin Cash library.\";\nvar author = \"Clemens Ley <ley.clemens@gmail.com>\";\nvar license = \"MIT\";\nvar main = \"dist/bitcoinsource.common.js\";\nvar module = \"dist/bitcoinsource.esm.js\";\nvar files = [\"dist\"];\nvar scripts = {\n  build: \"rollup -c\",\n  test: \"mocha --recursive --timeout 7000 --require @babel/register\",\n  \"test:cover\": \"nyc mocha\",\n  lint: \"eslint src test\",\n  \"lint:fix\": \"eslint src test --fix\",\n  flow: \"flow check\",\n  clean: \"rm -rf dist\",\n  docs: \"mustache package.json README.tpl.md > README.md\",\n  preversion: \"npm run clean && npm run lint && npm run flow && npm run test\",\n  version: \"npm run build && npm run docs && git add README.md\",\n  postversion: \"git push && git push --tags && npm publish\",\n  bump: \"npm version patch -m 'Bump version to %s.'\"\n};\nvar keywords = [\"bitcoin\", \"source\", \"transaction\", \"address\", \"p2p\", \"cryptocurrency\", \"blockchain\", \"payment\", \"multisig\"];\nvar repository = {\n  type: \"git\",\n  url: \"https://github.com/bitcoin-computer/bitcoin-source\"\n};\nvar prettier = {\n  printWidth: 100,\n  proseWrap: \"preserve\",\n  semi: false,\n  singleQuote: true\n};\nvar dependencies = {\n  \"big-integer\": \"^1.6.48\",\n  \"bn.js\": \"^4.11.9\",\n  bs58: \"=4.0.1\",\n  \"buffer-compare\": \"=1.1.1\",\n  cashaddrjs: \"^0.3.11\",\n  elliptic: \"^6.5.2\",\n  \"hash.js\": \"^1.1.7\",\n  lodash: \"^4.17.15\",\n  randombytes: \"^2.1.0\",\n  unorm: \"^1.6.0\"\n};\nvar devDependencies = {\n  \"@babel/core\": \"^7.9.6\",\n  \"@babel/preset-env\": \"^7.9.6\",\n  \"@babel/preset-flow\": \"^7.9.0\",\n  \"@babel/register\": \"^7.9.0\",\n  \"babel-eslint\": \"^10.1.0\",\n  \"babel-preset-minify\": \"^0.5.1\",\n  chai: \"^4.2.0\",\n  eslint: \"^7.0.0\",\n  \"eslint-config-airbnb-base\": \"^14.1.0\",\n  \"eslint-config-prettier\": \"^6.11.0\",\n  \"eslint-plugin-flowtype\": \"^5.1.0\",\n  \"eslint-plugin-flowtype-errors\": \"^4.3.0\",\n  \"eslint-plugin-import\": \"^2.20.2\",\n  \"eslint-plugin-prettier\": \"^3.1.3\",\n  \"flow-bin\": \"^0.125.1\",\n  \"flow-typed\": \"^3.1.0\",\n  jsdoc: \"^3.6.4\",\n  mocha: \"^7.1.2\",\n  mustache: \"^4.0.1\",\n  nyc: \"^15.0.1\",\n  prettier: \"^2.0.5\",\n  rollup: \"^2.10.5\",\n  \"rollup-plugin-babel\": \"^4.4.0\",\n  \"rollup-plugin-commonjs\": \"^10.1.0\",\n  \"rollup-plugin-flow\": \"^1.1.1\",\n  \"rollup-plugin-json\": \"^4.0.0\",\n  \"rollup-plugin-node-builtins\": \"^2.1.2\",\n  \"rollup-plugin-node-globals\": \"^1.4.0\",\n  \"rollup-plugin-node-resolve\": \"^5.2.0\",\n  \"rollup-plugin-terser\": \"^5.3.0\",\n  sinon: \"^9.0.2\"\n};\nvar PackageInfo = {\n  name: name,\n  version: version,\n  description: description,\n  author: author,\n  license: license,\n  main: main,\n  module: module,\n  files: files,\n  scripts: scripts,\n  keywords: keywords,\n  repository: repository,\n  prettier: prettier,\n  dependencies: dependencies,\n  devDependencies: devDependencies\n};\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags) {\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx,\n    nin,\n    flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack,\n    tx,\n    nin,\n    flags\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx,\n      nin,\n      flags\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n\n    return true;\n  }\n\n  return true;\n};\n\nInterpreter.prototype.initialize = function () {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altstack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes\n// script failure. Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to\n// checksig causes that pubkey to be skipped (not softfork safe: this flag can widen the validity\n// of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe,\n// BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script\n// failure (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7)\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible,\n// direct pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger).\n// Evaluating any other push causes the script to fail (BIP62 rule 3). In addition, whenever a\n// stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // CLTV See BIP65 for details.\n\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i += 1) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkSignatureEncoding = function (buf) {\n  var sig;\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = \"SCRIPT_ERR_UNKNOWN_ERROR: \".concat(e);\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; // bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf;\n  var buf1;\n  var buf2;\n  var spliced;\n  var n;\n  var x1;\n  var x2;\n  var bn;\n  var bn1;\n  var bn2;\n  var bufSig;\n  var bufPubkey;\n  var subscript;\n  var sig;\n  var pubkey;\n  var fValue;\n  var fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc += 1;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16) {\n    this.nOpCount += 1;\n\n    if (this.nOpCount > 201) {\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\n      return false;\n    }\n  }\n\n  if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && opcodenum >= 0 && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        // ( -- value)\n        // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n        n = opcodenum - (Opcode.OP_1 - 1);\n        buf = new BN(n).toScriptNumBuffer();\n        this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n        // they push, so no need for a CheckMinimalPush here.\n\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        {\n          if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n            // not enabled; treat as a NOP2\n            if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n              this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n              return false;\n            }\n\n            break;\n          }\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Note that elsewhere numeric opcodes are limited to\n          // operands in the range -2**31+1 to 2**31-1, however it is\n          // legal for opcodes to produce results exceeding that\n          // range. This limitation is implemented by CScriptNum's\n          // default 4-byte limit.\n          //\n          // If we kept to that limit we'd have a year 2038 problem,\n          // even though the nLockTime field in transactions\n          // themselves is uint32 which only becomes meaningless\n          // after the year 2106.\n          //\n          // Thus as a special case we tell CScriptNum to accept up\n          // to 5-byte bignums, which are good until 2**39-1, well\n          // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n          var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n          // some arithmetic being done first, you can always use\n          // 0 MAX CHECKLOCKTIMEVERIFY.\n\n          if (nLockTime.lt(new BN(0))) {\n            this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n            return false;\n          } // Actually compare the specified lock time with the transaction.\n\n\n          if (!this.checkLockTime(nLockTime)) {\n            this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n            return false;\n          }\n\n          break;\n        }\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        // <expression> if [statements] [else [statements]] endif\n        // bool fValue = false;\n        fValue = false;\n\n        if (fExec) {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          buf = this.stack.pop();\n          fValue = Interpreter.castToBool(buf);\n\n          if (opcodenum === Opcode.OP_NOTIF) {\n            fValue = !fValue;\n          }\n        }\n\n        this.vfExec.push(fValue);\n        break;\n\n      case Opcode.OP_ELSE:\n        if (this.vfExec.length === 0) {\n          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n          return false;\n        }\n\n        this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        break;\n\n      case Opcode.OP_ENDIF:\n        if (this.vfExec.length === 0) {\n          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n          return false;\n        }\n\n        this.vfExec.pop();\n        break;\n\n      case Opcode.OP_VERIFY:\n        // (true -- ) or\n        // (false -- false) and return\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        fValue = Interpreter.castToBool(buf);\n\n        if (fValue) {\n          this.stack.pop();\n        } else {\n          this.errstr = 'SCRIPT_ERR_VERIFY';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_RETURN:\n        this.errstr = 'SCRIPT_ERR_OP_RETURN';\n        return false;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.altstack.push(this.stack.pop());\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        if (this.altstack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.altstack.pop());\n        break;\n\n      case Opcode.OP_2DROP:\n        // (x1 x2 -- )\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.pop();\n        this.stack.pop();\n        break;\n\n      case Opcode.OP_2DUP:\n        // (x1 x2 -- x1 x2 x1 x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf1 = this.stack[this.stack.length - 2];\n        buf2 = this.stack[this.stack.length - 1];\n        this.stack.push(buf1);\n        this.stack.push(buf2);\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n        if (this.stack.length < 4) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf1 = this.stack[this.stack.length - 4];\n        buf2 = this.stack[this.stack.length - 3];\n        this.stack.push(buf1);\n        this.stack.push(buf2);\n        break;\n\n      case Opcode.OP_2ROT:\n        // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n        if (this.stack.length < 6) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        spliced = this.stack.splice(this.stack.length - 6, 2);\n        this.stack.push(spliced[0]);\n        this.stack.push(spliced[1]);\n        break;\n\n      case Opcode.OP_2SWAP:\n        // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n        if (this.stack.length < 4) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        spliced = this.stack.splice(this.stack.length - 4, 2);\n        this.stack.push(spliced[0]);\n        this.stack.push(spliced[1]);\n        break;\n\n      case Opcode.OP_IFDUP:\n        // (x - 0 | x x)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        fValue = Interpreter.castToBool(buf);\n\n        if (fValue) {\n          this.stack.push(buf);\n        }\n\n        break;\n\n      case Opcode.OP_DEPTH:\n        // -- stacksize\n        buf = new BN(this.stack.length).toScriptNumBuffer();\n        this.stack.push(buf);\n        break;\n\n      case Opcode.OP_DROP:\n        // (x -- )\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.pop();\n        break;\n\n      case Opcode.OP_DUP:\n        // (x -- x x)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.stack[this.stack.length - 1]);\n        break;\n\n      case Opcode.OP_NIP:\n        // (x1 x2 -- x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.splice(this.stack.length - 2, 1);\n        break;\n\n      case Opcode.OP_OVER:\n        // (x1 x2 -- x1 x2 x1)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.push(this.stack[this.stack.length - 2]);\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n        // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n        n = bn.toNumber();\n        this.stack.pop();\n\n        if (n < 0 || n >= this.stack.length) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - n - 1];\n\n        if (opcodenum === Opcode.OP_ROLL) {\n          this.stack.splice(this.stack.length - n - 1, 1);\n        }\n\n        this.stack.push(buf);\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        // (x1 x2 -- x2 x1)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        x1 = this.stack[this.stack.length - 2];\n        x2 = this.stack[this.stack.length - 1];\n        this.stack[this.stack.length - 2] = x2;\n        this.stack[this.stack.length - 1] = x1;\n        break;\n\n      case Opcode.OP_TUCK:\n        // (x1 x2 -- x2 x1 x2)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        break;\n\n      case Opcode.OP_SIZE:\n        // (in -- in size)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        bn = new BN(this.stack[this.stack.length - 1].length);\n        this.stack.push(bn.toScriptNumBuffer());\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        // case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        // (in -- out)\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        buf = this.stack[this.stack.length - 1];\n        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n        switch (opcodenum) {\n          case Opcode.OP_1ADD:\n            bn = bn.add(BN.One);\n            break;\n\n          case Opcode.OP_1SUB:\n            bn = bn.sub(BN.One);\n            break;\n\n          case Opcode.OP_NEGATE:\n            bn = bn.neg();\n            break;\n\n          case Opcode.OP_ABS:\n            if (bn.cmp(BN.Zero) < 0) {\n              bn = bn.neg();\n            }\n\n            break;\n\n          case Opcode.OP_NOT:\n            bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n            break;\n\n          case Opcode.OP_0NOTEQUAL:\n            bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n            break;\n\n          default:\n            // We should really not end up in here.\n            throw new Error('Ended up in a default switch statement that should never be executed.');\n        }\n\n        this.stack.pop();\n        this.stack.push(bn.toScriptNumBuffer());\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        // (x1 x2 -- out)\n        if (this.stack.length < 2) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n        bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n        bn = new BN(0);\n\n        switch (opcodenum) {\n          case Opcode.OP_ADD:\n            bn = bn1.add(bn2);\n            break;\n\n          case Opcode.OP_SUB:\n            bn = bn1.sub(bn2);\n            break;\n          // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n\n          case Opcode.OP_BOOLAND:\n            bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n            break;\n          // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n          case Opcode.OP_BOOLOR:\n            bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n            break;\n          // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n          case Opcode.OP_NUMEQUAL:\n            bn = new BN((bn1.cmp(bn2) === 0) + 0);\n            break;\n          // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n          case Opcode.OP_NUMEQUALVERIFY:\n            bn = new BN((bn1.cmp(bn2) === 0) + 0);\n            break;\n          // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n          case Opcode.OP_NUMNOTEQUAL:\n            bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n            break;\n          // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n          case Opcode.OP_LESSTHAN:\n            bn = new BN((bn1.cmp(bn2) < 0) + 0);\n            break;\n          // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n          case Opcode.OP_GREATERTHAN:\n            bn = new BN((bn1.cmp(bn2) > 0) + 0);\n            break;\n          // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n          case Opcode.OP_LESSTHANOREQUAL:\n            bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n            break;\n          // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n          case Opcode.OP_GREATERTHANOREQUAL:\n            bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n            break;\n\n          case Opcode.OP_MIN:\n            bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n            break;\n\n          case Opcode.OP_MAX:\n            bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n            break;\n\n          default:\n            // We should really not end up in here.\n            throw new Error('Ended up in a default switch statement that should never be executed.');\n        }\n\n        this.stack.pop();\n        this.stack.pop();\n        this.stack.push(bn.toScriptNumBuffer());\n\n        if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n          // if (CastToBool(stacktop(-1)))\n          if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n            return false;\n          }\n        }\n\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); // bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1]; // valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        // Hash starts after the code separator\n        this.pbegincodehash = this.pc;\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1]; // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            // invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // int ikey = ++i;\n\n\n          i += 1;\n          var ikey = i;\n          i += nKeysCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          i += 1;\n          var isig = i;\n          i += nSigsCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signatures, since there's no way for a signature to sign itself\n\n          for (var k = 0; k < nSigsCount; k += 1) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig]; // valtype& vchPubKey = stacktop(-ikey);\n\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk = void 0;\n\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              // invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig += 1;\n              nSigsCount -= 1;\n            }\n\n            ikey += 1;\n            nKeysCount -= 1; // If there are more signatures left than keys left,\n            // then too many signatures have failed\n\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i > 1) {\n            i -= 1;\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\nclass ScriptHashInput extends Input {\n  constructor(input, pubkeys, redeemScript) {\n    super(input, pubkeys, redeemScript);\n    var self = this;\n    this.publicKeys = pubkeys || input.publicKeys;\n    this.threshold = 1;\n    this.redeemScript = redeemScript;\n    preconditions.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script), \"Provided redeemScript doesn't hash to the provided output\");\n    this.publicKeyIndex = {};\n    this.publicKeys.forEach((publicKey, index) => {\n      self.publicKeyIndex[publicKey.toString()] = index;\n    }); // Empty array of signatures\n\n    this.signatures = new Array(this.publicKeys.length);\n  }\n\n  toObject() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var obj = Input.prototype.toObject.apply(this, args);\n    obj.threshold = this.threshold;\n    obj.publicKeys = this.publicKeys.map(publicKey => publicKey.toString());\n    obj.signatures = this._serializeSignatures();\n    return obj;\n  }\n\n  _deserializeSignatures(signatures) {\n    return signatures.map(signature => signature ? new TransactionSignature(signature) : undefined);\n  }\n\n  _serializeSignatures() {\n    return this.signatures.map(signature => signature ? signature.toObject() : undefined);\n  }\n\n  getSignatures(transaction, privateKey, index, sigtype) {\n    preconditions.checkState(this.output instanceof Output, 'Malformed output found when signing transaction');\n    sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n    var publicKeysForPrivateKey = this.publicKeys.filter(publicKey => publicKey.toString() === privateKey.publicKey.toString());\n    return publicKeysForPrivateKey.map(publicKey => new TransactionSignature({\n      publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype\n    }));\n  }\n\n  addSignature(transaction, signature) {\n    preconditions.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n    preconditions.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] !== undefined, 'Signature has no matching public key');\n    preconditions.checkState(this.isValidSignature(transaction, signature));\n    this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n    this._updateScript();\n\n    return this;\n  }\n\n  _updateScript() {\n    this.setScript(Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n      cachedMultisig: this.redeemScript\n    }));\n    return this;\n  }\n\n  _createSignatures() {\n    var definedSignatures = this.signatures.filter(signature => signature !== undefined);\n    return definedSignatures.map(signature => BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]));\n  }\n\n  clearSignatures() {\n    this.signatures = new Array(this.publicKeys.length);\n\n    this._updateScript();\n  }\n\n  isFullySigned() {\n    return this.countSignatures() === this.threshold;\n  }\n\n  countMissingSignatures() {\n    return this.threshold - this.countSignatures();\n  }\n\n  countSignatures() {\n    return this.signatures.reduce((sum, signature) => sum + !!signature, 0);\n  }\n\n  publicKeysWithoutSignature() {\n    var self = this;\n    return this.publicKeys.filter(publicKey => !self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  }\n\n  isValidSignature(transaction, signature) {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript, this.output.satoshisBN);\n  }\n\n  _estimateSize() {\n    return ScriptHashInput.OPCODES_SIZE + this.threshold * ScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * ScriptHashInput.PUBKEY_SIZE;\n  }\n\n}\n\nScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\n\nScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\n\nScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\n\nvar TXID_REGEX = /[0-9A-Fa-f]{64}/;\n/**\n * Output identifier for a Bitcoin transaction\n */\n\nclass OutputId {\n  /**\n      Creates an output id from a transaction id and output index\n     * @param {string} txId Transaction id in hex format\n     * @param {number} outputIndex Output index\n     */\n  constructor(txId, outputIndex) {\n    if (!TXID_REGEX.test(txId)) throw new Error(\"txId not in a valid hex format: \".concat(txId));\n    if (outputIndex < 0 || outputIndex > 4294967295 || Number.isNaN(outputIndex)) throw new Error(\"outputIndex out of range: \".concat(outputIndex));\n    this.txId = txId;\n    this.outputIndex = outputIndex;\n  }\n  /**\n   * Serializes the output id into a compressed string form\n   */\n\n\n  toString() {\n    return \"\".concat(this.txId, \":\").concat(this.outputIndex);\n  }\n  /**\n   * Parses the output id form its compressed string form\n   * @param {string} s String to parse\n   */\n\n\n  static fromString(s) {\n    var parts = s.split(':');\n    if (parts.length !== 2) throw new Error('Invalid string format');\n    return new OutputId(parts[0], parseInt(parts[1], 10));\n  }\n  /**\n   * Get the transaction id in hex format\n   */\n\n\n  get txid() {\n    return this.txId;\n  }\n  /**\n   * Get the output index\n   */\n\n\n  get vout() {\n    return this.outputIndex;\n  }\n  /**\n   * Returns whether two OutputIds refer to the same output\n   * @param {OutputId} other Other object to compare\n   * @returns {bool} True if the objects refer to the same output, false if not\n   */\n\n\n  equals(other) {\n    return this.outputIndex === other.outputIndex && this.txId.toLowerCase() === other.txId.toLowerCase();\n  }\n\n}\n/**\n * Bitcore URI\n *\n * Instantiate an URI from a bitcoin cash URI String or an Object. An URI instance\n * can be created with a bitcoin cash uri string or an object. All instances of\n * URI are valid, the static method isValid allows checking before instantiation.\n *\n * All standard parameters can be found as members of the class, the address\n * is represented using an {Address} instance and the amount is represented in\n * satoshis. Any other non-standard parameters can be found under the extra member.\n *\n * @example\n * ```javascript\n *\n * var uri = new URI('bitcoincash:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\n * console.log(uri.address, uri.amount);\n * ```\n *\n * @param {string|Object} data - A bitcoin cash URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n * @returns {URI} A new valid and frozen instance of URI\n * @constructor\n */\n// eslint-disable-next-line consistent-return\n\n\nvar URI = function URI(data, knownParams) {\n  // #weirdstuff refactor\n  if (!(this instanceof URI)) {\n    return new URI(data, knownParams);\n  }\n\n  this.extras = {};\n  this.knownParams = knownParams || [];\n  this.address = null;\n  this.network = null;\n  this.amount = null;\n  this.message = null;\n\n  if (typeof data === 'string') {\n    var params = URI.parse(data);\n\n    if (params.amount) {\n      params.amount = this._parseAmount(params.amount);\n    }\n\n    this._fromObject(params);\n  } else if (typeof data === 'object') {\n    this._fromObject(data);\n  } else {\n    throw new TypeError('Unrecognized data format.');\n  }\n};\n/**\n * Instantiate a URI from a String\n *\n * @param {string} str - JSON string or object of the URI\n * @returns {URI} A new instance of a URI\n */\n\n\nURI.fromString = function fromString(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  return new URI(str);\n};\n/**\n * Instantiate a URI from an Object\n *\n * @param {Object} data - object of the URI\n * @returns {URI} A new instance of a URI\n */\n\n\nURI.fromObject = function fromObject(json) {\n  return new URI(json);\n};\n/**\n * Check if an bitcoin cash URI string is valid\n *\n * @example\n * ```javascript\n *\n * var valid = URI.isValid('bitcoincash:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n * // true\n * ```\n *\n * @param {string|Object} data - A bitcoin cash URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @returns {boolean} Result of uri validation\n */\n\n\nURI.isValid = function (arg, knownParams) {\n  try {\n    // #weirdstuff refactor\n    // eslint-disable-next-line no-new\n    new URI(arg, knownParams);\n  } catch (err) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Convert a bitcoin cash URI string into a simple object.\n *\n * @param {string} uri - A bitcoin cash URI string\n * @throws {TypeError} Invalid bitcoin cash URI\n * @returns {Object} An object with the parsed params\n */\n\n\nURI.parse = function (uri) {\n  var info = URL.parse(uri, true);\n\n  if (info.protocol !== 'bitcoincash:') {\n    throw new TypeError('Invalid bitcoin cash URI');\n  } // workaround to host insensitiveness\n\n\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\n  info.query.address = group && group[1] || undefined;\n  return info.query;\n};\n\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\n/**\n * Internal function to load the URI instance with an object.\n *\n * @param {Object} obj - Object with the information\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n */\n\nURI.prototype._fromObject = function (obj) {\n  if (!Address.isValid(obj.address)) {\n    throw new TypeError('Invalid bitcoin address');\n  }\n\n  this.address = new Address(obj.address);\n  this.network = this.address.network;\n  this.amount = obj.amount;\n  Object.keys(obj).forEach(key => {\n    if (key !== 'address' && key !== 'amount') {\n      if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\n        throw Error(\"Unknown required argument \".concat(key));\n      }\n\n      var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\n      destination[key] = obj[key];\n    }\n  });\n};\n/**\n * Internal function to transform a BTC string amount into satoshis\n *\n * @param {string} amount - Amount BTC string\n * @throws {TypeError} Invalid amount\n * @returns {Object} Amount represented in satoshis\n */\n\n\nURI.prototype._parseAmount = function (amount) {\n  amount = Number(amount);\n\n  if (Number.isNaN(amount)) {\n    throw new TypeError('Invalid amount');\n  }\n\n  return Unit.fromBTC(amount).toSatoshis();\n};\n\nURI.prototype.toJSON = function toObject() {\n  var _this = this;\n\n  var json = {};\n\n  var _loop = function _loop(i) {\n    var m = URI.Members[i];\n\n    if (Object.keys(_this).findIndex(key => key === m) !== 1 && typeof _this[m] !== 'undefined') {\n      json[m] = _this[m].toString();\n    }\n  };\n\n  for (var i = 0; i < URI.Members.length; i += 1) {\n    _loop(i);\n  }\n\n  _.extend(json, this.extras);\n\n  return json;\n};\n\nURI.prototype.toObject = URI.prototype.toJSON;\n/**\n * Will return a the string representation of the URI\n *\n * @returns {string} Bitcoin cash URI string\n */\n\nURI.prototype.toString = function () {\n  var query = {};\n\n  if (this.amount) {\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\n  }\n\n  if (this.message) {\n    query.message = this.message;\n  }\n\n  if (this.label) {\n    query.label = this.label;\n  }\n\n  if (this.r) {\n    query.r = this.r;\n  }\n\n  _.extend(query, this.extras);\n\n  return URL.format({\n    protocol: 'bitcoincash:',\n    host: this.address,\n    query\n  });\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin cash URI\n */\n\n\nURI.prototype.inspect = function () {\n  return \"<URI: \".concat(this.toString(), \">\");\n};\n\nvar Varint = function Varint(buf) {\n  if (!(this instanceof Varint)) return new Varint(buf);\n\n  if (Buffer.isBuffer(buf)) {\n    this.buf = buf;\n  } else if (typeof buf === 'number') {\n    var num = buf;\n    this.fromNumber(num);\n  } else if (buf instanceof BN) {\n    var bn = buf;\n    this.fromBN(bn);\n  } else if (buf) {\n    var obj = buf;\n    this.set(obj);\n  }\n};\n\nVarint.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf;\n  return this;\n};\n\nVarint.prototype.fromString = function (str) {\n  this.set({\n    buf: Buffer.from(str, 'hex')\n  });\n  return this;\n};\n\nVarint.prototype.toString = function () {\n  return this.buf.toString('hex');\n};\n\nVarint.prototype.fromBuffer = function (buf) {\n  this.buf = buf;\n  return this;\n};\n\nVarint.prototype.fromBufferReader = function (br) {\n  this.buf = br.readVarintBuf();\n  return this;\n};\n\nVarint.prototype.fromBN = function (bn) {\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\n  return this;\n};\n\nVarint.prototype.fromNumber = function (num) {\n  this.buf = BufferWriter().writeVarintNum(num).concat();\n  return this;\n};\n\nVarint.prototype.toBuffer = function () {\n  return this.buf;\n};\n\nVarint.prototype.toBN = function () {\n  return BufferReader(this.buf).readVarintBN();\n};\n\nVarint.prototype.toNumber = function () {\n  return BufferReader(this.buf).readVarintNum();\n};\n\nvar Bitcoin = {}; // module information\n\nBitcoin.version = \"v\".concat(PackageInfo.version); // eslint-disable-next-line no-unused-vars\n\nBitcoin.versionGuard = function (version) {// if (version !== undefined) {\n  //   var message = 'More than one instance of bitcoincashjs found. ' +\n  //     'Please make sure to require bitcoincashjs and check that submodules do' +\n  //     ' not also include their own bitcoincashjs dependency.';\n  //   throw new Error(message);\n  // }\n};\n\nBitcoin.versionGuard(global._bitcoin);\nglobal._bitcoin = Bitcoin.version; // crypto\n\nBitcoin.crypto = {};\nBitcoin.crypto.BN = BN;\nBitcoin.crypto.ECDSA = ECDSA;\nBitcoin.crypto.Hash = Hash;\nBitcoin.crypto.Random = Random;\nBitcoin.crypto.Point = Point;\nBitcoin.crypto.Signature = Signature; // encoding\n\nBitcoin.encoding = {};\nBitcoin.encoding.Base58 = Base58;\nBitcoin.encoding.Base58Check = Base58Check;\nBitcoin.encoding.BufferReader = BufferReader;\nBitcoin.encoding.BufferWriter = BufferWriter;\nBitcoin.encoding.Varint = Varint; // utilities\n\nBitcoin.util = {};\nBitcoin.util.buffer = BufferUtil;\nBitcoin.util.js = JSUtil;\nBitcoin.util.preconditions = preconditions; // errors thrown by the library\n\nBitcoin.errors = errors; // main bitcoin library\n\nBitcoin.Address = Address;\nBitcoin.Block = Block;\nBitcoin.Block.BlockHeader = BlockHeader;\nBitcoin.Block.MerkleBlock = MerkleBlock;\nBitcoin.BlockHeader = BlockHeader;\nBitcoin.HDPrivateKey = HDPrivateKey;\nBitcoin.HDPublicKey = HDPublicKey;\nBitcoin.MerkleBlock = MerkleBlock;\nBitcoin.Message = Message;\nBitcoin.Mnemonic = Mnemonic;\nBitcoin.Networks = Networks;\nBitcoin.Opcode = Opcode;\nBitcoin.PrivateKey = PrivateKey;\nBitcoin.PublicKey = PublicKey;\nBitcoin.Script = Script;\nBitcoin.Script.Interpreter = Interpreter;\nBitcoin.Transaction = Transaction;\nBitcoin.Transaction.Input = Input;\nBitcoin.Transaction.Input.MultiSig = MultiSigInput;\nBitcoin.Transaction.Input.MultiSigScriptHash = MultiSigScriptHashInput;\nBitcoin.Transaction.Input.PublicKey = PublicKeyInput;\nBitcoin.Transaction.Input.PublicKeyHash = PublicKeyHashInput;\nBitcoin.Transaction.Input.ScriptHash = ScriptHashInput;\nBitcoin.Transaction.Output = Output;\nBitcoin.Transaction.OutputId = OutputId;\nBitcoin.Transaction.Sighash = Sighash;\nBitcoin.Transaction.Signature = TransactionSignature;\nBitcoin.Transaction.UnspentOutput = UnspentOutput;\nBitcoin.Unit = Unit;\nBitcoin.URI = URI; // dependencies, subject to change\n\nBitcoin.deps = {};\nBitcoin.deps.bnjs = BN;\nBitcoin.deps.bs58 = bs58;\nBitcoin.deps.Buffer = Buffer;\nBitcoin.deps.elliptic = elliptic;\nBitcoin.deps._ = _;\nexport default Bitcoin;","map":null,"metadata":{},"sourceType":"module"}